<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Ninja V2.11.6 - Completion Zone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- V2.5.0-SYNC: Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Suppress Tailwind CDN warning in console -->
    <script>
        if (typeof console !== 'undefined' && console.warn) {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && typeof args[0] === 'string' && args[0].includes('cdn.tailwindcss.com')) {
                    return; // Suppress Tailwind CDN warning
                }
                originalWarn.apply(console, args);
            };
        }
    </script>
    
    <style>
        body { 
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-y pinch-zoom;
            /* V2.6.3: Prevent scroll jumps during re-renders */
            overflow-anchor: none;
        }
        /* V2.6.3: Disable smooth scroll - causes issues during rapid updates */
        html { scroll-behavior: auto; }
        
        /* V2.6.3: Prevent layout shifts */
        #root {
            min-height: 100vh;
            /* contain removed - breaks drag positioning */
        }
        
        /* Drag and Drop Styles */
        .dragging { 
            opacity: 0.4; 
            cursor: grabbing;
            /* DON'T use pointer-events: none - it breaks drag in some browsers */
        }
        .drag-over { 
            background-color: rgba(99, 102, 241, 0.1); 
            border: 2px dashed #6366f1;
        }
        .draggable { cursor: grab; }
        .draggable:active { cursor: grabbing; }
        
        /* Touch device long-press feedback */
        @keyframes pulse-grab {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .long-press-active { animation: pulse-grab 0.3s ease-in-out; }
        
        /* Smooth transitions */
        .task-card { transition: all 0.2s ease-in-out; }
        .task-card:hover { transform: translateY(-2px); box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        /* Calendar cell styling */
        .calendar-cell { min-height: 100px; }
        .calendar-cell.has-tasks { background-color: rgba(99, 102, 241, 0.05); }
        
        /* Toast notification - V2.6.3: Top center for better mobile visibility */
        .toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            animation: slideDown 0.3s ease-out;
            z-index: 9999;
            max-width: 90vw;
        }
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        /* Gantt chart styles */
        .gantt-bar {
            height: 30px;
            border-radius: 4px;
            position: absolute;
            cursor: ew-resize;
        }
        
        /* Loading skeleton */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s ease-in-out infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* Modal backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            animation: fadeIn 0.2s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
    
    <!-- V2.11.6: Global Scroll Preservation Manager -->
    <script>
    (function() {
        // Save scroll position globally (outside React)
        let savedScrollPos = 0;
        let isRestoring = false;
        
        // Save scroll position continuously
        window.addEventListener('scroll', function() {
            if (!isRestoring) {
                savedScrollPos = window.pageYOffset || document.documentElement.scrollTop;
            }
        }, { passive: true });
        
        // Restore scroll after any DOM mutation
        const observer = new MutationObserver(function() {
            if (savedScrollPos > 0 && !isRestoring) {
                isRestoring = true;
                requestAnimationFrame(function() {
                    window.scrollTo(0, savedScrollPos);
                    setTimeout(function() {
                        window.scrollTo(0, savedScrollPos);
                        isRestoring = false;
                    }, 0);
                });
            }
        });
        
        // Start observing when DOM is ready
        if (document.body) {
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: false
            });
        } else {
            document.addEventListener('DOMContentLoaded', function() {
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: false
                });
            });
        }
        
        // Export for debugging
        window.__scrollManager = {
            getSavedPos: function() { return savedScrollPos; },
            restore: function() { window.scrollTo(0, savedScrollPos); }
        };
    })();
    </script>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const { createRoot, flushSync } = ReactDOM;
        
        // Lucide icons
        const Calendar = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('rect', {x: "3", y: "4", width: "18", height: "18", rx: "2", ry: "2"}), React.createElement('line', {x1: "16", y1: "2", x2: "16", y2: "6"}), React.createElement('line', {x1: "8", y1: "2", x2: "8", y2: "6"}), React.createElement('line', {x1: "3", y1: "10", x2: "21", y2: "10"}));
        const CheckCircle = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M22 11.08V12a10 10 0 1 1-5.93-9.14"}), React.createElement('polyline', {points: "22 4 12 14.01 9 11.01"}));
        const Circle = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "12", cy: "12", r: "10"}));
        const Play = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polygon', {points: "5 3 19 12 5 21 5 3"}));
        const Plus = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('line', {x1: "12", y1: "5", x2: "12", y2: "19"}), React.createElement('line', {x1: "5", y1: "12", x2: "19", y2: "12"}));
        const X = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('line', {x1: "18", y1: "6", x2: "6", y2: "18"}), React.createElement('line', {x1: "6", y1: "6", x2: "18", y2: "18"}));
        const ChevronDown = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "6 9 12 15 18 9"}));
        const ChevronUp = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "18 15 12 9 6 15"}));
        const ChevronRight = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "9 18 15 12 9 6"}));
        const ChevronLeft = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "15 18 9 12 15 6"}));
        const Settings = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "12", cy: "12", r: "3"}), React.createElement('path', {d: "M12 1v6m0 6v6m5.66-13.66L14 8.66m-4 4l-3.66 3.66M1 12h6m6 0h6M4.34 19.66L8 16m4-4l3.66-3.66"}));
        const Target = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "12", cy: "12", r: "10"}), React.createElement('circle', {cx: "12", cy: "12", r: "6"}), React.createElement('circle', {cx: "12", cy: "12", r: "2"}));
        const Clock = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "12", cy: "12", r: "10"}), React.createElement('polyline', {points: "12 6 12 12 16 14"}));
        const User = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"}), React.createElement('circle', {cx: "12", cy: "7", r: "4"}));
        const Briefcase = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('rect', {x: "2", y: "7", width: "20", height: "14", rx: "2", ry: "2"}), React.createElement('path', {d: "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"}));
        const Upload = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"}), React.createElement('polyline', {points: "17 8 12 3 7 8"}), React.createElement('line', {x1: "12", y1: "3", x2: "12", y2: "15"}));
        const Download = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"}), React.createElement('polyline', {points: "7 10 12 15 17 10"}), React.createElement('line', {x1: "12", y1: "15", x2: "12", y2: "3"}));
        const FileUp = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"}), React.createElement('polyline', {points: "14 2 14 8 20 8"}), React.createElement('polyline', {points: "12 18 12 12 15 15"}), React.createElement('polyline', {points: "9 15 12 12"}));
        const FileText = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"}), React.createElement('polyline', {points: "14 2 14 8 20 8"}), React.createElement('line', {x1: "16", y1: "13", x2: "8", y2: "13"}), React.createElement('line', {x1: "16", y1: "17", x2: "8", y2: "17"}), React.createElement('polyline', {points: "10 9 9 9 8 9"}));
        const ArrowRight = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('line', {x1: "5", y1: "12", x2: "19", y2: "12"}), React.createElement('polyline', {points: "12 5 19 12 12 19"}));
        const MoveHorizontal = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "18 8 22 12 18 16"}), React.createElement('polyline', {points: "6 8 2 12 6 16"}), React.createElement('line', {x1: "2", y1: "12", x2: "22", y2: "12"}));
        const Tag = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"}), React.createElement('line', {x1: "7", y1: "7", x2: "7.01", y2: "7"}));
        const Filter = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polygon', {points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"}));
        const Search = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "11", cy: "11", r: "8"}), React.createElement('path', {d: "m21 21-4.35-4.35"}));
        const BarChart3 = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M3 3v18h18"}), React.createElement('path', {d: "M18 17V9"}), React.createElement('path', {d: "M13 17V5"}), React.createElement('path', {d: "M8 17v-3"}));
        const BarChart2 = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('line', {x1: "18", y1: "20", x2: "18", y2: "10"}), React.createElement('line', {x1: "12", y1: "20", x2: "12", y2: "4"}), React.createElement('line', {x1: "6", y1: "20", x2: "6", y2: "14"}));
        const List = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('line', {x1: "8", y1: "6", x2: "21", y2: "6"}), React.createElement('line', {x1: "8", y1: "12", x2: "21", y2: "12"}), React.createElement('line', {x1: "8", y1: "18", x2: "21", y2: "18"}), React.createElement('line', {x1: "3", y1: "6", x2: "3.01", y2: "6"}), React.createElement('line', {x1: "3", y1: "12", x2: "3.01", y2: "12"}), React.createElement('line', {x1: "3", y1: "18", x2: "3.01", y2: "18"}));
        const Kanban = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M6 5v11"}), React.createElement('path', {d: "M12 5v6"}), React.createElement('path', {d: "M18 5v14"}));
        const Archive = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "21 8 21 21 3 21 3 8"}), React.createElement('rect', {x: "1", y: "3", width: "22", height: "5"}), React.createElement('line', {x1: "10", y1: "12", x2: "14", y2: "12"}));
        const Trophy = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6"}), React.createElement('path', {d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18"}), React.createElement('path', {d: "M4 22h16"}), React.createElement('path', {d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"}), React.createElement('path', {d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"}), React.createElement('path', {d: "M18 2H6v7a6 6 0 0 0 12 0V2Z"}));
        const Copy = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('rect', {x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2"}), React.createElement('path', {d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"}));
        const Trash2 = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "3 6 5 6 21 6"}), React.createElement('path', {d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"}), React.createElement('line', {x1: "10", y1: "11", x2: "10", y2: "17"}), React.createElement('line', {x1: "14", y1: "11", x2: "14", y2: "17"}));
        const Check = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "20 6 9 17 4 12"}));
        const Edit2 = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"}));
        const Info = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "12", cy: "12", r: "10"}), React.createElement('line', {x1: "12", y1: "16", x2: "12", y2: "12"}), React.createElement('line', {x1: "12", y1: "8", x2: "12.01", y2: "8"}));
        const TrendingUp = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('polyline', {points: "23 6 13.5 15.5 8.5 10.5 1 18"}), React.createElement('polyline', {points: "17 6 23 6 23 12"}));
        const GripVertical = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('circle', {cx: "9", cy: "12", r: "1"}), React.createElement('circle', {cx: "9", cy: "5", r: "1"}), React.createElement('circle', {cx: "9", cy: "19", r: "1"}), React.createElement('circle', {cx: "15", cy: "12", r: "1"}), React.createElement('circle', {cx: "15", cy: "5", r: "1"}), React.createElement('circle', {cx: "15", cy: "19", r: "1"}));
        const LogOut = (props) => React.createElement('svg', {...props, xmlns: "http://www.w3.org/2000/svg", width: props.size || 24, height: props.size || 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement('path', {d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"}), React.createElement('polyline', {points: "16 17 21 12 16 7"}), React.createElement('line', {x1: "21", y1: "12", x2: "9", y2: "12"}));

        // ============================================================================
        // V2.5.0-SYNC: SUPABASE INITIALIZATION
        // ============================================================================
        
        const SUPABASE_URL = 'https://edhwloqbyoqmsqpnnyce.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVkaHdsb3FieW9xbXNxcG5ueWNlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY2NzMyMTMsImV4cCI6MjA4MjI0OTIxM30.APpg2WmEsR8BiwOoO9dsBap3O0eAGv8qBwTDTFA7Ccs';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // V2.5.13-FIX: Better device detection
        const getDeviceId = () => {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
            const isTablet = /iPad|Android(?!.*Mobile)/i.test(userAgent);
            
            if (isMobile || isTablet) {
                return 'Mobile';
            }
            return 'Desktop';
        };
        
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üöÄ VERSION: V2.11.6-COMPLETION-ZONE-JAN20-2030 üöÄ');
        console.log('üèÜ NEW: Completion Zone for vaulted tasks');
        console.log('‚úÖ Completed tasks ‚Üí Trophy icon ‚Üí Move to zone');
        console.log('‚úÖ Scroll fix working (MutationObserver)');
        console.log('‚úÖ Drill-down analytics on cards');
        console.log('üìä Points persist, tasks hidden from views');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üñ•Ô∏è Device detected:', getDeviceId());
        
        console.log('‚úÖ Supabase ready');

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        // Date helpers
        const formatDate = (date) => {
            if (!date) return null;
            const d = new Date(date);
            // Use local timezone instead of UTC
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        
        // NEW: Format date for display (DD/MM/YYYY)
        const formatDateDisplay = (date) => {
            if (!date) return null;
            // Handle ISO string dates (from Supabase)
            const d = typeof date === 'string' ? new Date(date) : date;
            // Use UTC to avoid timezone issues
            const day = String(d.getUTCDate()).padStart(2, '0');
            const month = String(d.getUTCMonth() + 1).padStart(2, '0');
            const year = d.getUTCFullYear();
            return `${day}/${month}/${year}`;
        };

        const parseDate = (dateStr) => {
            if (!dateStr) return null;
            return new Date(dateStr);
        };

        const isSameDay = (date1, date2) => {
            if (!date1 || !date2) return false;
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            return d1.getFullYear() === d2.getFullYear() &&
                   d1.getMonth() === d2.getMonth() &&
                   d1.getDate() === d2.getDate();
        };

        const getDaysInMonth = (year, month) => {
            return new Date(year, month + 1, 0).getDate();
        };

        const getFirstDayOfMonth = (year, month) => {
            return new Date(year, month, 1).getDay();
        };

        const addDays = (date, days) => {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        };

        const daysBetween = (date1, date2) => {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            const diffTime = d2.getTime() - d1.getTime();
            return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        };

        // Score calculator with bonus multipliers
        const calculateTaskScore = (task) => {
            if (!task) return 0;
            
            let basePoints = 0;
            if (task.status === 'completed') {
                if (task.isOldTask) basePoints = 2;
                else if (task.taskType === 'growth') basePoints = 5;
                else if (task.taskType === 'consistency') basePoints = 3;
                else basePoints = 2;

                // Apply early completion bonus
                if (task.dueDate && task.completedAt) {
                    const daysDiff = daysBetween(task.completedAt, task.dueDate);
                    if (daysDiff === 0) basePoints *= 1.5; // On time: +50%
                    else if (daysDiff === 1) basePoints *= 1.75; // 1 day early: +75%
                    else if (daysDiff >= 2) basePoints *= 2.0; // 2+ days early: +100%
                    // Late completion gets no bonus
                }
            } else if (task.status === 'in-progress') {
                basePoints = 1;
            }
            
            // V2.7.0: Add priority rating bonus (0-10 points)
            const priorityBonus = task.priority_rating !== undefined ? task.priority_rating : 5;
            
            return Math.round(basePoints + priorityBonus);
        };

        // Recurring task helper
        const getNextRecurrence = (task) => {
            if (!task.recurringPattern || !task.scheduledDate) return null;
            
            const current = new Date(task.scheduledDate);
            let next = new Date(current);
            
            switch(task.recurringPattern) {
                case 'daily':
                    next.setDate(current.getDate() + 1);
                    break;
                case 'weekly':
                    next.setDate(current.getDate() + 7);
                    break;
                case 'monthly':
                    next.setMonth(current.getMonth() + 1);
                    break;
                default:
                    return null;
            }
            
            return formatDate(next);
        };

        // Local storage helper with auto-save
        const useStickyState = (defaultValue, key) => {
            const [value, setValue] = useState(() => {
                try {
                    const stickyValue = window.localStorage.getItem(key);
                    return stickyValue !== null ? JSON.parse(stickyValue) : defaultValue;
                } catch (error) {
                    console.error('Error loading from localStorage:', error);
                    return defaultValue;
                }
            });
            
            useEffect(() => {
                try {
                    window.localStorage.setItem(key, JSON.stringify(value));
                } catch (error) {
                    console.error('Error saving to localStorage:', error);
                }
            }, [key, value]);
            
            return [value, setValue];
        };

        // ============================================================================
        // DATE/TIME UTILITY FUNCTIONS (V2.4.0 - FR-1: Single Source of Truth)
        // ============================================================================
        // These pure functions compute derived values from stored task properties.
        // NEVER store these computed values in localStorage.
        // ============================================================================

        /**
         * Get array of all dates a task spans (inclusive)
         * @param {Object} task - Task object
         * @returns {string[]} Array of date strings (YYYY-MM-DD)
         * @example ['2025-01-15', '2025-01-16', '2025-01-17']
         */
        const getTaskDateRange = (task) => {
          if (!task?.scheduledDate) return [];
          
          // Parse dates as local midnight to avoid timezone issues
          const parseLocalDate = (dateStr) => {
            const [year, month, day] = dateStr.split('-').map(Number);
            return new Date(year, month - 1, day);
          };
          
          const startDate = parseLocalDate(task.scheduledDate);
          const endDate = task.dueDate 
            ? parseLocalDate(task.dueDate)
            : startDate;
          
          // Handle invalid dates
          if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            console.warn('‚ö†Ô∏è Invalid date in task:', task.id, task.text);
            return [];
          }
          
          const dates = [];
          const current = new Date(startDate);
          
          while (current <= endDate) {
            // Format as YYYY-MM-DD using local timezone
            const year = current.getFullYear();
            const month = String(current.getMonth() + 1).padStart(2, '0');
            const day = String(current.getDate()).padStart(2, '0');
            dates.push(`${year}-${month}-${day}`);
            current.setDate(current.getDate() + 1);
          }
          
          return dates;
        };

        /**
         * Get number of days a task spans
         * @param {Object} task - Task object
         * @returns {number} Number of days (minimum 1)
         */
        const getTaskDaysSpan = (task) => {
          const dateRange = getTaskDateRange(task);
          return Math.max(1, dateRange.length);
        };

        /**
         * Get end time of task based on timeSlot + estimatedDuration
         * @param {Object} task - Task object
         * @returns {string|null} End time (HH:MM) or null if no timeSlot
         */
        const getTaskEndTime = (task) => {
          if (!task?.timeSlot || !task?.estimatedDuration) return null;
          
          try {
            const [hours, minutes] = task.timeSlot.split(':').map(Number);
            const startMinutes = hours * 60 + minutes;
            const endMinutes = startMinutes + task.estimatedDuration;
            
            const endHours = Math.floor(endMinutes / 60);
            const endMins = endMinutes % 60;
            
            return `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;
          } catch (error) {
            console.warn('‚ö†Ô∏è Error calculating end time:', task.id, error);
            return null;
          }
        };

        /**
         * Check if task spans multiple days
         * @param {Object} task - Task object
         * @returns {boolean} True if task spans 2+ days
         */
        const getTaskIsMultiDay = (task) => {
          return getTaskDaysSpan(task) > 1;
        };

        /**
         * Check if task is scheduled for a specific date
         * @param {Object} task - Task object
         * @param {string} date - Date string (YYYY-MM-DD)
         * @returns {boolean} True if task occurs on this date
         */
        const getTaskIsScheduledForDate = (task, date) => {
          if (!task?.scheduledDate) return false;
          
          // SPECIAL CASE: ALWAYS show on scheduled date (even if date range is invalid)
          // This matches original Calendar behavior for tasks with scheduledDate > dueDate
          if (task.scheduledDate === date) return true;
          
          // For multi-day tasks, check if date is in range
          const dateRange = getTaskDateRange(task);
          return dateRange.includes(date);
        };

        /**
         * Get array of 15-minute time slots occupied by task
         * @param {Object} task - Task object
         * @returns {string[]} Array of time slot strings (HH:MM)
         * @example ['09:00', '09:15', '09:30', '09:45'] for 1-hour task at 9am
         */
        const getTaskTimeSlots = (task) => {
          if (!task?.timeSlot || !task?.estimatedDuration) return [];
          
          try {
            const [hours, minutes] = task.timeSlot.split(':').map(Number);
            const startMinutes = hours * 60 + minutes;
            const endMinutes = startMinutes + task.estimatedDuration;
            
            const slots = [];
            for (let min = startMinutes; min < endMinutes; min += 15) {
              const h = Math.floor(min / 60);
              const m = min % 60;
              slots.push(`${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`);
            }
            
            return slots;
          } catch (error) {
            console.warn('‚ö†Ô∏è Error calculating time slots:', task.id, error);
            return [];
          }
        };

        /**
         * Get task start time as minutes from midnight (for calculations)
         * @param {Object} task - Task object
         * @returns {number|null} Minutes from midnight (0-1439) or null
         */
        const getTaskStartMinutes = (task) => {
          if (!task?.timeSlot) return null;
          
          try {
            const [hours, minutes] = task.timeSlot.split(':').map(Number);
            return hours * 60 + minutes;
          } catch (error) {
            console.warn('‚ö†Ô∏è Error parsing start time:', task.id, error);
            return null;
          }
        };

        /**
         * Get task end time as minutes from midnight (for calculations)
         * @param {Object} task - Task object
         * @returns {number|null} Minutes from midnight (0-1439) or null
         */
        const getTaskEndMinutes = (task) => {
          const startMinutes = getTaskStartMinutes(task);
          if (startMinutes === null || !task?.estimatedDuration) return null;
          
          return startMinutes + task.estimatedDuration;
        };

        // ============================================================================
        // END DATE/TIME UTILITIES
        // ============================================================================


        // ============================================================================
        // TOAST NOTIFICATION COMPONENT
        // ============================================================================

        const Toast = ({ message, onClose, showUndo, onUndo }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    // V2.8.0 FIX: Preserve focus when toast closes
                    const activeElement = document.activeElement;
                    onClose();
                    // Restore focus after toast removal
                    setTimeout(() => {
                        if (activeElement && activeElement !== document.body) {
                            activeElement.focus();
                        }
                    }, 0);
                }, 3000);
                return () => clearTimeout(timer);
            }, [onClose]);

            // V2.8.0 FIX: Also preserve focus on manual close
            const handleManualClose = () => {
                const activeElement = document.activeElement;
                onClose();
                setTimeout(() => {
                    if (activeElement && activeElement !== document.body) {
                        activeElement.focus();
                    }
                }, 0);
            };

            return (
                <div className="toast flex items-center gap-3">
                    <Info size={20} />
                    <span>{message}</span>
                    {showUndo && (
                        <button 
                            onClick={onUndo}
                            className="ml-2 px-3 py-1 bg-white text-gray-900 rounded text-sm font-semibold hover:bg-gray-100"
                        >
                            Undo
                        </button>
                    )}
                    <button onClick={handleManualClose} className="ml-2 hover:opacity-70">
                        <X size={16} />
                    </button>
                </div>
            );
        };

        // ============================================================================
        // MAIN LIFE NINJA APP COMPONENT
        // ============================================================================

        const LifeNinjaApp = () => {
            // ====== V2.5.0-SYNC: EMAIL/PASSWORD AUTHENTICATION ======
            const [user, setUser] = useState(null);
            const [authMode, setAuthMode] = useState('login'); // 'login' or 'signup'
            const [authEmail, setAuthEmail] = useState('');
            const [authPassword, setAuthPassword] = useState('');
            const [authLoading, setAuthLoading] = useState(true);
            const [authError, setAuthError] = useState('');
            
            // Check for existing session on mount
            useEffect(() => {
                supabase.auth.getSession().then(({ data: { session } }) => {
                    setUser(session?.user ?? null);
                    setAuthLoading(false);
                });

                // Listen for auth changes
                const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
                    setUser(session?.user ?? null);
                });

                return () => subscription.unsubscribe();
            }, []);
            
            const handleEmailSignup = async () => {
                try {
                    setAuthError('');
                    setAuthLoading(true);
                    const { data, error } = await supabase.auth.signUp({
                        email: authEmail,
                        password: authPassword,
                    });
                    if (error) throw error;
                    console.log('‚úÖ Signup successful, check email for verification');
                    setAuthError('‚úÖ Check your email to verify your account!');
                } catch (error) {
                    console.error('‚ùå Signup error:', error);
                    setAuthError(error.message);
                } finally {
                    setAuthLoading(false);
                }
            };
            
            const handleEmailLogin = async () => {
                try {
                    setAuthError('');
                    setAuthLoading(true);
                    const { data, error } = await supabase.auth.signInWithPassword({
                        email: authEmail,
                        password: authPassword,
                    });
                    if (error) throw error;
                    console.log('‚úÖ Login successful');
                } catch (error) {
                    console.error('‚ùå Login error:', error);
                    setAuthError(error.message);
                } finally {
                    setAuthLoading(false);
                }
            };
            
            const handleLogout = async () => {
                try {
                    console.log('üö™ Logging out...');
                    await supabase.auth.signOut();
                    
                    // V2.7.1 FIX: Clear ALL sync flags and local data
                    localStorage.removeItem('ln_has_synced_to_supabase');
                    localStorage.removeItem('ln_has_synced_events_to_supabase');
                    localStorage.removeItem('ln_has_synced_lists_to_supabase');
                    localStorage.removeItem('ln_customLists'); // Clear local lists
                    
                    console.log('‚úÖ Logged out successfully, cleared all local data');
                    
                    // Force full page reload (more aggressive than window.location.reload())
                    window.location.href = window.location.href;
                } catch (error) {
                    console.error('‚ùå Logout error:', error);
                    // Force reload anyway
                    window.location.href = window.location.href;
                }
            };
            
            // ====== V2.5.0-SYNC: SUPABASE SYNC FUNCTIONS ======
            const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'synced', 'error'
            const [lastSyncTime, setLastSyncTime] = useState(null);
            const [needsMigration, setNeedsMigration] = useState(false);
            const [isLoadingFromSupabase, setIsLoadingFromSupabase] = useState(false);
            const [hasSyncedOnce, setHasSyncedOnce] = useState(false);
            const [hasEventsSynced, setHasEventsSynced] = useState(false);
            
            // Check if we need to migrate localStorage tasks to Supabase
            useEffect(() => {
                const checkMigration = async () => {
                    if (!user) return;
                    
                    // CRITICAL: Check flag FIRST - if already synced, NEVER show banner
                    const hasAlreadySynced = localStorage.getItem('ln_has_synced_to_supabase') === 'true';
                    if (hasAlreadySynced) {
                        setHasSyncedOnce(true);
                        setNeedsMigration(false); // Explicitly set to false
                        console.log('‚úÖ Already synced - skipping migration check');
                        return;
                    }
                    
                    // Check if we have localStorage tasks
                    const localTasks = JSON.parse(localStorage.getItem('ln_tasks') || '[]');
                    if (localTasks.length === 0) {
                        // No local tasks, just mark as synced
                        localStorage.setItem('ln_has_synced_to_supabase', 'true');
                        setHasSyncedOnce(true);
                        return;
                    }
                    
                    // Check if Supabase has any tasks
                    try {
                        const { count, error } = await supabase
                            .from('tasks')
                            .select('*', { count: 'exact', head: true });
                        
                        if (error) throw error;
                        
                        // If no tasks in Supabase but have local tasks, need migration
                        if (count === 0) {
                            setNeedsMigration(true);
                            console.log('üì§ Migration needed:', localTasks.length, 'tasks in localStorage');
                        } else {
                            // Has tasks in Supabase - mark as already synced
                            localStorage.setItem('ln_has_synced_to_supabase', 'true');
                            setHasSyncedOnce(true);
                            console.log('‚úÖ Supabase has', count, 'tasks - no migration needed');
                        }
                    } catch (error) {
                        console.error('‚ùå Error checking migration:', error);
                    }
                };
                
                checkMigration();
            }, [user]);
            
            // SURGICAL FIX #5: Time format helper functions (accessible globally)
            const normalizeTimeSlot = (timeSlot) => {
                if (!timeSlot) return null;
                // If already HH:mm:ss format, return as-is
                if (/^\d{2}:\d{2}:\d{2}$/.test(timeSlot)) return timeSlot;
                // If HH:mm format, add :00
                if (/^\d{2}:\d{2}$/.test(timeSlot)) return `${timeSlot}:00`;
                // Otherwise return as-is
                return timeSlot;
            };
            
            const denormalizeTimeSlot = (timeSlot) => {
                if (!timeSlot) return null;
                // If HH:mm:ss format ending in :00, strip seconds
                if (/^\d{2}:\d{2}:00$/.test(timeSlot)) {
                    return timeSlot.substring(0, 5); // "16:30:00" ‚Üí "16:30"
                }
                // Otherwise return as-is
                return timeSlot;
            };
            
            // Save a single task to Supabase
            const saveTaskToSupabase = async (task, options = {}) => {
                if (!user) return;
                if (isLoadingFromSupabase) return; // Don't save while loading!
                
                try {
                    setSyncStatus('syncing');
                    
                    // V2.5.11-FIX: Optionally exclude manualOrder from saves
                    // This prevents property edits from overwriting order
                    const { excludeManualOrder = false } = options;
                    
                    // Prepare task for Supabase (remove id if it's a new task)
                    const taskData = {
                        user_id: user.id,
                        text: task.text,
                        scheduled_date: task.scheduledDate || null,
                        due_date: task.dueDate || null,
                        time_slot: normalizeTimeSlot(task.timeSlot),
                        estimated_duration: task.estimatedDuration || 30,
                        status: task.status || 'not-started',
                        priority: task.priority || 'medium',
                        priority_rating: task.priority_rating !== undefined ? task.priority_rating : 5, // V2.7.0
                        task_type: task.taskType || null,
                        persona: task.persona || null,
                        project: task.project || null,
                        tags: task.tags || [],
                        notes: task.notes || null,
                        archived: task.archived || false,
                        is_old_task: task.isOldTask || false,
                        subtasks: task.subtasks || []
                    };
                    
                    // V2.10.2: Device tracking enabled (SQL migration completed)
                    const deviceId = getDeviceId();
                    const isNewTask = !task.supabaseId;
                    if (isNewTask) {
                        taskData.created_device = deviceId;
                    }
                    taskData.last_edited_device = deviceId;
                    
                    // V2.5.12-MANUAL-SYNC: Manual order tracking
                    if (!excludeManualOrder) {
                        taskData.manual_order = task.manualOrder || null;
                        taskData.last_ordered_device = getDeviceId();  // V2.10.2: Re-enabled
                        taskData.last_ordered_at = new Date().toISOString();
                    }
                    
                    // Check if task already exists in Supabase (by checking if we have a supabaseId)
                    if (task.supabaseId) {
                        // Update existing task
                        const { data, error } = await supabase
                            .from('tasks')
                            .update(taskData)
                            .eq('id', task.supabaseId)
                            .eq('user_id', user.id)
                            .select()
                            .single();
                        
                        if (error) throw error;
                        
                        console.log('‚úÖ Task updated in Supabase:', data.id);
                        setSyncStatus('synced');
                        // V2.6.3-FOCUS: Suppress lastSyncTime update during rapid entry
                        if (!isCreatingTasksRef.current) {
                            setLastSyncTime(new Date());
                        }
                        return data;
                    } else {
                        // Insert new task
                        const { data, error } = await supabase
                            .from('tasks')
                            .insert([taskData])
                            .select()
                            .single();
                        
                        if (error) throw error;
                        
                        console.log('‚úÖ Task saved to Supabase:', data.id);
                        
                        // Don't update here - let caller handle ID update
                        
                        setSyncStatus('synced');
                        // V2.6.3-FOCUS: Suppress lastSyncTime update during rapid entry
                        if (!isCreatingTasksRef.current) {
                            setLastSyncTime(new Date());
                        }
                        return data;
                    }
                } catch (error) {
                    console.error('‚ùå Error saving to Supabase:', error);
                    setSyncStatus('error');
                    return null;
                }
            };
            
            // Delete task from Supabase
            const deleteTaskFromSupabase = async (task) => {
                if (!user || !task.supabaseId) return;
                
                try {
                    setSyncStatus('syncing');
                    
                    const { error } = await supabase
                        .from('tasks')
                        .delete()
                        .eq('id', task.supabaseId)
                        .eq('user_id', user.id);
                    
                    if (error) throw error;
                    
                    console.log('‚úÖ Task deleted from Supabase:', task.supabaseId);
                    setSyncStatus('synced');
                    setLastSyncTime(new Date());
                } catch (error) {
                    console.error('‚ùå Error deleting from Supabase:', error);
                    setSyncStatus('error');
                }
            };
            
            // Load all tasks from Supabase
            const loadTasksFromSupabase = async () => {
                if (!user) return;
                
                try {
                    setIsLoadingFromSupabase(true); // CRITICAL: Prevent saves during load!
                    setSyncStatus('syncing');
                    
                    const { data, error } = await supabase
                        .from('tasks')
                        .select('*')
                        .eq('user_id', user.id)
                        .order('created_at', { ascending: true });
                    
                    if (error) throw error;
                    
                    console.log('‚úÖ Loaded tasks from Supabase:', data.length);
                    
                    // If migration hasn't happened yet AND we have local tasks, don't overwrite
                    if (needsMigration) {
                        console.log('‚ö†Ô∏è Migration pending, keeping local tasks');
                        setIsLoadingFromSupabase(false);
                        setSyncStatus('idle');
                        return;
                    }
                    
                    // Convert Supabase format to app format
                    // CRITICAL FIX: Use Supabase ID as local ID for stability!
                    const supabaseTasks = data.map(t => ({
                        id: t.id, // Use Supabase ID as local ID (STABLE!)
                        supabaseId: t.id, // Also keep it here for clarity
                        text: t.text,
                        scheduledDate: t.scheduled_date,
                        dueDate: t.due_date,
                        timeSlot: denormalizeTimeSlot(t.time_slot), // FIX #5: Strip :00 seconds
                        estimatedDuration: t.estimated_duration,
                        status: t.status,
                        priority: t.priority,
                        priority_rating: t.priority_rating !== undefined ? t.priority_rating : 5, // V2.7.0
                        taskType: t.task_type,
                        persona: t.persona,
                        project: t.project,
                        tags: t.tags || [],
                        notes: t.notes,
                        archived: t.archived,
                        isOldTask: t.is_old_task,
                        manualOrder: t.manual_order,
                        subtasks: t.subtasks || [],
                        createdAt: t.created_at
                    }));
                    
                    // CRITICAL: Sort consistently across all devices
                    // Priority: manual_order (if set) > scheduled_date > created_at
                    const sortedTasks = supabaseTasks.sort((a, b) => {
                        // First: Manual order (if both have it)
                        if (a.manualOrder !== null && b.manualOrder !== null) {
                            return a.manualOrder - b.manualOrder;
                        }
                        // If only one has manual order, it goes first
                        if (a.manualOrder !== null) return -1;
                        if (b.manualOrder !== null) return 1;
                        
                        // Second: Scheduled date (null dates go last)
                        if (a.scheduledDate && b.scheduledDate) {
                            const dateCompare = a.scheduledDate.localeCompare(b.scheduledDate);
                            if (dateCompare !== 0) return dateCompare;
                        }
                        if (a.scheduledDate && !b.scheduledDate) return -1;
                        if (!a.scheduledDate && b.scheduledDate) return 1;
                        
                        // Third: Created at
                        return new Date(a.createdAt) - new Date(b.createdAt);
                    });
                    
                    // Use Supabase as single source of truth
                    setTasks(sortedTasks);
                    
                    // SURGICAL FIX #3: If tasks have manualOrder, enable manual order mode
                    const hasManualOrder = sortedTasks.some(t => t.manualOrder !== null && t.manualOrder !== undefined);
                    if (hasManualOrder) {
                        setIsManualOrder(true);
                        console.log('‚úÖ Manual order detected, enabled manual order mode');
                    }
                    
                    // Mark that we've synced successfully
                    localStorage.setItem('ln_has_synced_to_supabase', 'true');
                    setHasSyncedOnce(true);
                    
                    setSyncStatus('synced');
                    setLastSyncTime(new Date());
                    setIsLoadingFromSupabase(false); // Done loading!
                    
                    console.log('‚úÖ Sync complete, Supabase is source of truth');
                    
                } catch (error) {
                    console.error('‚ùå Error loading from Supabase:', error);
                    setSyncStatus('error');
                    setIsLoadingFromSupabase(false);
                }
            };
            
            // Migrate all localStorage tasks to Supabase
            const migrateToSupabase = async () => {
                if (!user) return;
                
                try {
                    setIsLoadingFromSupabase(true); // Prevent duplicate saves during migration
                    setSyncStatus('syncing');
                    console.log('üì§ Starting migration...');
                    
                    const localTasks = JSON.parse(localStorage.getItem('ln_tasks') || '[]');
                    
                    if (localTasks.length === 0) {
                        console.log('‚úÖ No tasks to migrate');
                        setNeedsMigration(false);
                        setSyncStatus('synced');
                        setIsLoadingFromSupabase(false);
                        return;
                    }
                    
                    console.log('üì§ Migrating', localTasks.length, 'tasks...');
                    
                    // Prepare all tasks for batch insert
                    const tasksToInsert = localTasks.map(task => ({
                        user_id: user.id,
                        text: task.text,
                        scheduled_date: task.scheduledDate || null,
                        due_date: task.dueDate || null,
                        time_slot: task.timeSlot || null,
                        estimated_duration: task.estimatedDuration || 30,
                        status: task.status || 'not-started',
                        priority: task.priority || 'medium',
                        task_type: task.taskType || null,
                        persona: task.persona || null,
                        project: task.project || null,
                        tags: task.tags || [],
                        notes: task.notes || null,
                        archived: task.archived || false,
                        is_old_task: task.isOldTask || false,
                        manual_order: task.manualOrder || null,
                        subtasks: task.subtasks || [],
                        created_at: task.createdAt || new Date().toISOString()
                    }));
                    
                    // Batch insert all tasks
                    const { data, error } = await supabase
                        .from('tasks')
                        .insert(tasksToInsert)
                        .select();
                    
                    if (error) throw error;
                    
                    console.log('‚úÖ Migration complete!', data.length, 'tasks uploaded');
                    
                    // Mark migration complete
                    setNeedsMigration(false);
                    localStorage.setItem('ln_has_synced_to_supabase', 'true');
                    setHasSyncedOnce(true);
                    
                    // Now load from Supabase to get proper IDs
                    await loadTasksFromSupabase();
                    
                    alert(`‚úÖ Successfully synced ${data.length} tasks to cloud!`);
                    
                } catch (error) {
                    console.error('‚ùå Migration error:', error);
                    setSyncStatus('error');
                    setIsLoadingFromSupabase(false);
                    alert('‚ùå Migration failed: ' + error.message);
                }
            };
            
            // Load tasks from Supabase when user logs in
            useEffect(() => {
                if (user && !needsMigration && !hasSyncedOnce) {
                    loadTasksFromSupabase();
                }
            }, [user, needsMigration, hasSyncedOnce]);
            
            // ====== PHASE 3: REAL-TIME SYNC ======
            
            // Subscribe to real-time changes for tasks
            useEffect(() => {
                if (!user) return;
                
                console.log('üîî Setting up real-time subscriptions...');
                
                // Subscribe to tasks table changes
                const tasksSubscription = supabase
                    .channel('tasks-changes')
                    .on(
                        'postgres_changes',
                        {
                            event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
                            schema: 'public',
                            table: 'tasks',
                            filter: `user_id=eq.${user.id}`
                        },
                        (payload) => {
                            console.log('üì• Tasks change detected:', payload.eventType);
                            
                            if (payload.eventType === 'INSERT') {
                                console.log('üîç INSERT EVENT RECEIVED');
                                console.log('üîç payload.new.text:', payload.new.text);
                                
                                // V2.6.3-FLAG: Check if user is in rapid task entry mode
                                const timeSinceLastCreation = Date.now() - lastTaskCreationTimeRef.current;
                                const isRapidEntry = isCreatingTasksRef.current && timeSinceLastCreation < 4000;
                                
                                console.log('üîç isCreatingTasksRef:', isCreatingTasksRef.current);
                                console.log('üîç timeSinceLastCreation:', timeSinceLastCreation, 'ms');
                                console.log('üîç isRapidEntry:', isRapidEntry);
                                
                                if (isRapidEntry) {
                                    console.log('‚è≠Ô∏è ‚úÖ SKIPPING INSERT - user is in rapid task entry mode');
                                    return;
                                }
                                
                                // Fallback: Check if input has text (for modifying existing task text)
                                const newTaskInput = document.querySelector('input[placeholder="Add a new task..."]');
                                const inputHasText = newTaskInput && newTaskInput.value && newTaskInput.value.trim().length > 0;
                                
                                console.log('üîç newTaskInput.value:', newTaskInput?.value);
                                console.log('üîç inputHasText:', inputHasText);
                                
                                if (inputHasText) {
                                    console.log('‚è≠Ô∏è ‚úÖ SKIPPING INSERT - input has text');
                                    return;
                                }
                                
                                // Fallback: Check if ANY input is focused
                                const activeElement = document.activeElement;
                                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                                    console.log('‚è≠Ô∏è ‚úÖ SKIPPING INSERT - input is focused');
                                    return;
                                }
                                
                                console.log('üîç ‚ùå NOT SKIPPING - proceeding with INSERT');
                                
                                const newTask = {
                                    id: payload.new.id,
                                    supabaseId: payload.new.id,
                                    text: payload.new.text,
                                    scheduledDate: payload.new.scheduled_date,
                                    dueDate: payload.new.due_date,
                                    timeSlot: denormalizeTimeSlot(payload.new.time_slot), // FIX #5
                                    estimatedDuration: payload.new.estimated_duration,
                                    status: payload.new.status,
                                    priority: payload.new.priority,
                                    priority_rating: payload.new.priority_rating !== undefined ? payload.new.priority_rating : 5, // V2.7.0
                                    taskType: payload.new.task_type,
                                    persona: payload.new.persona,
                                    project: payload.new.project,
                                    tags: payload.new.tags || [],
                                    notes: payload.new.notes,
                                    archived: payload.new.archived,
                                    isOldTask: payload.new.is_old_task,
                                    manualOrder: payload.new.manual_order,
                                    subtasks: payload.new.subtasks || []
                                };
                                
                                // Only add if not already in local state
                                setTasks(prev => {
                                    const exists = prev.some(t => t.id === newTask.id);
                                    if (exists) {
                                        console.log('üîç Task already exists, returning prev');
                                        return prev;
                                    }
                                    console.log('‚ú® Adding new task from real-time:', newTask.text);
                                    console.log('üîç About to call setTasks - this will trigger re-render');
                                    return [...prev, newTask];
                                });
                                
                                console.log('üîç INSERT handler complete');
                            }
                            
                            if (payload.eventType === 'UPDATE') {
                                // V2.5.7-FIX: Skip manualOrder updates during reordering
                                // This prevents the "jumping task" bug where tasks reposition randomly
                                const isManualOrderUpdate = payload.new.manual_order !== payload.old.manual_order;
                                if (isReorderingRef.current && isManualOrderUpdate) {
                                    console.log('‚è∏Ô∏è Skipping manual order update during reorder');
                                    return;
                                }
                                
                                const updatedTask = {
                                    id: payload.new.id,
                                    supabaseId: payload.new.id,
                                    text: payload.new.text,
                                    scheduledDate: payload.new.scheduled_date,
                                    dueDate: payload.new.due_date,
                                    timeSlot: denormalizeTimeSlot(payload.new.time_slot),
                                    estimatedDuration: payload.new.estimated_duration,
                                    status: payload.new.status,
                                    priority: payload.new.priority,
                                    priority_rating: payload.new.priority_rating !== undefined ? payload.new.priority_rating : 5, // V2.7.0
                                    taskType: payload.new.task_type,
                                    persona: payload.new.persona,
                                    project: payload.new.project,
                                    tags: payload.new.tags || [],
                                    notes: payload.new.notes,
                                    archived: payload.new.archived,
                                    isOldTask: payload.new.is_old_task,
                                    subtasks: payload.new.subtasks || []
                                    // V2.5.12-MANUAL-SYNC: manualOrder NOT included
                                    // Order is device-local, synced manually via button
                                };
                                
                                // V2.11.1-FIX: Smarter skip logic - only skip if user is ACTIVELY typing
                                // Check 1: Is user editing this specific task?
                                if (editingTask === updatedTask.id) {
                                    console.log('‚è≠Ô∏è Skipping real-time update - task is being edited:', updatedTask.text);
                                    return;
                                }
                                
                                // Check 2: Is user ACTIVELY typing (rapid entry mode)?
                                // V2.11.1: Changed from checking activeElement to checking rapid entry state
                                if (isCreatingTasksRef.current) {
                                    const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                    if (timeSince < 2000) { // Only skip if typed within last 2 seconds
                                        console.log('‚è≠Ô∏è Skipping real-time update - user is actively typing (rapid entry mode)');
                                        return;
                                    }
                                }
                                
                                // V2.11.1: Allow updates when user is just clicking around UI
                                // Even if input happens to have focus, allow updates unless actively typing
                                
                                // SURGICAL FIX #2: Merge updates instead of replacing
                                // This preserves any local changes that haven't synced yet
                                setTasks(prev => {
                                    const index = prev.findIndex(t => t.id === updatedTask.id);
                                    if (index === -1) return prev;
                                    console.log('üîÑ Updating task from real-time:', updatedTask.text);
                                    const newTasks = [...prev];
                                    // Merge instead of replace (preserves local manualOrder!)
                                    newTasks[index] = { ...newTasks[index], ...updatedTask };
                                    
                                    return newTasks;
                                });
                            }
                            
                            if (payload.eventType === 'DELETE') {
                                const deletedId = payload.old.id;
                                setTasks(prev => {
                                    console.log('üóëÔ∏è Deleting task from real-time:', deletedId);
                                    return prev.filter(t => t.id !== deletedId);
                                });
                            }
                        }
                    )
                    .subscribe((status) => {
                        const timestamp = new Date().toISOString();
                        console.log(`üì° [${timestamp}] Tasks subscription status:`, status);
                        
                        // V2.7.4 FIX: Update sync status on connection changes
                        if (status === 'SUBSCRIBED') {
                            console.log('‚úÖ Real-time sync CONNECTED');
                            if (syncStatus === 'error') {
                                console.log('üîÑ Clearing error state, connection restored');
                                setSyncStatus('synced');
                            }
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('‚ùå Real-time sync ERROR - connection lost!');
                            setSyncStatus('error');
                        } else if (status === 'TIMED_OUT') {
                            console.warn('‚è±Ô∏è Real-time sync TIMEOUT - reconnecting...');
                            setSyncStatus('error');
                        } else if (status === 'CLOSED') {
                            console.warn('üîå Real-time sync CLOSED - connection ended');
                        }
                    });
                
                // Subscribe to events table changes
                const eventsSubscription = supabase
                    .channel('events-changes')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',
                            schema: 'public',
                            table: 'events',
                            filter: `user_id=eq.${user.id}`
                        },
                        (payload) => {
                            console.log('üì• Events change detected:', payload.eventType);
                            
                            if (payload.eventType === 'INSERT') {
                                const newEvent = {
                                    id: payload.new.id,
                                    supabaseId: payload.new.id,
                                    type: 'event',
                                    text: payload.new.text,
                                    scheduledDate: payload.new.start_date,
                                    endDate: payload.new.end_date,
                                    startTime: payload.new.start_time,
                                    endTime: payload.new.end_time,
                                    allDay: payload.new.all_day,
                                    color: payload.new.color,
                                    notes: payload.new.notes,
                                    tags: payload.new.tags || [],
                                    persona: payload.new.persona,
                                    project: payload.new.project,
                                    priority: payload.new.priority,
                                    tasks: [],
                                    status: 'upcoming'
                                };
                                
                                setEvents(prev => {
                                    const exists = prev.some(e => e.id === newEvent.id);
                                    if (exists) return prev;
                                    console.log('‚ú® Adding new event from real-time:', newEvent.text);
                                    return [...prev, newEvent];
                                });
                            }
                            
                            if (payload.eventType === 'UPDATE') {
                                const updatedEvent = {
                                    id: payload.new.id,
                                    supabaseId: payload.new.id,
                                    type: 'event',
                                    text: payload.new.text,
                                    scheduledDate: payload.new.start_date,
                                    endDate: payload.new.end_date,
                                    startTime: payload.new.start_time,
                                    endTime: payload.new.end_time,
                                    allDay: payload.new.all_day,
                                    color: payload.new.color,
                                    notes: payload.new.notes,
                                    tags: payload.new.tags || [],
                                    persona: payload.new.persona,
                                    project: payload.new.project,
                                    priority: payload.new.priority,
                                    tasks: [],
                                    status: 'upcoming'
                                };
                                
                                setEvents(prev => {
                                    const index = prev.findIndex(e => e.id === updatedEvent.id);
                                    if (index === -1) return prev;
                                    console.log('üîÑ Updating event from real-time:', updatedEvent.text);
                                    const newEvents = [...prev];
                                    newEvents[index] = updatedEvent;
                                    return newEvents;
                                });
                            }
                            
                            if (payload.eventType === 'DELETE') {
                                const deletedId = payload.old.id;
                                setEvents(prev => {
                                    console.log('üóëÔ∏è Deleting event from real-time:', deletedId);
                                    return prev.filter(e => e.id !== deletedId);
                                });
                            }
                        }
                    )
                    .subscribe((status) => {
                        const timestamp = new Date().toISOString();
                        console.log(`üì° [${timestamp}] Events subscription status:`, status);
                        
                        // V2.7.0: Detailed diagnostics
                        if (status === 'SUBSCRIBED') {
                            console.log('‚úÖ Events sync CONNECTED');
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('‚ùå Events sync ERROR - connection lost!');
                        } else if (status === 'TIMED_OUT') {
                            console.warn('‚è±Ô∏è Events sync TIMEOUT - reconnecting...');
                        } else if (status === 'CLOSED') {
                            console.warn('üîå Events sync CLOSED - connection ended');
                        }
                    });
                
                // V2.7.0: Connection health monitoring
                const healthCheck = setInterval(() => {
                    const now = new Date().toISOString();
                    console.log(`üíì [${now}] Connection heartbeat - monitoring active`);
                    
                    // Check if subscriptions are still active
                    if (tasksSubscription.state !== 'joined') {
                        console.warn(`‚ö†Ô∏è Tasks subscription state: ${tasksSubscription.state}`);
                    }
                    if (eventsSubscription.state !== 'joined') {
                        console.warn(`‚ö†Ô∏è Events subscription state: ${eventsSubscription.state}`);
                    }
                }, 60000); // Check every 60 seconds
                
                // Cleanup subscriptions on unmount
                return () => {
                    console.log('üîå Unsubscribing from real-time channels');
                    clearInterval(healthCheck);
                    tasksSubscription.unsubscribe();
                    eventsSubscription.unsubscribe();
                };
            }, [user]);
            
            // ====== V2.5.0-SYNC: EVENTS SYNC FUNCTIONS ======
            
            // Save a single event to Supabase
            const saveEventToSupabase = async (event) => {
                if (!user) return;
                if (isLoadingFromSupabase) return; // Don't save while loading!
                
                try {
                    setSyncStatus('syncing');
                    
                    // Prepare event for Supabase
                    const eventData = {
                        user_id: user.id,
                        text: event.text,
                        start_date: event.scheduledDate || null,
                        end_date: event.endDate || null,
                        start_time: event.startTime || null,
                        end_time: event.endTime || null,
                        all_day: event.allDay || false,
                        color: event.color || '#10b981',
                        notes: event.notes || null,
                        tags: event.tags || [],
                        persona: event.persona || null,
                        project: event.project || null,
                        priority: event.priority || 'medium'
                    };
                    
                    // Check if event already exists in Supabase
                    if (event.supabaseId) {
                        // Update existing event
                        const { data, error } = await supabase
                            .from('events')
                            .update(eventData)
                            .eq('id', event.supabaseId)
                            .eq('user_id', user.id)
                            .select()
                            .single();
                        
                        if (error) throw error;
                        
                        console.log('‚úÖ Event updated in Supabase:', data.id);
                        setSyncStatus('synced');
                        setLastSyncTime(new Date());
                        return data;
                    } else {
                        // Insert new event
                        const { data, error } = await supabase
                            .from('events')
                            .insert([eventData])
                            .select()
                            .single();
                        
                        if (error) throw error;
                        
                        console.log('‚úÖ Event saved to Supabase:', data.id);
                        
                        // Don't update here - let caller handle ID update
                        
                        setSyncStatus('synced');
                        setLastSyncTime(new Date());
                        return data;
                    }
                } catch (error) {
                    console.error('‚ùå Error saving event to Supabase:', error);
                    setSyncStatus('error');
                    return null;
                }
            };
            
            // Delete event from Supabase
            const deleteEventFromSupabase = async (event) => {
                if (!user || !event.supabaseId) return;
                
                try {
                    setSyncStatus('syncing');
                    
                    const { error } = await supabase
                        .from('events')
                        .delete()
                        .eq('id', event.supabaseId)
                        .eq('user_id', user.id);
                    
                    if (error) throw error;
                    
                    console.log('‚úÖ Event deleted from Supabase:', event.supabaseId);
                    setSyncStatus('synced');
                    setLastSyncTime(new Date());
                } catch (error) {
                    console.error('‚ùå Error deleting event from Supabase:', error);
                    setSyncStatus('error');
                }
            };
            
            // Load all events from Supabase
            const loadEventsFromSupabase = async () => {
                if (!user) return;
                
                try {
                    setIsLoadingFromSupabase(true);
                    
                    const { data, error } = await supabase
                        .from('events')
                        .select('*')
                        .eq('user_id', user.id)
                        .order('start_date', { ascending: true });
                    
                    if (error) throw error;
                    
                    console.log('‚úÖ Loaded events from Supabase:', data.length);
                    
                    // Convert Supabase format to app format
                    const supabaseEvents = data.map(e => ({
                        id: e.id, // Use Supabase ID as local ID (STABLE!)
                        supabaseId: e.id,
                        type: 'event',
                        text: e.text,
                        scheduledDate: e.start_date,
                        endDate: e.end_date,
                        startTime: e.start_time,
                        endTime: e.end_time,
                        allDay: e.all_day,
                        color: e.color || '#10b981',
                        notes: e.notes,
                        tags: e.tags || [],
                        persona: e.persona,
                        project: e.project,
                        priority: e.priority || 'medium',
                        tasks: [], // Events can have tasks, but we'll sync those later
                        status: 'upcoming', // Default status
                        createdAt: e.created_at
                    }));
                    
                    // Use Supabase as single source of truth
                    setEvents(supabaseEvents);
                    setIsLoadingFromSupabase(false);
                    
                    // Mark that we've synced events successfully
                    localStorage.setItem('ln_has_synced_events_to_supabase', 'true');
                    setHasEventsSynced(true);
                    
                    console.log('‚úÖ Events sync complete');
                    
                } catch (error) {
                    console.error('‚ùå Error loading events from Supabase:', error);
                    setIsLoadingFromSupabase(false);
                }
            };
            
            // Migrate localStorage events to Supabase
            const migrateEventsToSupabase = async () => {
                if (!user) return;
                
                try {
                    const localEvents = JSON.parse(localStorage.getItem('ln_events') || '[]');
                    
                    if (localEvents.length === 0) {
                        console.log('‚úÖ No events to migrate');
                        return;
                    }
                    
                    console.log('üì§ Migrating', localEvents.length, 'events...');
                    
                    const eventsToInsert = localEvents.map(event => ({
                        user_id: user.id,
                        text: event.text,
                        start_date: event.scheduledDate || null,
                        end_date: event.endDate || null,
                        start_time: event.startTime || null,
                        end_time: event.endTime || null,
                        all_day: event.allDay || false,
                        color: event.color || '#10b981',
                        notes: event.notes || null,
                        tags: event.tags || [],
                        persona: event.persona || null,
                        project: event.project || null,
                        priority: event.priority || 'medium',
                        created_at: event.createdAt || new Date().toISOString()
                    }));
                    
                    const { data, error } = await supabase
                        .from('events')
                        .insert(eventsToInsert)
                        .select();
                    
                    if (error) throw error;
                    
                    console.log('‚úÖ Events migration complete!', data.length, 'events uploaded');
                    
                    // Mark migration complete
                    localStorage.setItem('ln_has_synced_events_to_supabase', 'true');
                    setHasEventsSynced(true);
                    
                    // Reload events from Supabase
                    await loadEventsFromSupabase();
                    
                } catch (error) {
                    console.error('‚ùå Events migration error:', error);
                }
            };
            
            // Load events from Supabase when user logs in
            useEffect(() => {
                const initializeEvents = async () => {
                    if (!user || isLoadingFromSupabase) return;
                    
                    // Check if already synced (flag in localStorage)
                    const hasAlreadySynced = localStorage.getItem('ln_has_synced_events_to_supabase') === 'true';
                    
                    if (hasAlreadySynced) {
                        // Already synced, just load from Supabase
                        setHasEventsSynced(true);
                        await loadEventsFromSupabase();
                        return;
                    }
                    
                    // First time - check if we need to migrate localStorage events
                    const localEvents = JSON.parse(localStorage.getItem('ln_events') || '[]');
                    
                    if (localEvents.length > 0) {
                        // Migrate localStorage events
                        console.log('üì§ Found', localEvents.length, 'local events to migrate');
                        await migrateEventsToSupabase();
                    } else {
                        // No local events, just load from Supabase
                        await loadEventsFromSupabase();
                    }
                };
                
                if (user && !hasEventsSynced) {
                    initializeEvents();
                }
            }, [user, hasEventsSynced]);
            
            // Generate time slots (used in multiple views)
            const timeSlots = [];
            for (let h = 0; h < 24; h++) {
                timeSlots.push(`${String(h).padStart(2, '0')}:00`);
                timeSlots.push(`${String(h).padStart(2, '0')}:15`); // 15-min support
                timeSlots.push(`${String(h).padStart(2, '0')}:30`);
                timeSlots.push(`${String(h).padStart(2, '0')}:45`); // 15-min support
            }
            
            // V2.6.2-POLISH: Helper to convert 24hr time to AM/PM format
            const formatTimeAMPM = (time24) => {
                if (!time24) return '';
                const [hourStr, minute] = time24.split(':');
                const hour = parseInt(hourStr);
                const period = hour >= 12 ? 'PM' : 'AM';
                const hour12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
                return `${hour12}:${minute} ${period}`;
            };
            
            // V2.6.2-POLISH: Create AM/PM display versions of time slots
            const timeSlotsDisplay = timeSlots.map(slot => ({
                value: slot,
                label: formatTimeAMPM(slot)
            }));
            
            // ====== V2.7.1-LISTSYNC: CUSTOM LISTS SYNC FUNCTIONS ======
            
            // Save a single list to Supabase
            const saveListToSupabase = async (list) => {
                if (!user) return;
                if (isLoadingFromSupabase) return; // Don't save while loading!
                
                // V2.7.1 CRITICAL: Mark this list as actively being saved
                activelySavingListRef.current.add(list.id);
                console.log('üîí Locking list from real-time updates:', list.id);
                
                try {
                    // V2.7.1 FIX: Suppress sync status during rapid entry (prevents re-renders)
                    if (!isCreatingListsRef.current) {
                        setSyncStatus('syncing');
                    }
                    
                    console.log('üíæ Saving list to Supabase:', list.name);
                    
                    // V2.7.1: Track which device created/edited the list
                    const deviceId = getDeviceId();
                    const isNewList = !list.supabaseId; // New list if no Supabase ID yet
                    
                    const listData = {
                        id: list.id,
                        user_id: user.id,
                        name: list.name,
                        tasks: list.tasks || [],
                        created_device: isNewList ? deviceId : list.created_device, // Only set on creation
                        last_edited_device: deviceId // Always update on save
                    };
                    
                    const { data, error } = await supabase
                        .from('custom_lists')
                        .upsert(listData, {
                            onConflict: 'id'
                        })
                        .select()
                        .single();
                    
                    if (error) {
                        console.error('‚ùå Error saving list:', error);
                        if (!isCreatingListsRef.current) {
                            setSyncStatus('error');
                        }
                        return null;
                    }
                    
                    console.log('‚úÖ List saved:', data);
                    // V2.7.1 FIX: Suppress sync status during rapid entry
                    if (!isCreatingListsRef.current) {
                        setSyncStatus('synced');
                    }
                    
                    // V2.7.1 CRITICAL: Wait a bit for real-time to settle, then unlock
                    setTimeout(() => {
                        activelySavingListRef.current.delete(list.id);
                        console.log('üîì Unlocking list for real-time updates:', list.id);
                    }, 1000); // Wait 1 second for real-time to settle
                    
                    return data;
                } catch (error) {
                    console.error('‚ùå Unexpected error saving list:', error);
                    if (!isCreatingListsRef.current) {
                        setSyncStatus('error');
                    }
                    
                    // Unlock on error too
                    activelySavingListRef.current.delete(list.id);
                    
                    return null;
                }
            };
            
            // Delete a list from Supabase
            const deleteListFromSupabase = async (list) => {
                if (!user || !list) return;
                if (isLoadingFromSupabase) return;
                
                try {
                    console.log('üóëÔ∏è Deleting list from Supabase:', list.name);
                    
                    const { error } = await supabase
                        .from('custom_lists')
                        .delete()
                        .eq('id', list.id)
                        .eq('user_id', user.id);
                    
                    if (error) {
                        console.error('‚ùå Error deleting list:', error);
                        return;
                    }
                    
                    console.log('‚úÖ List deleted from Supabase');
                } catch (error) {
                    console.error('‚ùå Unexpected error deleting list:', error);
                }
            };
            
            // Load all lists from Supabase
            const loadListsFromSupabase = async () => {
                if (!user) return;
                
                try {
                    console.log('üì• Loading lists from Supabase...');
                    
                    const { data, error } = await supabase
                        .from('custom_lists')
                        .select('*')
                        .eq('user_id', user.id)
                        .order('created_at', { ascending: true });
                    
                    if (error) {
                        console.error('‚ùå Error loading lists:', error);
                        return;
                    }
                    
                    console.log('‚úÖ Loaded', data.length, 'lists from Supabase');
                    
                    // Convert Supabase format to app format
                    const supabaseLists = data.map(l => ({
                        id: l.id,
                        supabaseId: l.id, // Track Supabase ID
                        name: l.name,
                        tasks: l.tasks || [],
                        createdAt: l.created_at,
                        created_device: l.created_device, // V2.7.1: Device tracking
                        last_edited_device: l.last_edited_device // V2.7.1: Device tracking
                    }));
                    
                    // V2.7.1 FIX: Use Supabase as single source of truth
                    // Always replace local state with Supabase data
                    setCustomLists(supabaseLists);
                    console.log('‚úÖ Lists loaded, Supabase is source of truth');
                    
                } catch (error) {
                    console.error('‚ùå Unexpected error loading lists:', error);
                }
            };
            
            // V2.7.1: Load lists from Supabase on mount
            // FIX: Always load from Supabase when user logs in (Supabase is single source of truth)
            useEffect(() => {
                if (user) {
                    console.log('üîÑ Loading lists from Supabase (user logged in)');
                    loadListsFromSupabase();
                }
            }, [user]);
            
            // V2.7.1: Subscribe to custom_lists real-time changes
            useEffect(() => {
                if (!user) return;
                
                console.log('üì° V2.7.1: Setting up custom_lists real-time subscription');
                
                const listsSubscription = supabase
                    .channel('custom-lists-changes')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',
                            schema: 'public',
                            table: 'custom_lists',
                            filter: `user_id=eq.${user.id}`
                        },
                        (payload) => {
                            console.log('üì° Custom lists change detected:', payload);
                            
                            if (payload.eventType === 'INSERT') {
                                const newList = {
                                    id: payload.new.id,
                                    supabaseId: payload.new.id,
                                    name: payload.new.name,
                                    tasks: payload.new.tasks || [],
                                    createdAt: payload.new.created_at,
                                    created_device: payload.new.created_device, // V2.7.1
                                    last_edited_device: payload.new.last_edited_device // V2.7.1
                                };
                                
                                // Check if list already exists locally
                                setCustomLists(prev => {
                                    const exists = prev.some(l => l.id === newList.id);
                                    if (exists) {
                                        console.log('‚è≠Ô∏è List already exists locally, skipping INSERT');
                                        return prev;
                                    }
                                    console.log('‚ûï Adding new list from real-time:', newList.name);
                                    return [...prev, newList];
                                });
                            }
                            
                            if (payload.eventType === 'UPDATE') {
                                const updatedList = {
                                    id: payload.new.id,
                                    supabaseId: payload.new.id,
                                    name: payload.new.name,
                                    tasks: payload.new.tasks || [],
                                    createdAt: payload.new.created_at,
                                    created_device: payload.new.created_device, // V2.7.1
                                    last_edited_device: payload.new.last_edited_device // V2.7.1
                                };
                                
                                // V2.7.1 CRITICAL FIX: Don't overwrite if we're actively saving this list!
                                if (activelySavingListRef.current.has(updatedList.id)) {
                                    console.log('‚è≠Ô∏è List is being saved, ignoring real-time UPDATE to prevent overwrite');
                                    return;
                                }
                                
                                setCustomLists(prev => {
                                    const index = prev.findIndex(l => l.id === updatedList.id);
                                    if (index === -1) {
                                        console.log('‚è≠Ô∏è List not found locally, skipping UPDATE');
                                        return prev;
                                    }
                                    
                                    console.log('üìù Updating list from real-time:', updatedList.name);
                                    const newLists = [...prev];
                                    newLists[index] = updatedList;
                                    return newLists;
                                });
                            }
                            
                            if (payload.eventType === 'DELETE') {
                                const deletedId = payload.old.id;
                                setCustomLists(prev => {
                                    console.log('üóëÔ∏è Deleting list from real-time:', deletedId);
                                    return prev.filter(l => l.id !== deletedId);
                                });
                            }
                        }
                    )
                    .subscribe((status) => {
                        const timestamp = new Date().toISOString();
                        console.log(`üì° [${timestamp}] Lists subscription status:`, status);
                        
                        if (status === 'SUBSCRIBED') {
                            console.log('‚úÖ Lists sync CONNECTED');
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('‚ùå Lists sync ERROR - connection lost!');
                        } else if (status === 'TIMED_OUT') {
                            console.warn('‚è±Ô∏è Lists sync TIMEOUT - reconnecting...');
                        } else if (status === 'CLOSED') {
                            console.warn('üîå Lists sync CLOSED - connection ended');
                        }
                    });
                
                // Cleanup on unmount
                return () => {
                    console.log('üîå Unsubscribing from lists channel');
                    listsSubscription.unsubscribe();
                };
            }, [user]);
            
            // ====== STATE MANAGEMENT ======
            const [currentView, setCurrentView] = useState('list');
            const [selectedDate, setSelectedDate] = useState(formatDate(new Date()));
            const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
            const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
            const newTaskTextRef = useRef(''); // V2.6.3-REF: Use ref to persist across remounts without triggering re-renders
            const isCreatingTasksRef = useRef(false); // V2.6.3-FLAG: Track rapid task entry mode
            const lastTaskCreationTimeRef = useRef(0); // V2.6.3-FLAG: Track last task creation time
            
            // V2.7.1: List rapid entry refs (same pattern as tasks)
            const newListTextRef = useRef('');
            const isCreatingListsRef = useRef(false);
            const lastListCreationTimeRef = useRef(0);
            const activelySavingListRef = useRef(new Set()); // Track lists being saved to prevent overwrite
            
            // Task and organizational data
            const [tasks, setTasks] = useStickyState([], 'ln_tasks');
            const [personas, setPersonas] = useStickyState(['The Self', 'Healthcare Professional', 'Entrepreneur'], 'ln_personas');
            const [projects, setProjects] = useStickyState([
                {
                    id: 'no-project', // Special ID for "No Project" pseudo-project
                    name: '__NO_PROJECT__', // Special name (won't match any task.project)
                    status: 0, // Not used for "No Project"
                    color: '#9ca3af', // Gray color
                    statuses: ['not-started', 'in-progress', 'completed'], // Default statuses
                    isNoProject: true // Flag to identify this special project
                },
                {
                    id: Date.now(), 
                    name: 'X-Ponential AI', 
                    status: 80, 
                    color: '#6366f1',
                    statuses: ['not-started', 'in-progress', 'completed'] // Default
                },
                {
                    id: Date.now() + 1, 
                    name: 'Anyo Lyfis', 
                    status: 60, 
                    color: '#8b5cf6',
                    statuses: ['to-do', 'in-progress', 'awaiting-discussion', 'delayed-parked', 'done']
                }
            ], 'ln_projects');
            
            // MIGRATION: Ensure "No Project" pseudo-project exists
            React.useEffect(() => {
                const hasNoProjectPseudo = projects.some(p => p.isNoProject);
                if (!hasNoProjectPseudo) {
                    console.log('üîß MIGRATION: Adding "No Project" pseudo-project');
                    setProjects(prev => [
                        {
                            id: 'no-project',
                            name: '__NO_PROJECT__',
                            status: 0,
                            color: '#9ca3af',
                            statuses: ['not-started', 'in-progress', 'completed'],
                            isNoProject: true
                        },
                        ...prev
                    ]);
                }
            }, []); // Run once on mount
            
            const [customLists, setCustomLists] = useStickyState([], 'ln_customLists');

            // UI state
            const [searchQuery, setSearchQuery] = useState('');
            const [filterStatus, setFilterStatus] = useState('all');
            const [filterPersona, setFilterPersona] = useState('all');
            const [filterProject, setFilterProject] = useState('all');
            const [sortBy, setSortBy] = useState('createdAt');
            const [showFilters, setShowFilters] = useState(false);
            const [expandedTasks, setExpandedTasks] = useState({});
            const [editingTask, setEditingTask] = useState(null);
            const [editingSubtask, setEditingSubtask] = useState(null);
            const [showArchived, setShowArchived] = useState(false);
            const [showListsModal, setShowListsModal] = useState(false);
            const [quickEditTask, setQuickEditTask] = useState(null);
            const [showQuickEdit, setShowQuickEdit] = useState(false);
            
            // V1.3: Manual task reordering
            // FIX #7: Persist manual order mode to localStorage
            const [isManualOrder, setIsManualOrder] = useState(() => {
                try {
                    const saved = localStorage.getItem('isManualOrder');
                    return saved === 'true';
                } catch {
                    return false;
                }
            });
            
            // Save isManualOrder to localStorage whenever it changes
            useEffect(() => {
                try {
                    localStorage.setItem('isManualOrder', isManualOrder.toString());
                } catch (error) {
                    console.error('Failed to save isManualOrder:', error);
                }
            }, [isManualOrder]);
            
            // V2.5.7-FIX: Prevent real-time updates from disrupting manual reorder
            const isReorderingRef = useRef(false);
            const reorderTimeoutRef = useRef(null);
            const [isSyncingFromRealtime, setIsSyncingFromRealtime] = useState(false);
            
            // V1.3: Events system
            const [events, setEvents] = useStickyState([], 'ln_events');
            const [showEventModal, setShowEventModal] = useState(false);
            const [editingEvent, setEditingEvent] = useState(null);
            
            // V1.3: Multi-day timeline
            const [timelineViewMode, setTimelineViewMode] = useState('day'); // 'day' or 'week'
            
            // V1.3: Enhanced Gantt
            const [ganttViewMode, setGanttViewMode] = useState('day'); // 'day' or 'week'
            
            // V1.3.1: Task mover modal (fallback for drag-drop)
            const [showTaskMover, setShowTaskMover] = useState(false);
            const [taskToMove, setTaskToMove] = useState(null);
            
            // V1.4: Mouse-based drag system (HTML5 drag doesn't work in React)
            const [isDragging, setIsDragging] = useState(false);
            const [draggedTask, setDraggedTask] = useState(null);
            const [dragStartPos, setDragStartPos] = useState(null);
            const [currentDropZone, setCurrentDropZone] = useState(null);
            
            // V1.4.1: Use ref for immediate tracking (state updates are async)
            const isDraggingRef = useRef(false);
            const draggedTaskRef = useRef(null);
            const currentDropZoneRef = useRef(null);
            
            // Toast notifications
            const [toast, setToast] = useState(null);
            const [undoData, setUndoData] = useState(null);

            // Drag and drop state (keeping for compatibility)
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragOverZone, setDragOverZone] = useState(null);
            const [touchStartTime, setTouchStartTime] = useState(null);
            const [longPressTimer, setLongPressTimer] = useState(null);

            // Modal state
            const [showTaskModal, setShowTaskModal] = useState(false);
            const [modalTask, setModalTask] = useState(null);

            // Bulk import
            const [bulkImportText, setBulkImportText] = useState('');
            const [importedItems, setImportedItems] = useState([]);
            const [currentClassifyIndex, setCurrentClassifyIndex] = useState(0);

            // ====== COMPUTED VALUES ======
            const dailyScore = useMemo(() => {
                let total = 0;
                tasks.forEach(task => {
                    // V2.11.4: Skip archived tasks
                    if (task.archived) return;
                    
                    if (isSameDay(task.scheduledDate || task.createdAt, selectedDate)) {
                        total += calculateTaskScore(task);
                        if (task.subtasks) {
                            task.subtasks.forEach(st => total += calculateTaskScore(st));
                        }
                    }
                });
                return total;
            }, [tasks, selectedDate]);

            const weeklyScore = useMemo(() => {
                const weekStart = new Date(selectedDate);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                let total = 0;
                for (let i = 0; i < 7; i++) {
                    const day = addDays(weekStart, i);
                    tasks.forEach(task => {
                        // V2.11.4: Skip archived tasks
                        if (task.archived) return;
                        
                        if (isSameDay(task.scheduledDate || task.createdAt, day)) {
                            total += calculateTaskScore(task);
                            if (task.subtasks) {
                                task.subtasks.forEach(st => total += calculateTaskScore(st));
                            }
                        }
                    });
                }
                return total;
            }, [tasks, selectedDate]);

            const monthlyScore = useMemo(() => {
                let total = 0;
                tasks.forEach(task => {
                    // V2.11.4: Skip archived tasks
                    if (task.archived) return;
                    
                    const taskDate = new Date(task.scheduledDate || task.createdAt);
                    if (taskDate.getMonth() === currentMonth && taskDate.getFullYear() === currentYear) {
                        total += calculateTaskScore(task);
                        if (task.subtasks) {
                            task.subtasks.forEach(st => total += calculateTaskScore(st));
                        }
                    }
                });
                return total;
            }, [tasks, currentMonth, currentYear]);

            // Filtered and sorted tasks
            const filteredTasks = useMemo(() => {
                let filtered = tasks.filter(task => {
                    // V2.11.6: Hide completion zone tasks from main views
                    if (task.inCompletionZone) return false;
                    
                    if (!showArchived && task.archived) return false;
                    if (showArchived && !task.archived) return false;
                    if (filterStatus !== 'all' && task.status !== filterStatus) return false;
                    if (filterPersona !== 'all' && task.persona !== filterPersona) return false;
                    if (filterProject !== 'all' && task.project !== filterProject) return false;
                    // Fix #1: Search in text, tags, AND notes
                    if (searchQuery) {
                        const searchLower = searchQuery.toLowerCase();
                        const matchesText = task.text.toLowerCase().includes(searchLower);
                        const matchesTags = (task.tags || []).some(tag => tag.toLowerCase().includes(searchLower));
                        const matchesNotes = (task.notes || '').toLowerCase().includes(searchLower);
                        
                        if (!matchesText && !matchesTags && !matchesNotes) {
                            return false;
                        }
                    }
                    return true;
                });

                // FIX Issues 1-3: Sort tasks with proper manual order handling
                // Auto-detect manual order mode based on task data
                const hasManualOrderTasks = filtered.some(t => t.manualOrder !== null && t.manualOrder !== undefined);
                
                if (hasManualOrderTasks || isManualOrder) {
                    // Manual order mode: use manualOrder if set, fallback to createdAt
                    filtered.sort((a, b) => {
                        const hasOrderA = a.manualOrder !== undefined && a.manualOrder !== null;
                        const hasOrderB = b.manualOrder !== undefined && b.manualOrder !== null;
                        
                        // Both have manualOrder: compare them
                        if (hasOrderA && hasOrderB) {
                            return a.manualOrder - b.manualOrder;
                        }
                        
                        // Only A has order: A comes first
                        if (hasOrderA) return -1;
                        if (hasOrderB) return 1;
                        
                        // Neither has order: sort by createdAt (newest first)
                        return new Date(b.createdAt) - new Date(a.createdAt);
                    });
                } else {
                    // Use selected sort option
                    filtered.sort((a, b) => {
                        if (sortBy === 'createdAt') return new Date(b.createdAt) - new Date(a.createdAt);
                        if (sortBy === 'dueDate') {
                            if (!a.dueDate) return 1;
                            if (!b.dueDate) return -1;
                            return new Date(a.dueDate) - new Date(b.dueDate);
                        }
                        if (sortBy === 'priority') {
                            const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 };
                            return priorityOrder[a.priority || 'medium'] - priorityOrder[b.priority || 'medium'];
                        }
                        if (sortBy === 'points') {
                            return calculateTaskScore(b) - calculateTaskScore(a);
                        }
                        return 0;
                    });
                }

                return filtered;
            }, [tasks, filterStatus, filterPersona, filterProject, searchQuery, sortBy, showArchived, isManualOrder]);

            // ====== TASK MANAGEMENT FUNCTIONS ======
            const createTask = async (taskData) => {
                // V2.6.3: Extract rapid mode flag BEFORE creating task
                const wasInRapidMode = taskData._wasInRapidMode || false;
                
                // Create temporary task with temp ID
                const tempId = 'temp_' + Date.now();
                const newTask = {
                    id: tempId,
                    text: '',
                    status: 'not-started',
                    taskType: 'consistency',
                    priority: 'medium',
                    priority_rating: 5, // V2.7.0: Default rating is 5 (medium)
                    persona: personas[0],
                    project: null,
                    scheduledDate: selectedDate,
                    dueDate: null,
                    dueLabel: null,
                    timeSlot: null,
                    estimatedDuration: null,
                    actualDuration: null,
                    tags: [],
                    notes: '',
                    isOldTask: false,
                    archived: false,
                    inCompletionZone: false, // V2.11.6: Completion zone for completed tasks
                    recurringPattern: null,
                    subtasks: [],
                    manualOrder: null,
                    createdAt: new Date().toISOString(),
                    startedAt: null,
                    completedAt: null,
                    ...taskData,
                    _wasInRapidMode: undefined  // Remove internal flag from task object
                };
                
                // Add to local state immediately (optimistic UI)
                setTasks(prev => [...prev, newTask]);
                
                // V2.6.3-TOAST: Show toast for first task or after pause
                // Only suppress for rapid subsequent tasks
                if (!wasInRapidMode) {
                    showToast('Task created successfully');
                } else {
                    console.log('üîá Toast suppressed - rapid entry in progress');
                }
                
                // V2.5.0-SYNC: Save to Supabase and get real ID
                if (user && !isLoadingFromSupabase) {
                    try {
                        const savedTask = await saveTaskToSupabase(newTask);
                        if (savedTask && savedTask.id) {
                            // Replace temp task with task using Supabase ID
                            setTasks(prev => prev.map(t => 
                                t.id === tempId 
                                    ? { ...t, id: savedTask.id, supabaseId: savedTask.id }
                                    : t
                            ));
                        }
                    } catch (error) {
                        console.error('‚ùå Error saving new task:', error);
                    }
                }
                
                return newTask;
            };

            const updateTask = (taskId, updates) => {
                setTasks(prev => {
                    const updated = prev.map(task => 
                        task.id === taskId ? { ...task, ...updates } : task
                    );
                    
                    // V2.5.11-FIX: Save to Supabase WITHOUT manualOrder
                    // This prevents property edits from overwriting drag order
                    const updatedTask = updated.find(t => t.id === taskId);
                    
                    // V2.6.1-FIX: Only save if task has supabaseId
                    // This prevents duplicates when editing newly created tasks
                    if (updatedTask && user && updatedTask.supabaseId) {
                        saveTaskToSupabase(updatedTask, { excludeManualOrder: true });
                    } else if (updatedTask && !updatedTask.supabaseId) {
                        console.log('‚è≠Ô∏è Skipping save: Task not yet saved to Supabase', taskId);
                    }
                    
                    return updated;
                });
            };
            
            // V2.6.0-BUTTONS: Move task up in manual order
            const moveTaskUp = (taskId) => {
                const visibleTasks = [...filteredTasks];
                const currentIndex = visibleTasks.findIndex(t => t.id === taskId);
                
                if (currentIndex <= 0) return; // Already at top
                
                console.log('‚¨ÜÔ∏è Moving task up:', visibleTasks[currentIndex].text);
                
                // Swap with task above
                [visibleTasks[currentIndex - 1], visibleTasks[currentIndex]] = 
                [visibleTasks[currentIndex], visibleTasks[currentIndex - 1]];
                
                // Reassign manual order
                const updatedTasks = tasks.map(task => {
                    const visibleIndex = visibleTasks.findIndex(t => t.id === task.id);
                    if (visibleIndex !== -1) {
                        return { ...task, manualOrder: visibleIndex };
                    }
                    return task;
                });
                
                setTasks(updatedTasks);
                setIsManualOrder(true);
                
                // V2.6.3-FIX: Batch save with single Supabase call to reduce real-time events
                const tasksToSave = updatedTasks.filter(t => t.manualOrder !== null && t.supabaseId);
                if (tasksToSave.length > 0 && user) {
                    // Use a single batch update instead of individual saves
                    const batchUpdate = async () => {
                        try {
                            const updates = tasksToSave.map(task => ({
                                id: task.supabaseId,
                                user_id: user.id,
                                manual_order: task.manualOrder,
                                last_ordered_device: getDeviceId(),  // V2.10.2: Re-enabled
                                last_ordered_at: new Date().toISOString()
                            }));
                            
                            // Update all at once using upsert
                            for (const update of updates) {
                                await supabase
                                    .from('tasks')
                                    .update({
                                        manual_order: update.manual_order,
                                        last_ordered_device: update.last_ordered_device,  // V2.10.2: Re-enabled
                                        last_ordered_at: update.last_ordered_at
                                    })
                                    .eq('id', update.id)
                                    .eq('user_id', user.id);
                            }
                        } catch (error) {
                            console.error('‚ùå Batch save error:', error);
                        }
                    };
                    
                    batchUpdate();
                }
                
                showToast('Task moved up', false);
            };
            
            // V2.6.0-BUTTONS: Move task down in manual order
            const moveTaskDown = (taskId) => {
                const visibleTasks = [...filteredTasks];
                const currentIndex = visibleTasks.findIndex(t => t.id === taskId);
                
                if (currentIndex < 0 || currentIndex >= visibleTasks.length - 1) return; // Already at bottom
                
                console.log('‚¨áÔ∏è Moving task down:', visibleTasks[currentIndex].text);
                
                // Swap with task below
                [visibleTasks[currentIndex], visibleTasks[currentIndex + 1]] = 
                [visibleTasks[currentIndex + 1], visibleTasks[currentIndex]];
                
                // Reassign manual order
                const updatedTasks = tasks.map(task => {
                    const visibleIndex = visibleTasks.findIndex(t => t.id === task.id);
                    if (visibleIndex !== -1) {
                        return { ...task, manualOrder: visibleIndex };
                    }
                    return task;
                });
                
                setTasks(updatedTasks);
                setIsManualOrder(true);
                
                // V2.6.3-FIX: Batch save with single Supabase call to reduce real-time events
                const tasksToSave = updatedTasks.filter(t => t.manualOrder !== null && t.supabaseId);
                if (tasksToSave.length > 0 && user) {
                    // Use a single batch update instead of individual saves
                    const batchUpdate = async () => {
                        try {
                            const updates = tasksToSave.map(task => ({
                                id: task.supabaseId,
                                user_id: user.id,
                                manual_order: task.manualOrder,
                                last_ordered_device: getDeviceId(),  // V2.10.2: Re-enabled
                                last_ordered_at: new Date().toISOString()
                            }));
                            
                            // Update all at once
                            for (const update of updates) {
                                await supabase
                                    .from('tasks')
                                    .update({
                                        manual_order: update.manual_order,
                                        last_ordered_device: update.last_ordered_device,  // V2.10.2: Re-enabled
                                        last_ordered_at: update.last_ordered_at
                                    })
                                    .eq('id', update.id)
                                    .eq('user_id', user.id);
                            }
                        } catch (error) {
                            console.error('‚ùå Batch save error:', error);
                        }
                    };
                    
                    batchUpdate();
                }
                
                showToast('Task moved down', false);
            };

            const updateListTask = async (listId, taskId, updates) => {
                // V2.7.1: Update local state and capture updated list
                let updatedList = null;
                setCustomLists(prev => prev.map(list => {
                    if (list.id === listId) {
                        updatedList = { ...list, tasks: list.tasks.map(t => t.id === taskId ? { ...t, ...updates } : t) };
                        return updatedList;
                    }
                    return list;
                }));
                
                // V2.7.1: Save updated list to Supabase
                if (user && !isLoadingFromSupabase && updatedList) {
                    await saveListToSupabase(updatedList);
                }
            };

            const deleteTask = (taskId) => {
                const taskToDelete = tasks.find(t => t.id === taskId);
                setUndoData({ action: 'deleteTask', data: taskToDelete });
                setTasks(prev => prev.filter(task => task.id !== taskId));
                
                // V2.5.0-SYNC: Delete from Supabase
                if (taskToDelete && user) {
                    deleteTaskFromSupabase(taskToDelete);
                }
                
                showToast('Task deleted', true);
            };

            const duplicateTask = async (taskId) => {
                const task = tasks.find(t => t.id === taskId);
                if (task) {
                    // V2.7.0 FIX: Create completely new task with new Supabase ID
                    const tempId = 'temp_' + Date.now();
                    const duplicate = {
                        ...task,
                        id: tempId,
                        supabaseId: undefined, // V2.7.0: Remove old Supabase ID so new one is created
                        text: task.text + ' (Copy)',
                        status: 'not-started',
                        createdAt: new Date().toISOString(),
                        startedAt: null,
                        completedAt: null,
                        subtasks: task.subtasks.map(st => ({
                            ...st,
                            id: Date.now() + Math.random(),
                            status: 'not-started',
                            startedAt: null,
                            completedAt: null
                        }))
                    };
                    
                    // Add to local state immediately
                    setTasks(prev => [...prev, duplicate]);
                    showToast('Task duplicated');
                    
                    // V2.7.0: Save to Supabase to get real ID
                    if (user && !isLoadingFromSupabase) {
                        try {
                            const savedTask = await saveTaskToSupabase(duplicate);
                            if (savedTask && savedTask.id) {
                                // Replace temp task with task using Supabase ID
                                setTasks(prev => prev.map(t => 
                                    t.id === tempId 
                                        ? { ...t, id: savedTask.id, supabaseId: savedTask.id }
                                        : t
                                ));
                                console.log('‚úÖ Duplicate task saved to Supabase with new ID:', savedTask.id);
                            }
                        } catch (error) {
                            console.error('‚ùå Error saving duplicate task:', error);
                        }
                    }
                }
            };

            const archiveTask = (taskId) => {
                updateTask(taskId, { archived: true });
                showToast('Task archived');
            };

            const restoreTask = (taskId) => {
                updateTask(taskId, { archived: false });
                showToast('Task restored');
            };
            
            // V2.5.13-STABLE: Push current order to cloud
            const pushOrderToCloud = async () => {
                if (!user) {
                    showToast('‚ùå Please log in first', true);
                    return;
                }
                
                console.log('üì§ PUSH: Starting push order to cloud');
                console.log('üì§ PUSH: Current device:', getDeviceId());
                console.log('üì§ PUSH: Total tasks:', tasks.length);
                
                try {
                    setSyncStatus('syncing');
                    setIsLoadingFromSupabase(true);
                    
                    // Get all tasks that have manual order
                    const tasksWithOrder = tasks.filter(t => t.manualOrder !== null && t.manualOrder !== undefined && t.supabaseId);
                    
                    console.log('üì§ PUSH: Tasks with order:', tasksWithOrder.length);
                    console.log('üì§ PUSH: Manual orders:', tasksWithOrder.map(t => ({ text: t.text.substring(0, 20), order: t.manualOrder })));
                    
                    if (tasksWithOrder.length === 0) {
                        showToast('‚ÑπÔ∏è No order to push', false);
                        setSyncStatus('synced');
                        setIsLoadingFromSupabase(false);
                        return;
                    }
                    
                    // Save all tasks with current order
                    const deviceId = getDeviceId();
                    const timestamp = new Date().toISOString();
                    
                    console.log(`üì§ PUSH: Pushing order for ${tasksWithOrder.length} tasks from ${deviceId}`);
                    
                    const updates = tasksWithOrder.map(task => ({
                        id: task.supabaseId,
                        manual_order: task.manualOrder,
                        last_ordered_device: deviceId,  // V2.10.2: Re-enabled
                        last_ordered_at: timestamp
                    }));
                    
                    // Update all in parallel
                    const results = await Promise.all(updates.map(async (update) => {
                        const { error } = await supabase
                            .from('tasks')
                            .update({
                                manual_order: update.manual_order,
                                last_ordered_device: update.last_ordered_device,  // V2.10.2: Re-enabled
                                last_ordered_at: update.last_ordered_at
                            })
                            .eq('id', update.id)
                            .eq('user_id', user.id);
                        
                        if (error) {
                            console.error('üì§ PUSH: Error updating task', update.id, error);
                            throw error;
                        }
                        return update.id;
                    }));
                    
                    console.log(`‚úÖ PUSH: Successfully pushed ${results.length} tasks`);
                    showToast(`‚úÖ Order pushed to cloud from ${deviceId}!`);
                    setSyncStatus('synced');
                    setLastSyncTime(new Date());
                    
                } catch (error) {
                    console.error('‚ùå PUSH: Failed:', error);
                    showToast('‚ùå Failed to push order', true);
                    setSyncStatus('error');
                } finally {
                    setIsLoadingFromSupabase(false);
                }
            };
            
            // V2.5.13-STABLE: Pull order from cloud
            const pullOrderFromCloud = async () => {
                if (!user) {
                    showToast('‚ùå Please log in first', true);
                    return;
                }
                
                console.log('üì• PULL: Starting pull order from cloud');
                console.log('üì• PULL: Current device:', getDeviceId());
                
                try {
                    setSyncStatus('syncing');
                    setIsLoadingFromSupabase(true);
                    
                    // Get all tasks from Supabase with their manual_order
                    const { data, error } = await supabase
                        .from('tasks')
                        .select('id, manual_order, last_ordered_device, last_ordered_at')  // V2.10.2: Re-enabled
                        .eq('user_id', user.id)
                        .not('manual_order', 'is', null)
                        .order('manual_order');
                    
                    if (error) throw error;
                    
                    console.log('üì• PULL: Retrieved', data?.length || 0, 'tasks from cloud');
                    
                    if (!data || data.length === 0) {
                        showToast('‚ÑπÔ∏è No order to pull', false);
                        setSyncStatus('synced');
                        setIsLoadingFromSupabase(false);
                        return;
                    }
                    
                    console.log('üì• PULL: Cloud orders:', data.map(t => ({ id: t.id, order: t.manual_order, device: t.last_ordered_device })));
                    
                    // Update local tasks with Supabase manual_order
                    setTasks(prev => {
                        const updated = prev.map(task => {
                            const supabaseTask = data.find(t => t.id === task.supabaseId);
                            if (supabaseTask && supabaseTask.manual_order !== null) {
                                console.log(`üì• PULL: Updating task ${task.text.substring(0, 20)} order: ${task.manualOrder} ‚Üí ${supabaseTask.manual_order}`);
                                return { ...task, manualOrder: supabaseTask.manual_order };
                            }
                            return task;
                        });
                        
                        console.log('üì• PULL: Final local orders:', updated.filter(t => t.manualOrder !== null).map(t => ({ text: t.text.substring(0, 20), order: t.manualOrder })));
                        return updated;
                    });
                    
                    setIsManualOrder(true);
                    
                    // V2.10.2: Restored device name in message
                    const latestOrder = data.reduce((latest, current) => {
                        if (!latest || new Date(current.last_ordered_at) > new Date(latest.last_ordered_at)) {
                            return current;
                        }
                        return latest;
                    }, null);
                    
                    const sourceDevice = latestOrder?.last_ordered_device || 'cloud';
                    
                    console.log(`‚úÖ PULL: Successfully pulled order from ${sourceDevice}`);
                    showToast(`‚úÖ Order pulled from ${sourceDevice}!`);
                    setSyncStatus('synced');
                    setLastSyncTime(new Date());
                    
                } catch (error) {
                    console.error('‚ùå PULL: Failed:', error);
                    showToast('‚ùå Failed to pull order', true);
                    setSyncStatus('error');
                } finally {
                    setIsLoadingFromSupabase(false);
                }
            };

            const toggleTaskStatus = (taskId) => {
                // V2.11.1: Clear rapid entry mode when user clicks checkbox
                // This prevents focus from jumping back to input
                isCreatingTasksRef.current = false;
                
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;

                let newStatus = task.status === 'not-started' ? 'in-progress' : 
                               task.status === 'in-progress' ? 'completed' : 'not-started';
                const now = new Date().toISOString();
                
                const updates = {
                    status: newStatus,
                    startedAt: newStatus === 'in-progress' && !task.startedAt ? now : task.startedAt,
                    completedAt: newStatus === 'completed' ? now : null
                };

                // Handle recurring tasks
                if (newStatus === 'completed' && task.recurringPattern) {
                    const nextDate = getNextRecurrence(task);
                    if (nextDate) {
                        createTask({
                            ...task,
                            scheduledDate: nextDate,
                            status: 'not-started',
                            startedAt: null,
                            completedAt: null,
                            createdAt: now
                        });
                        showToast(`Recurring task created for ${nextDate}`);
                    }
                }

                updateTask(taskId, updates);
                // V2.11.6: Scroll preservation now handled by useEffect
            };

            // V2.11.6: Toggle completion zone (vault completed tasks)
            const toggleCompletionZone = (taskId) => {
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                
                // Only completed tasks can be moved to completion zone
                if (task.status !== 'completed') {
                    showToast('Only completed tasks can be moved to completion zone');
                    return;
                }
                
                const newState = !task.inCompletionZone;
                updateTask(taskId, { inCompletionZone: newState });
                
                if (newState) {
                    showToast('Task moved to Completion Zone üèÜ');
                } else {
                    showToast('Task restored from Completion Zone');
                }
            };

            const addSubtask = (parentId, subtaskText) => {
                const task = tasks.find(t => t.id === parentId);
                if (!task || !subtaskText.trim()) return;

                const newSubtask = {
                    id: Date.now(),
                    text: subtaskText,
                    status: 'not-started',
                    taskType: task.taskType || 'consistency',
                    priority: task.priority || 'medium',
                    priority_rating: task.priority_rating !== undefined ? task.priority_rating : 5, // V2.7.0: Inherit from parent
                    persona: task.persona,
                    isOldTask: false,
                    dueDate: task.dueDate || null,
                    dueLabel: null,
                    timeSlot: null,
                    estimatedDuration: null,
                    tags: [],
                    notes: '',
                    createdAt: new Date().toISOString(),
                    startedAt: null,
                    completedAt: null
                };

                updateTask(parentId, {
                    subtasks: [...(task.subtasks || []), newSubtask]
                });
            };

            const updateSubtask = (parentId, subtaskId, updates) => {
                const task = tasks.find(t => t.id === parentId);
                if (!task) return;

                const updatedSubtasks = task.subtasks.map(st =>
                    st.id === subtaskId ? { ...st, ...updates } : st
                );
                updateTask(parentId, { subtasks: updatedSubtasks });
            };

            const deleteSubtask = (parentId, subtaskId) => {
                const task = tasks.find(t => t.id === parentId);
                if (!task) return;

                updateTask(parentId, {
                    subtasks: task.subtasks.filter(st => st.id !== subtaskId)
                });
                showToast('Subtask deleted');
            };

            const toggleSubtaskStatus = (parentId, subtaskId) => {
                const task = tasks.find(t => t.id === parentId);
                if (!task) return;

                const subtask = task.subtasks.find(st => st.id === subtaskId);
                if (!subtask) return;

                let newStatus = subtask.status === 'not-started' ? 'in-progress' :
                               subtask.status === 'in-progress' ? 'completed' : 'not-started';
                const now = new Date().toISOString();

                updateSubtask(parentId, subtaskId, {
                    status: newStatus,
                    startedAt: newStatus === 'in-progress' && !subtask.startedAt ? now : subtask.startedAt,
                    completedAt: newStatus === 'completed' ? now : null
                });
            };

            // ====== LISTS HANDLERS ======
            const handleAddToList = async (listId, text, isRapidEntry = false) => {
                if (!text?.trim()) return;
                
                const newTask = {
                    id: Date.now(),
                    text: text.trim(),
                    status: 'not-started',
                    priority: 'medium',
                    priority_rating: 5, // V2.7.0: Add priority rating
                    taskType: 'consistency',
                    persona: personas[0],
                    project: null,
                    scheduledDate: null,
                    dueDate: null,
                    timeSlot: null,
                    estimatedDuration: null,
                    tags: [],
                    notes: '',
                    subtasks: [],
                    createdAt: new Date().toISOString(),
                    startedAt: null,
                    completedAt: null
                };
                
                // V2.7.1: Update local state
                let updatedList = null;
                setCustomLists(prev => prev.map(list => {
                    if (list.id === listId) {
                        updatedList = {...list, tasks: [...list.tasks, newTask]};
                        return updatedList;
                    }
                    return list;
                }));
                
                // V2.7.1 FIX: Suppress toast during rapid entry to prevent focus loss
                if (!isRapidEntry) {
                    const listName = customLists.find(l => l.id === listId)?.name;
                    console.log('üì¢ Showing toast (not rapid entry)');
                    showToast(`Item added to ${listName}`);
                } else {
                    console.log('üîá Toast suppressed (rapid entry mode)');
                }
                
                // V2.7.1: Save updated list to Supabase
                if (user && !isLoadingFromSupabase && updatedList) {
                    await saveListToSupabase(updatedList);
                }
            };

            const handleDeleteFromList = async (taskId, listId) => {
                console.log('üóëÔ∏è DELETE: Starting deletion', { taskId, listId });
                
                // V2.7.7 FINAL FIX: Calculate updated list BEFORE setState
                // Don't rely on setState callback - it's async!
                const currentList = customLists.find(l => l.id === listId);
                if (!currentList) {
                    console.error('‚ùå DELETE: List not found!', listId);
                    return;
                }
                
                // Calculate updated list BEFORE any setState
                const updatedList = {
                    ...currentList,
                    tasks: currentList.tasks.filter(t => t.id !== taskId)
                };
                
                console.log('üóëÔ∏è DELETE: Updated list has', updatedList.tasks.length, 'items');
                
                // Now update state with the pre-calculated list
                setCustomLists(prev => prev.map(list => 
                    list.id === listId ? updatedList : list
                ));
                
                showToast('Item removed from list');
                
                // V2.7.7: updatedList was calculated BEFORE setState, guaranteed to exist
                console.log('üóëÔ∏è DELETE: Checking save conditions...', {
                    hasUser: !!user,
                    notLoading: !isLoadingFromSupabase,
                    hasUpdatedList: !!updatedList
                });
                
                if (user && !isLoadingFromSupabase && updatedList) {
                    console.log('üóëÔ∏è DELETE: Conditions met, saving to Supabase...');
                    await saveListToSupabase(updatedList);
                    console.log('‚úÖ DELETE: Save completed!');
                } else {
                    console.error('‚ùå DELETE: Save SKIPPED due to conditions!', {
                        user: !!user,
                        isLoadingFromSupabase,
                        updatedList: !!updatedList
                    });
                }
            };

            const handleToggleListTaskStatus = async (taskId, listId) => {
                // V2.11.2: Clear rapid entry mode
                isCreatingTasksRef.current = false;
                
                // V2.7.1: Update local state and capture updated list
                let updatedList = null;
                setCustomLists(prev => prev.map(list => {
                    if (list.id !== listId) return list;
                    
                    updatedList = {
                        ...list,
                        tasks: list.tasks.map(task => {
                            if (task.id !== taskId) return task;
                            
                            // V2.7.2: Three-state cycle: not-started ‚Üí in-progress ‚Üí done ‚Üí not-started
                            let newStatus;
                            if (task.status === 'not-started' || !task.status) {
                                newStatus = 'in-progress';
                            } else if (task.status === 'in-progress') {
                                newStatus = 'done';
                            } else {
                                newStatus = 'not-started';
                            }
                            
                            const now = new Date().toISOString();
                            
                            return {
                                ...task,
                                status: newStatus,
                                completedAt: newStatus === 'done' ? now : null
                            };
                        })
                    };
                    return updatedList;
                }));
                
                // V2.7.1: Save updated list to Supabase
                if (user && !isLoadingFromSupabase && updatedList) {
                    await saveListToSupabase(updatedList);
                }
                // V2.11.4: Scroll preservation now handled by useEffect
            };
            
            const handleUpdateListTaskText = async (taskId, listId, newText) => {
                // V2.7.1: Update list item text
                let updatedList = null;
                setCustomLists(prev => prev.map(list => {
                    if (list.id === listId) {
                        updatedList = {
                            ...list, 
                            tasks: list.tasks.map(t => 
                                t.id === taskId ? {...t, text: newText} : t
                            )
                        };
                        return updatedList;
                    }
                    return list;
                }));
                
                // V2.7.1: Save updated list to Supabase
                if (user && !isLoadingFromSupabase && updatedList) {
                    await saveListToSupabase(updatedList);
                }
            };
            
            const handleUpdateListTaskNotes = async (taskId, listId, newNotes) => {
                // V2.7.2: Update list item notes
                let updatedList = null;
                setCustomLists(prev => prev.map(list => {
                    if (list.id === listId) {
                        updatedList = {
                            ...list, 
                            tasks: list.tasks.map(t => 
                                t.id === taskId ? {...t, notes: newNotes} : t
                            )
                        };
                        return updatedList;
                    }
                    return list;
                }));
                
                // V2.7.2: Save updated list to Supabase
                if (user && !isLoadingFromSupabase && updatedList) {
                    await saveListToSupabase(updatedList);
                }
            };

            // V2.7.5 NEW: Move item from one list to another
            const handleMoveItemToList = async (taskId, sourceListId, targetListId) => {
                console.log('üì¶ MOVE: Starting move', { taskId, sourceListId, targetListId });
                
                if (sourceListId === targetListId) {
                    showToast('Item is already in this list');
                    return;
                }
                
                let sourceList = null;
                let targetList = null;
                let itemToMove = null;
                
                // Find the item to move
                setCustomLists(prev => {
                    sourceList = prev.find(l => l.id === sourceListId);
                    targetList = prev.find(l => l.id === targetListId);
                    
                    if (!sourceList || !targetList) {
                        console.error('‚ùå MOVE: Lists not found!');
                        return prev;
                    }
                    
                    itemToMove = sourceList.tasks.find(t => t.id === taskId);
                    if (!itemToMove) {
                        console.error('‚ùå MOVE: Item not found!');
                        return prev;
                    }
                    
                    console.log('üì¶ MOVE: Moving item:', itemToMove.text);
                    
                    // V2.7.5: Reset status to 'not-started' when moving (custom states might differ)
                    const movedItem = {
                        ...itemToMove,
                        status: 'not-started'  // Reset to first state
                    };
                    
                    // Remove from source, add to target
                    const updatedSource = {
                        ...sourceList,
                        tasks: sourceList.tasks.filter(t => t.id !== taskId)
                    };
                    
                    const updatedTarget = {
                        ...targetList,
                        tasks: [...targetList.tasks, movedItem]
                    };
                    
                    console.log('üì¶ MOVE: Source now has', updatedSource.tasks.length, 'items');
                    console.log('üì¶ MOVE: Target now has', updatedTarget.tasks.length, 'items');
                    
                    // Return updated state
                    return prev.map(list => {
                        if (list.id === sourceListId) return updatedSource;
                        if (list.id === targetListId) return updatedTarget;
                        return list;
                    });
                });
                
                // Save both lists
                if (user && !isLoadingFromSupabase && sourceList && targetList) {
                    console.log('üì¶ MOVE: Saving both lists to Supabase...');
                    const updatedSource = {
                        ...sourceList,
                        tasks: sourceList.tasks.filter(t => t.id !== taskId)
                    };
                    const movedItem = { ...itemToMove, status: 'not-started' };
                    const updatedTarget = {
                        ...targetList,
                        tasks: [...targetList.tasks, movedItem]
                    };
                    
                    await Promise.all([
                        saveListToSupabase(updatedSource),
                        saveListToSupabase(updatedTarget)
                    ]);
                    
                    showToast(`Moved to ${targetList.name}`);
                    console.log('‚úÖ MOVE: Save completed!');
                }
            };

            // V2.8.0 NEW: Archive/unarchive item in list
            const handleArchiveListItem = async (taskId, listId) => {
                console.log('üì¶ ARCHIVE: Toggling archive', { taskId, listId });
                
                const currentList = customLists.find(l => l.id === listId);
                if (!currentList) {
                    console.error('‚ùå ARCHIVE: List not found!', listId);
                    return;
                }
                
                const item = currentList.tasks.find(t => t.id === taskId);
                if (!item) {
                    console.error('‚ùå ARCHIVE: Item not found!', taskId);
                    return;
                }
                
                const newArchivedState = !item.archived;
                
                const updatedList = {
                    ...currentList,
                    tasks: currentList.tasks.map(t => 
                        t.id === taskId ? {...t, archived: newArchivedState} : t
                    )
                };
                
                console.log('üì¶ ARCHIVE: Item now', newArchivedState ? 'archived' : 'unarchived');
                
                setCustomLists(prev => prev.map(list => 
                    list.id === listId ? updatedList : list
                ));
                
                showToast(newArchivedState ? 'Item archived' : 'Item unarchived');
                
                if (user && !isLoadingFromSupabase && updatedList) {
                    await saveListToSupabase(updatedList);
                }
            };

            // V2.7.1: handleAddNewList removed - now handled inside ListsManagementModal component

            const handleDeleteList = async (listId) => {
                const list = customLists.find(l => l.id === listId);
                if (!list) return;
                
                if (list.tasks.length > 0) {
                    if (!confirm(`Delete "${list.name}" with ${list.tasks.length} items?`)) {
                        return;
                    }
                }
                
                // V2.7.1: Delete from local state
                setCustomLists(prev => prev.filter(l => l.id !== listId));
                if (currentView === `list:${listId}`) {
                    setCurrentView('list');
                }
                showToast('List deleted');
                
                // V2.7.1: Delete from Supabase
                if (user && !isLoadingFromSupabase) {
                    await deleteListFromSupabase(list);
                }
            };
            
            // V2.7.1 NEW: Rename list
            const handleRenameList = async (listId) => {
                const list = customLists.find(l => l.id === listId);
                if (!list) return;
                
                const newName = prompt('Rename list:', list.name);
                if (!newName || newName.trim() === '' || newName === list.name) return;
                
                const updatedList = { ...list, name: newName.trim() };
                
                // Update local state
                setCustomLists(prev => prev.map(l => 
                    l.id === listId ? updatedList : l
                ));
                
                showToast(`List renamed to "${newName.trim()}"`);
                
                // Save to Supabase
                if (user && !isLoadingFromSupabase) {
                    await saveListToSupabase(updatedList);
                }
            };

            // ====== STATUS SYSTEM HELPERS ======
            
            // Comprehensive status icon library
            const STATUS_ICON_LIBRARY = {
                // Default statuses
                'not-started': { icon: '‚óã', color: 'text-gray-400', label: 'Not Started' },
                'in-progress': { icon: '‚ñ∂', color: 'text-yellow-600', label: 'In Progress' },
                'completed': { icon: '‚úì', color: 'text-green-600', label: 'Completed' },
                
                // Common workflow statuses
                'to-do': { icon: '‚ñ°', color: 'text-blue-500', label: 'To Do' },
                'done': { icon: '‚úì', color: 'text-green-600', label: 'Done' },
                'in-review': { icon: 'üëÄ', color: 'text-blue-600', label: 'In Review' },
                'reviewing': { icon: 'üëÄ', color: 'text-blue-600', label: 'Reviewing' },
                
                // Discussion/Communication statuses
                'awaiting-discussion': { icon: 'üí¨', color: 'text-purple-600', label: 'Awaiting Discussion' },
                'awaiting-approval': { icon: '‚úã', color: 'text-orange-500', label: 'Awaiting Approval' },
                'awaiting-input': { icon: 'üì®', color: 'text-indigo-500', label: 'Awaiting Input' },
                
                // Pause/Delay statuses
                'delayed': { icon: '‚è∞', color: 'text-red-600', label: 'Delayed' },
                'delayed-parked': { icon: '‚è∏', color: 'text-orange-600', label: 'Delayed/Parked' },
                'parked': { icon: 'üÖø', color: 'text-gray-600', label: 'Parked' },
                'on-hold': { icon: '‚è∏', color: 'text-yellow-700', label: 'On Hold' },
                'paused': { icon: '‚è∏', color: 'text-yellow-600', label: 'Paused' },
                
                // Priority/Speed statuses
                'set-aside': { icon: 'üìå', color: 'text-indigo-600', label: 'Set Aside' },
                'go-slow': { icon: 'üê¢', color: 'text-blue-400', label: 'Go Slow' },
                'urgent': { icon: 'üî•', color: 'text-red-600', label: 'Urgent' },
                'fast-track': { icon: '‚ö°', color: 'text-yellow-500', label: 'Fast Track' },
                
                // Blocking/Issue statuses
                'blocked': { icon: 'üö´', color: 'text-red-700', label: 'Blocked' },
                'disabled': { icon: '‚äò', color: 'text-gray-500', label: 'Disabled' },
                'do-not-execute': { icon: 'üõë', color: 'text-red-800', label: 'Do Not Execute' },
                'needs-info': { icon: '‚ùì', color: 'text-blue-500', label: 'Needs Info' },
                
                // Completion variants
                'cancelled': { icon: '‚úó', color: 'text-gray-500', label: 'Cancelled' },
                'archived': { icon: 'üì¶', color: 'text-gray-400', label: 'Archived' },
                'verified': { icon: '‚úì‚úì', color: 'text-green-700', label: 'Verified' },
                
                // Fallback for unknown statuses
                'default': { icon: '‚óè', color: 'text-gray-500', label: 'Status' }
            };
            
            // Get status icon/color/label for any status
            const getStatusIcon = (status) => {
                if (!status) return STATUS_ICON_LIBRARY['not-started'];
                
                // Direct match
                if (STATUS_ICON_LIBRARY[status]) {
                    return STATUS_ICON_LIBRARY[status];
                }
                
                // Fuzzy match: convert status to readable label
                const label = status
                    .split('-')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                
                // Return with generated label
                return {
                    icon: STATUS_ICON_LIBRARY['default'].icon,
                    color: STATUS_ICON_LIBRARY['default'].color,
                    label: label
                };
            };
            
            // Get statuses for a task based on its project
            const getTaskStatuses = (task) => {
                if (!task.project) {
                    // No project = use default statuses
                    return ['not-started', 'in-progress', 'completed'];
                }
                
                const project = projects.find(p => p.name === task.project);
                return project?.statuses || ['not-started', 'in-progress', 'completed'];
            };
            
            // Get next status in circular cycle
            const getNextStatus = (task) => {
                const statuses = getTaskStatuses(task);
                const currentIndex = statuses.indexOf(task.status);
                
                if (currentIndex === -1) {
                    // Current status not in list, return first status
                    return statuses[0];
                }
                
                // Circular: wrap to beginning after last status
                const nextIndex = (currentIndex + 1) % statuses.length;
                return statuses[nextIndex];
            };

            // ====== DRAG AND DROP HANDLERS ======
            const handleDragStart = (e, item, type) => {
                console.log('üî• Drag:', item.text || item.id);
                
                // Simple approach - just set data and effectAllowed
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', JSON.stringify({ item, type }));
                
                // Set state for React
                setDraggedItem({ item, type });
                window.__draggedItem = { item, type };
                
                // Visual feedback
                if (e.currentTarget) {
                    e.currentTarget.style.opacity = '0.4';
                    e.currentTarget.classList.add('dragging');
                }
            };

            const handleDragEnd = (e) => {
                // Restore visual
                if (e.currentTarget) {
                    e.currentTarget.style.opacity = '1';
                    e.currentTarget.classList.remove('dragging');
                }
                
                // FIX Issues 1-2, 3: Clear ALL drag states
                setDraggedItem(null);
                setDraggedTask(null);
                setDragOverZone(null);
                setCurrentDropZone(null);
                isDraggingRef.current = false;
                draggedTaskRef.current = null;
                currentDropZoneRef.current = null;
                delete window.__draggedItem;
                
                // FIX Issue 3: Clear all visual drop zone indicators from DOM
                document.querySelectorAll('.drop-zone-active, .bg-blue-200, .bg-blue-100').forEach(el => {
                    el.classList.remove('drop-zone-active', 'bg-blue-200', 'bg-blue-100');
                });
                
                // Force reflow to ensure states cleared
                setTimeout(() => {
                    console.log('‚úÖ All drag states cleared');
                }, 0);
                
                console.log('üèÅ End drag');
            };

            const handleDragOver = (e, zone, zoneData) => {
                e.preventDefault(); // CRITICAL: Must prevent default
                e.stopPropagation(); // Stop event bubbling
                e.dataTransfer.dropEffect = 'move'; // Set drop effect
                console.log('üëÜ Over:', zone);
                setDragOverZone({ zone, data: zoneData });
                return false; // Additional safety
            };

            const handleDragLeave = (e) => {
                setDragOverZone(null);
            };

            const handleDrop = (e, zone, zoneData) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('üíß Drop:', zone);
                
                // Get dragged data - try all methods
                let draggedData = null;
                
                // Method 1: text/plain (most reliable)
                try {
                    const textData = e.dataTransfer.getData('text/plain');
                    if (textData) {
                        draggedData = JSON.parse(textData);
                    }
                } catch (err) {}
                
                // Method 2: From window backup
                if (!draggedData && window.__draggedItem) {
                    draggedData = window.__draggedItem;
                }
                
                // Method 3: From state
                if (!draggedData && draggedItem) {
                    draggedData = draggedItem;
                }
                
                if (!draggedData) {
                    console.log('‚ùå No data');
                    return;
                }

                const { item, type } = draggedData;
                console.log('‚úÖ Dropped:', item.text);

                // Handle different drop zones
                if (zone === 'calendar-date' && type === 'task') {
                    updateTask(item.id, { scheduledDate: zoneData.date });
                    showToast(`Task moved to ${zoneData.date}`, true);
                } else if (zone === 'timeline-slot' && type === 'task') {
                    // CRITICAL FIX: Ensure task has scheduled date when dropped in timeline
                    const updates = { timeSlot: zoneData.slot };
                    
                    // If task doesn't have a scheduled date, set it to selected date
                    const task = tasks.find(t => t.id === item.id);
                    if (!task?.scheduledDate) {
                        updates.scheduledDate = selectedDate;
                        console.log('üìÖ Setting scheduled date:', selectedDate);
                    }
                    
                    updateTask(item.id, updates);
                    showToast(`Task scheduled at ${zoneData.slot}`, true);
                } else if (zone === 'kanban-column' && type === 'task') {
                    updateTask(item.id, { status: zoneData.status });
                    showToast(`Task status updated`, true);
                } else if (zone === 'project' && type === 'task') {
                    updateTask(item.id, { project: zoneData.projectId });
                    showToast(`Task assigned to project`, true);
                } else if (zone === 'persona' && type === 'task') {
                    updateTask(item.id, { persona: zoneData.persona });
                    showToast(`Task assigned to persona`, true);
                } else if (zone === 'custom-list') {
                    const targetListId = zoneData.listId;
                    
                    // From main tasks to list
                    if (item.source === 'main') {
                        const task = tasks.find(t => t.id === item.id);
                        if (task) {
                            setTasks(prev => prev.filter(t => t.id !== item.id));
                            setCustomLists(prev => prev.map(list =>
                                list.id === targetListId
                                    ? {...list, tasks: [...list.tasks, task]}
                                    : list
                            ));
                            showToast('Task moved to list', true);
                        }
                    }
                    // Between lists
                    else if (item.source === 'list' && item.sourceListId) {
                        const sourceList = customLists.find(l => l.id === item.sourceListId);
                        const task = sourceList?.tasks.find(t => t.id === item.id);
                        if (task && item.sourceListId !== targetListId) {
                            setCustomLists(prev => prev.map(list => {
                                if (list.id === item.sourceListId) {
                                    return {...list, tasks: list.tasks.filter(t => t.id !== item.id)};
                                }
                                if (list.id === targetListId) {
                                    return {...list, tasks: [...list.tasks, task]};
                                }
                                return list;
                            }));
                            showToast('Task moved between lists', true);
                        }
                    }
                }
                // V1.3: Manual reordering within list
                else if (zone === 'reorder' && type === 'task') {
                    const draggedTaskId = item.id;
                    const targetTaskId = zoneData.targetTaskId;
                    const position = zoneData.position; // 'before' or 'after'
                    
                    const taskList = [...tasks];
                    const draggedIndex = taskList.findIndex(t => t.id === draggedTaskId);
                    const targetIndex = taskList.findIndex(t => t.id === targetTaskId);
                    
                    if (draggedIndex !== -1 && targetIndex !== -1) {
                        // Remove dragged task
                        const [draggedTask] = taskList.splice(draggedIndex, 1);
                        
                        // Insert at new position
                        const newIndex = position === 'before' ? targetIndex : targetIndex + 1;
                        taskList.splice(draggedIndex < targetIndex ? newIndex - 1 : newIndex, 0, draggedTask);
                        
                        // Assign manual order values
                        const updatedTasks = tasks.map((task, idx) => {
                            const newPosition = taskList.findIndex(t => t.id === task.id);
                            return { ...task, manualOrder: newPosition };
                        });
                        
                        setTasks(updatedTasks);
                        setIsManualOrder(true);
                        showToast('Task reordered', true);
                    }
                }

                setDraggedItem(null);
                setDragOverZone(null);
                delete window.__draggedItem;
            };

            // ====== V1.4: MOUSE-BASED DRAG SYSTEM (WORKS EVERYWHERE!) ======
            const handleMouseDragStart = (e, task) => {
                // Only left click
                if (e.button !== 0) return;
                
                e.preventDefault();
                console.log('üñ±Ô∏è Mouse drag:', task.text);
                
                // Use refs for immediate tracking
                isDraggingRef.current = true;
                draggedTaskRef.current = task;
                
                // Also set state for UI updates
                setIsDragging(true);
                setDraggedTask(task);
                setDragStartPos({ x: e.clientX, y: e.clientY });
                
                // Add global mouse listeners
                document.addEventListener('mousemove', handleMouseDragMove);
                document.addEventListener('mouseup', handleMouseDragEnd);
            };
            
            // V2.5.13-FIX: Touch-based drag for mobile
            const handleTouchDragStart = (e, task) => {
                // Prevent scrolling while dragging
                e.preventDefault();
                
                const touch = e.touches[0];
                console.log('üì± Touch drag:', task.text);
                
                // Use refs for immediate tracking
                isDraggingRef.current = true;
                draggedTaskRef.current = task;
                
                // Also set state for UI updates
                setIsDragging(true);
                setDraggedTask(task);
                setDragStartPos({ x: touch.clientX, y: touch.clientY });
                
                // Add global touch listeners
                document.addEventListener('touchmove', handleTouchDragMove, { passive: false });
                document.addEventListener('touchend', handleTouchDragEnd);
            };
            
            const handleMouseDragMove = (e) => {
                // Use ref for immediate check (state updates are async!)
                if (!isDraggingRef.current) {
                    return;
                }
                
                // Update drag position for ghost preview
                setDragStartPos({ x: e.clientX, y: e.clientY });
                
                // Find element under mouse
                const elementUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
                if (!elementUnderMouse) return;
                
                // Check if it's a drop zone
                const dropZone = elementUnderMouse.closest('[data-drop-zone]');
                if (dropZone) {
                    const zoneType = dropZone.getAttribute('data-drop-zone');
                    const zoneData = dropZone.getAttribute('data-drop-data');
                    
                    // Only log if zone changed (reduce spam)
                    if (currentDropZoneRef.current?.data !== zoneData) {
                        console.log('üëÜ Mouse over:', zoneType);
                    }
                    
                    currentDropZoneRef.current = { type: zoneType, data: zoneData };
                    setCurrentDropZone({ type: zoneType, data: zoneData });
                } else {
                    currentDropZoneRef.current = null;
                    setCurrentDropZone(null);
                }
            };
            
            // V2.5.13-FIX: Touch move handler
            const handleTouchDragMove = (e) => {
                // Prevent scrolling
                e.preventDefault();
                
                // Use ref for immediate check (state updates are async!)
                if (!isDraggingRef.current) {
                    return;
                }
                
                const touch = e.touches[0];
                
                // Update drag position for ghost preview
                setDragStartPos({ x: touch.clientX, y: touch.clientY });
                
                // Find element under touch
                const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                if (!elementUnderTouch) return;
                
                // Check if it's a drop zone
                const dropZone = elementUnderTouch.closest('[data-drop-zone]');
                if (dropZone) {
                    const zoneType = dropZone.getAttribute('data-drop-zone');
                    const zoneData = dropZone.getAttribute('data-drop-data');
                    
                    // Only log if zone changed (reduce spam)
                    if (currentDropZoneRef.current?.data !== zoneData) {
                        console.log('üëÜ Touch over:', zoneType);
                    }
                    
                    currentDropZoneRef.current = { type: zoneType, data: zoneData };
                    setCurrentDropZone({ type: zoneType, data: zoneData });
                } else {
                    currentDropZoneRef.current = null;
                    setCurrentDropZone(null);
                }
            };
            
            const handleMouseDragEnd = (e) => {
                console.log('üèÅ Mouse drop');
                
                // Remove global listeners
                document.removeEventListener('mousemove', handleMouseDragMove);
                document.removeEventListener('mouseup', handleMouseDragEnd);
                
                // Use refs for immediate access
                if (currentDropZoneRef.current && draggedTaskRef.current) {
                    console.log('üíß Dropped on:', currentDropZoneRef.current.type);
                    
                    // Parse drop zone data
                    let dropData = {};
                    try {
                        dropData = JSON.parse(currentDropZoneRef.current.data);
                    } catch (e) {}
                    
                    // Handle the drop based on zone type
                    if (currentDropZoneRef.current.type === 'timeline-slot') {
                        updateTask(draggedTaskRef.current.id, { 
                            timeSlot: dropData.slot,
                            scheduledDate: dropData.date || selectedDate
                        });
                        showToast(`Scheduled at ${dropData.slot}`, true);
                    }
                    else if (currentDropZoneRef.current.type === 'calendar-date') {
                        updateTask(draggedTaskRef.current.id, { 
                            scheduledDate: dropData.date
                        });
                        showToast(`Moved to ${dropData.date}`, true);
                    }
                    else if (currentDropZoneRef.current.type === 'persona') {
                        updateTask(draggedTaskRef.current.id, { 
                            persona: dropData.persona
                        });
                        showToast(`Assigned to ${dropData.persona}`, true);
                    }
                    else if (currentDropZoneRef.current.type === 'project' || currentDropZoneRef.current.type === 'kanban-column') {
                        console.log('üìã Kanban drop data:', dropData);
                        console.log('üìã Task before update:', draggedTaskRef.current);
                        
                        if (dropData.status) {
                            updateTask(draggedTaskRef.current.id, { 
                                status: dropData.status,
                                project: dropData.project || dropData.projectId
                            });
                            console.log('‚úÖ Updated task with status:', dropData.status, 'project:', dropData.project);
                            showToast(`Status updated to ${dropData.status}`, true);
                        } else {
                            updateTask(draggedTaskRef.current.id, { 
                                project: dropData.project || dropData.projectId
                            });
                            showToast(`Moved to project`, true);
                        }
                    }
                    else if (currentDropZoneRef.current.type === 'reorder') {
                        // FIX: Handle list reordering with FILTERED tasks only
                        const draggedTaskId = draggedTaskRef.current.id;
                        const targetTaskId = dropData.targetTaskId;
                        const position = dropData.position;
                        
                        console.log('üîÑ REORDER: Starting', { draggedTaskId, targetTaskId, position });
                        
                        // V2.5.8-FIX: Use CURRENT filteredTasks from screen instead of recalculating
                        // This prevents corruption from stale manualOrder values after page reload
                        const visibleTasks = [...filteredTasks];
                        const draggedIndex = visibleTasks.findIndex(t => t.id === draggedTaskId);
                        const targetIndex = visibleTasks.findIndex(t => t.id === targetTaskId);
                        
                        console.log('üîÑ REORDER: Using current visual order, indices:', { draggedIndex, targetIndex });
                        
                        if (draggedIndex !== -1 && targetIndex !== -1) {
                            // Remove dragged task
                            const [draggedTask] = visibleTasks.splice(draggedIndex, 1);
                            
                            // Insert at new position
                            const insertIndex = position === 'before' ? targetIndex : targetIndex + 1;
                            const finalIndex = draggedIndex < targetIndex ? insertIndex - 1 : insertIndex;
                            visibleTasks.splice(finalIndex, 0, draggedTask);
                            
                            console.log('üîÑ REORDER: New order', visibleTasks.map(t => t.text.substring(0, 20)));
                            
                            // Assign sequential order to visible tasks only
                            const updatedTasks = tasks.map(task => {
                                const visibleIndex = visibleTasks.findIndex(t => t.id === task.id);
                                if (visibleIndex !== -1) {
                                    return { ...task, manualOrder: visibleIndex };
                                }
                                return task;
                            });
                            
                            setTasks(updatedTasks);
                            setIsManualOrder(true);
                            
                            // SURGICAL FIX #2: Save manualOrder to Supabase (debounced)
                            if (user) {
                                // Get original manualOrder values before reorder
                                const originalOrders = new Map(tasks.map(t => [t.id, t.manualOrder]));
                                
                                // Only save tasks whose manualOrder actually changed
                                const tasksToSave = updatedTasks.filter(task => {
                                    const originalOrder = originalOrders.get(task.id);
                                    return task.manualOrder !== originalOrder;
                                });
                                
                                console.log(`üíæ Saving ${tasksToSave.length} tasks with new order to Supabase`);
                                
                                // V2.5.7-FIX: Block real-time updates during reorder save
                                isReorderingRef.current = true;
                                console.log('üîí Blocking real-time updates during reorder');
                                
                                // Clear any existing timeout
                                if (reorderTimeoutRef.current) {
                                    clearTimeout(reorderTimeoutRef.current);
                                }
                                
                                // Save all tasks in parallel for faster sync
                                if (tasksToSave.length > 0) {
                                    Promise.all(tasksToSave.map(task => saveTaskToSupabase(task)))
                                        .then(() => {
                                            console.log('‚úÖ Manual order saved to Supabase');
                                            // V2.5.8-FIX: Unblock after 2 seconds (was 1) to ensure all echoes settle
                                            reorderTimeoutRef.current = setTimeout(() => {
                                                isReorderingRef.current = false;
                                                console.log('üîì Unblocked real-time updates');
                                            }, 2000);
                                        })
                                        .catch(err => {
                                            console.error('‚ùå Error saving manual order:', err);
                                            // Unblock even on error
                                            reorderTimeoutRef.current = setTimeout(() => {
                                                isReorderingRef.current = false;
                                                console.log('üîì Unblocked real-time updates (after error)');
                                            }, 2000);
                                        });
                                }
                            }
                            
                            showToast('Task reordered', true);
                        } else {
                            console.log('‚ùå REORDER: Invalid indices!');
                        }
                    }
                } else {
                    console.log('‚ùå No drop zone or task');
                }
                
                // Reset refs
                isDraggingRef.current = false;
                draggedTaskRef.current = null;
                currentDropZoneRef.current = null;
                
                // Reset state
                setIsDragging(false);
                setDraggedTask(null);
                setDragStartPos(null);
                setCurrentDropZone(null);
            };
            
            // V2.5.13-FIX: Touch end handler (mirrors mouse end)
            const handleTouchDragEnd = (e) => {
                console.log('üèÅ Touch drop');
                
                // Remove global listeners
                document.removeEventListener('touchmove', handleTouchDragMove);
                document.removeEventListener('touchend', handleTouchDragEnd);
                
                // Use refs for immediate access
                if (currentDropZoneRef.current && draggedTaskRef.current) {
                    console.log('üíß Dropped on:', currentDropZoneRef.current.type);
                    
                    // Parse drop zone data
                    let dropData = {};
                    try {
                        dropData = JSON.parse(currentDropZoneRef.current.data);
                    } catch (e) {}
                    
                    // Handle the drop based on zone type
                    if (currentDropZoneRef.current.type === 'timeline-slot') {
                        updateTask(draggedTaskRef.current.id, { 
                            timeSlot: dropData.slot,
                            scheduledDate: dropData.date || selectedDate
                        });
                        showToast(`Scheduled at ${dropData.slot}`, true);
                    }
                    else if (currentDropZoneRef.current.type === 'calendar-date') {
                        updateTask(draggedTaskRef.current.id, { 
                            scheduledDate: dropData.date
                        });
                        showToast(`Moved to ${dropData.date}`, true);
                    }
                    else if (currentDropZoneRef.current.type === 'persona') {
                        updateTask(draggedTaskRef.current.id, { 
                            persona: dropData.persona
                        });
                        showToast(`Assigned to ${dropData.persona}`, true);
                    }
                    else if (currentDropZoneRef.current.type === 'project' || currentDropZoneRef.current.type === 'kanban-column') {
                        console.log('üìã Kanban drop data:', dropData);
                        console.log('üìã Task before update:', draggedTaskRef.current);
                        
                        if (dropData.status) {
                            updateTask(draggedTaskRef.current.id, { 
                                status: dropData.status,
                                project: dropData.project || dropData.projectId
                            });
                            console.log('‚úÖ Updated task with status:', dropData.status, 'project:', dropData.project);
                            showToast(`Status updated to ${dropData.status}`, true);
                        } else {
                            updateTask(draggedTaskRef.current.id, { 
                                project: dropData.project || dropData.projectId
                            });
                            showToast(`Moved to project`, true);
                        }
                    }
                    else if (currentDropZoneRef.current.type === 'reorder') {
                        // Handle list reordering
                        const draggedTaskId = draggedTaskRef.current.id;
                        const targetTaskId = dropData.targetTaskId;
                        const position = dropData.position;
                        
                        console.log('üîÑ REORDER: Starting', { draggedTaskId, targetTaskId, position });
                        
                        const visibleTasks = [...filteredTasks];
                        const draggedIndex = visibleTasks.findIndex(t => t.id === draggedTaskId);
                        const targetIndex = visibleTasks.findIndex(t => t.id === targetTaskId);
                        
                        console.log('üîÑ REORDER: Using current visual order, indices:', { draggedIndex, targetIndex });
                        
                        if (draggedIndex !== -1 && targetIndex !== -1) {
                            // Remove dragged task
                            const [draggedTask] = visibleTasks.splice(draggedIndex, 1);
                            
                            // Insert at new position
                            const insertIndex = position === 'before' ? targetIndex : targetIndex + 1;
                            const finalIndex = draggedIndex < targetIndex ? insertIndex - 1 : insertIndex;
                            visibleTasks.splice(finalIndex, 0, draggedTask);
                            
                            console.log('üîÑ REORDER: New order', visibleTasks.map(t => t.text.substring(0, 20)));
                            
                            // Assign sequential order to visible tasks only
                            const updatedTasks = tasks.map(task => {
                                const visibleIndex = visibleTasks.findIndex(t => t.id === task.id);
                                if (visibleIndex !== -1) {
                                    return { ...task, manualOrder: visibleIndex };
                                }
                                return task;
                            });
                            
                            setTasks(updatedTasks);
                            setIsManualOrder(true);
                            
                            // Save new order to Supabase
                            const tasksToSave = updatedTasks.filter(t => t.manualOrder !== null && t.manualOrder !== undefined);
                            
                            if (tasksToSave.length > 0 && user) {
                                console.log(`üíæ Saving ${tasksToSave.length} tasks with new order to Supabase`);
                                
                                // Block real-time updates during reorder save
                                isReorderingRef.current = true;
                                console.log('üîí Blocking real-time updates during reorder');
                                
                                // Clear any existing timeout
                                if (reorderTimeoutRef.current) {
                                    clearTimeout(reorderTimeoutRef.current);
                                }
                                
                                // Save all tasks in parallel for faster sync
                                if (tasksToSave.length > 0) {
                                    Promise.all(tasksToSave.map(task => saveTaskToSupabase(task)))
                                        .then(() => {
                                            console.log('‚úÖ Manual order saved to Supabase');
                                            // Unblock after 2 seconds (increased from 1s for safety)
                                            reorderTimeoutRef.current = setTimeout(() => {
                                                isReorderingRef.current = false;
                                                console.log('üîì Unblocked real-time updates');
                                            }, 2000);
                                        })
                                        .catch(err => {
                                            console.error('‚ùå Error saving manual order:', err);
                                            // Unblock even on error
                                            reorderTimeoutRef.current = setTimeout(() => {
                                                isReorderingRef.current = false;
                                                console.log('üîì Unblocked real-time updates (after error)');
                                            }, 2000);
                                        });
                                }
                            }
                            
                            showToast('Task reordered', true);
                        } else {
                            console.log('‚ùå REORDER: Invalid indices!');
                        }
                    }
                } else {
                    console.log('‚ùå No drop zone or task');
                }
                
                // Reset refs
                isDraggingRef.current = false;
                draggedTaskRef.current = null;
                currentDropZoneRef.current = null;
                
                // Reset state
                setIsDragging(false);
                setDraggedTask(null);
                setDragStartPos(null);
                setCurrentDropZone(null);
            };

            // Touch support for drag and drop
            const handleTouchStart = (e, item, type) => {
                const touch = e.touches[0];
                setTouchStartTime(Date.now());
                
                const timer = setTimeout(() => {
                    setDraggedItem({ item, type });
                    e.target.classList.add('long-press-active');
                    // Vibrate if supported
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 500);
                
                setLongPressTimer(timer);
            };

            const handleTouchEnd = (e) => {
                if (longPressTimer) clearTimeout(longPressTimer);
                e.target.classList.remove('long-press-active');
                
                if (draggedItem && dragOverZone) {
                    // Process drop
                    handleDrop(e, dragOverZone.zone, dragOverZone.data);
                }
                
                setDraggedItem(null);
                setDragOverZone(null);
            };

            // ====== TOAST NOTIFICATION ======
            const showToast = (message, showUndo = false) => {
                setToast({ message, showUndo });
            };

            const handleUndo = () => {
                if (undoData) {
                    if (undoData.action === 'deleteTask') {
                        setTasks(prev => [...prev, undoData.data]);
                        showToast('Task restored');
                    }
                    setUndoData(null);
                }
                setToast(null);
            };

            // ====== DATA IMPORT/EXPORT ======
            const exportData = () => {
                const data = {
                    version: '1.3',
                    tasks,
                    events,
                    personas,
                    projects,
                    customLists,
                    exportDate: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `life-ninja-backup-${formatDate(new Date())}.json`;
                a.click();
                showToast('Data exported successfully');
            };

            const importData = (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.tasks) setTasks(data.tasks);
                        if (data.events) setEvents(data.events);
                        if (data.personas) setPersonas(data.personas);
                        if (data.projects) setProjects(data.projects);
                        if (data.customLists) setCustomLists(data.customLists);
                        showToast('Data imported successfully');
                    } catch (error) {
                        showToast('Error importing data');
                        console.error(error);
                    }
                };
                reader.readAsText(file);
            };

            // Migration from old format
            const migrateOldData = () => {
                try {
                    const oldWins = JSON.parse(localStorage.getItem('ps_dailyWins') || '[]');
                    const oldTimeline = JSON.parse(localStorage.getItem('ps_timelineItems') || '[]');
                    
                    const migratedTasks = [...oldWins, ...oldTimeline].map(task => ({
                        ...task,
                        priority: task.priority || 'medium',
                        scheduledDate: task.scheduledDate || formatDate(new Date()),
                        tags: task.tags || [],
                        notes: task.notes || '',
                        estimatedDuration: task.estimatedDuration || null,
                        actualDuration: task.actualDuration || null,
                        archived: false,
                        recurringPattern: null
                    }));

                    setTasks(migratedTasks);
                    showToast(`Migrated ${migratedTasks.length} tasks from old format`);
                } catch (error) {
                    showToast('Error migrating old data');
                    console.error(error);
                }
            };

            // ====== BULK IMPORT ======
            const parseBulkImport = () => {
                const lines = bulkImportText.split('\n').filter(line => line.trim());
                const items = lines.map((line, idx) => ({
                    id: Date.now() + idx,
                    text: line.trim().replace(/^[+\-*‚Ä¢]\s*/, '')
                }));
                setImportedItems(items);
                setCurrentClassifyIndex(0);
                setCurrentView('classify');
            };

            const saveClassifiedItem = (classification) => {
                const item = importedItems[currentClassifyIndex];
                createTask({
                    text: item.text,
                    ...classification
                });

                if (currentClassifyIndex < importedItems.length - 1) {
                    setCurrentClassifyIndex(prev => prev + 1);
                } else {
                    setCurrentView('list');
                    setBulkImportText('');
                    setImportedItems([]);
                    setCurrentClassifyIndex(0);
                }
            };

            // ====== RENDER HELPERS ======
            const getIcon = (status) => {
                if (status === 'completed') return <CheckCircle className="text-green-600" size={20} />;
                if (status === 'in-progress') return <Play className="text-blue-600" size={20} />;
                return <Circle className="text-gray-400" size={20} />;
            };

            const getColor = (status) => {
                if (status === 'completed') return 'bg-green-50 border-green-400';
                if (status === 'in-progress') return 'bg-blue-50 border-blue-400';
                return 'bg-gray-50 border-gray-300';
            };

            const getPriorityColor = (priority) => {
                if (priority === 'urgent') return 'bg-red-100 text-red-700';
                if (priority === 'high') return 'bg-orange-100 text-orange-700';
                if (priority === 'medium') return 'bg-yellow-100 text-yellow-700';
                if (priority === 'low') return 'bg-blue-100 text-blue-700';
                if (priority === 'non-priority') return 'bg-gray-100 text-gray-500'; // V2.7.0: Rating 0
                return 'bg-gray-100 text-gray-700';
            };

            // ====== TASK CARD COMPONENT ======
            // V2.6.0-OPTIMIZE: Memoized to prevent unnecessary re-renders
            const TaskCard = React.memo(({ task, location = 'list', showDate = false }) => {
                const [newSubtaskText, setNewSubtaskText] = useState('');
                // Bug 2 Complete Fix: Local state for all text inputs to prevent scroll/focus loss
                const [localText, setLocalText] = useState(task.text || '');
                const [localDuration, setLocalDuration] = useState(task.estimatedDuration || '');
                const [localTags, setLocalTags] = useState((task.tags || []).join(', '));
                const [localNotes, setLocalNotes] = useState(task.notes || '');
                const [localTimeSlot, setLocalTimeSlot] = useState(task.timeSlot || ''); // V1.3.2: Fix time picker
                const isExpanded = expandedTasks[task.id];
                const isEditing = editingTask === task.id;
                const points = calculateTaskScore(task);
                
                // V2.6.3-QUICKEDIT: Long-press detection for mobile Quick Edit
                const longPressTimer = useRef(null);
                const [isLongPressing, setIsLongPressing] = useState(false);
                
                // V2.7.0: Click detection for double-click
                const clickTimer = useRef(null);
                const clickCount = useRef(0);
                
                // Update local state when task changes (e.g., from external update)
                useEffect(() => {
                    setLocalText(task.text || '');
                    setLocalDuration(task.estimatedDuration || '');
                    setLocalTags((task.tags || []).join(', '));
                    setLocalNotes(task.notes || '');
                    setLocalTimeSlot(task.timeSlot || ''); // V1.3.2: Update time slot
                }, [task.id]);
                
                const handleTaskUpdate = (updates) => {
                    if (location === 'list-view' && task.listId) {
                        updateListTask(task.listId, task.id, updates);
                    } else {
                        updateTask(task.id, updates);
                    }
                };
                
                // V2.6.3-QUICKEDIT: Open Quick Edit modal
                const openQuickEdit = () => {
                    console.log('‚ú® Opening Quick Edit for:', task.text);
                    setQuickEditTask({...task});
                    setShowQuickEdit(true); // V2.7.0 FIX: Actually show the modal!
                };
                
                // V2.6.3-QUICKEDIT: Double-click handler (PC)
                const handleDoubleClick = (e) => {
                    e.stopPropagation();
                    openQuickEdit();
                };
                
                // V2.6.3-QUICKEDIT: Long-press handlers (Mobile)
                const handleTouchStart = (e) => {
                    // V2.7.0: Don't preventDefault - it breaks long-press detection!
                    // Text selection is prevented via CSS: userSelect: 'none'
                    longPressTimer.current = setTimeout(() => {
                        setIsLongPressing(true);
                        if (navigator.vibrate) navigator.vibrate(50); // Haptic feedback
                        openQuickEdit();
                    }, 500); // 500ms long-press
                };
                
                const handleTouchEnd = () => {
                    if (longPressTimer.current) {
                        clearTimeout(longPressTimer.current);
                    }
                    setIsLongPressing(false);
                };
                
                const handleTouchMove = () => {
                    // Cancel long-press if user moves finger
                    if (longPressTimer.current) {
                        clearTimeout(longPressTimer.current);
                    }
                };

                return (
                    <div
                        key={task.id}
                        className={`task-card border-2 rounded-lg mb-2 ${getColor(task.status)} ${isDragging && draggedTask?.id === task.id ? 'opacity-40' : ''}`}
                        style={{ 
                            cursor: !isEditing ? 'grab' : 'default',
                            minWidth: location === 'kanban' ? '220px' : undefined,
                            wordWrap: 'break-word',
                            overflowWrap: 'break-word'
                        }}
                    >
                        <div className="p-3">
                            <div className="flex items-start gap-2">
                                {!isEditing && (
                                    <>
                                        <div 
                                            className="text-gray-400 mt-1 drag-handle" 
                                            title="Click and drag to move task" 
                                            style={{ cursor: 'grab' }}
                                            draggable="false"
                                            onMouseDown={(e) => {
                                                e.stopPropagation();
                                                handleMouseDragStart(e, {...task, source: location === 'list-view' ? 'list' : 'main', sourceListId: location === 'list-view' ? task.listId : null});
                                            }}
                                            onTouchStart={(e) => {
                                                e.stopPropagation();
                                                handleTouchDragStart(e, {...task, source: location === 'list-view' ? 'list' : 'main', sourceListId: location === 'list-view' ? task.listId : null});
                                            }}
                                        >
                                            <GripVertical size={16} />
                                        </div>
                                        {/* V2.6.0-BUTTONS: Up/Down reorder buttons */}
                                        <div className="flex flex-col gap-0.5">
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    moveTaskUp(task.id);
                                                }}
                                                onTouchEnd={(e) => {
                                                    e.preventDefault();
                                                    e.stopPropagation();
                                                    moveTaskUp(task.id);
                                                }}
                                                className="text-gray-400 hover:text-blue-600 transition-colors p-0.5 rounded hover:bg-blue-50"
                                                title="Move task up"
                                                draggable="false"
                                            >
                                                <ChevronUp size={14} />
                                            </button>
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    moveTaskDown(task.id);
                                                }}
                                                onTouchEnd={(e) => {
                                                    e.preventDefault();
                                                    e.stopPropagation();
                                                    moveTaskDown(task.id);
                                                }}
                                                className="text-gray-400 hover:text-blue-600 transition-colors p-0.5 rounded hover:bg-blue-50"
                                                title="Move task down"
                                                draggable="false"
                                            >
                                                <ChevronDown size={14} />
                                            </button>
                                        </div>
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                setTaskToMove(task);
                                                setShowTaskMover(true);
                                            }}
                                            className="text-blue-500 hover:text-blue-700 mt-1"
                                            title="Move task to date/time"
                                            draggable="false"
                                        >
                                            <ArrowRight size={16} />
                                        </button>
                                    </>
                                )}
                                <div
                                    onClick={() => {
                                        if (location === 'list-view' && task.listId) {
                                            handleToggleListTaskStatus(task.id, task.listId);
                                        } else {
                                            toggleTaskStatus(task.id);
                                        }
                                    }}
                                    className="cursor-pointer mt-1"
                                >
                                    {getIcon(task.status)}
                                </div>
                                
                                {/* V2.11.6: Trophy icon for completed tasks (Completion Zone) */}
                                {task.status === 'completed' && !task.inCompletionZone && (
                                    <div
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            toggleCompletionZone(task.id);
                                        }}
                                        className="cursor-pointer mt-1 hover:scale-110 transition-transform"
                                        title="Move to Completion Zone (keeps points, hides from views)"
                                    >
                                        <Trophy size={18} className="text-yellow-600 hover:text-yellow-700" />
                                    </div>
                                )}
                                
                                <div 
                                    className="flex-1" 
                                    style={{ minWidth: '150px', wordWrap: 'break-word', overflowWrap: 'break-word', cursor: 'pointer', userSelect: 'none' }}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        clickCount.current += 1;
                                        console.log('üëÜ Click detected, count:', clickCount.current);
                                        
                                        if (clickCount.current === 1) {
                                            // First click - start timer
                                            clickTimer.current = setTimeout(() => {
                                                // Timer expired - this was a single click
                                                if (clickCount.current === 1) {
                                                    console.log('üìñ Single-click: Expanding task');
                                                    setExpandedTasks(p => ({ ...p, [task.id]: !p[task.id] }));
                                                }
                                                clickCount.current = 0;
                                            }, 160); // 160ms delay (reduced for snappier feel)
                                        } else if (clickCount.current === 2) {
                                            // Second click - this is a double-click
                                            console.log('‚ö° Double-click detected: Opening Quick Edit');
                                            clearTimeout(clickTimer.current);
                                            clickCount.current = 0;
                                            openQuickEdit();
                                        } else {
                                            // More than 2 clicks - reset
                                            console.log('üîÑ Multiple clicks, resetting');
                                            clearTimeout(clickTimer.current);
                                            clickCount.current = 0;
                                        }
                                    }}
                                    onTouchStart={handleTouchStart}
                                    onTouchEnd={handleTouchEnd}
                                    onTouchMove={handleTouchMove}
                                >
                                    <p className="text-sm font-medium break-words" style={{ wordBreak: 'break-word' }}>{task.text}</p>
                                    
                                    {/* Tags and metadata */}
                                    <div className="flex flex-wrap gap-1 mt-2 text-xs">
                                        <span className={`px-2 py-0.5 rounded ${getPriorityColor(task.priority)}`}>
                                            {task.priority} {task.priority_rating !== undefined && `(${task.priority_rating})`}
                                        </span>
                                        <span className="bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded">
                                            {task.persona}
                                        </span>
                                        {task.project && (
                                            <span className="bg-purple-100 text-purple-700 px-2 py-0.5 rounded">
                                                {task.project}
                                            </span>
                                        )}
                                        <span className="bg-green-100 text-green-700 px-2 py-0.5 rounded font-semibold">
                                            {points}pts
                                        </span>
                                        {task.dueLabel && (
                                            <span className="bg-orange-100 text-orange-700 px-2 py-0.5 rounded">
                                                üìÖ {task.dueLabel}
                                            </span>
                                        )}
                                        {task.timeSlot && (
                                            <span className="bg-blue-100 text-blue-700 px-2 py-0.5 rounded">
                                                üïí {task.timeSlot}
                                            </span>
                                        )}
                                        {task.estimatedDuration && (
                                            <span className="bg-cyan-100 text-cyan-700 px-2 py-0.5 rounded">
                                                ‚è±Ô∏è {task.estimatedDuration}min
                                            </span>
                                        )}
                                        {task.recurringPattern && (
                                            <span className="bg-pink-100 text-pink-700 px-2 py-0.5 rounded">
                                                üîÑ {task.recurringPattern}
                                            </span>
                                        )}
                                        {task.tags?.map(tag => (
                                            <span key={tag} className="bg-gray-100 text-gray-700 px-2 py-0.5 rounded">
                                                #{tag}
                                            </span>
                                        ))}
                                        {task.subtasks?.length > 0 && (
                                            <span className="bg-blue-100 text-blue-700 px-2 py-0.5 rounded">
                                                ‚úì {task.subtasks.filter(st => st.status === 'completed').length}/{task.subtasks.length}
                                            </span>
                                        )}
                                    </div>

                                    {/* Date info */}
                                    {showDate && task.scheduledDate && (
                                        <div className="text-xs text-gray-500 mt-1">
                                            üìÖ {formatDateDisplay(task.scheduledDate)}
                                        </div>
                                    )}

                                    {/* Notes preview */}
                                    {task.notes && !isExpanded && (
                                        <div className="text-xs text-gray-600 mt-1 italic truncate">
                                            {task.notes}
                                        </div>
                                    )}

                                    {/* Timestamps */}
                                    <div className="text-xs text-gray-400 mt-1">
                                        {task.createdAt && `Created: ${formatDateDisplay(task.createdAt)}`}
                                        {task.completedAt && ` ‚Ä¢ Completed: ${formatDateDisplay(task.completedAt)}`}
                                    </div>
                                </div>

                                {/* Action buttons */}
                                <div className="flex gap-1 flex-shrink-0">
                                    <button
                                        onClick={() => setEditingTask(isEditing ? null : task.id)}
                                        className="p-1 hover:bg-blue-100 rounded text-blue-600"
                                        title="Edit task"
                                    >
                                        <Settings size={16} />
                                    </button>
                                    {/* V2.6.3-BUTTON: Quick Edit button */}
                                    <button
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            console.log('‚ö° Quick Edit button clicked for:', task.text);
                                            setQuickEditTask({...task});
                                            setShowQuickEdit(true);
                                        }}
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            console.log('‚ö° Quick Edit button touched for:', task.text);
                                            setQuickEditTask({...task});
                                            setShowQuickEdit(true);
                                        }}
                                        className="p-1 hover:bg-purple-100 rounded text-purple-600"
                                        title="Quick Edit (fast)"
                                    >
                                        <svg 
                                            width="16" 
                                            height="16" 
                                            viewBox="0 0 24 24" 
                                            fill="none" 
                                            stroke="currentColor" 
                                            strokeWidth="2" 
                                            strokeLinecap="round" 
                                            strokeLinejoin="round"
                                        >
                                            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                                        </svg>
                                    </button>
                                    <button
                                        onClick={() => setExpandedTasks(p => ({ ...p, [task.id]: !p[task.id] }))}
                                        className="p-1 hover:bg-gray-200 rounded"
                                        title="Expand/Collapse"
                                    >
                                        {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
                                    </button>
                                    <button
                                        onClick={() => duplicateTask(task.id)}
                                        className="p-1 hover:bg-green-100 rounded text-green-600"
                                        title="Duplicate"
                                    >
                                        <Copy size={16} />
                                    </button>
                                    <button
                                        onClick={() => task.archived ? restoreTask(task.id) : archiveTask(task.id)}
                                        className="p-1 hover:bg-yellow-100 rounded text-yellow-600"
                                        title={task.archived ? "Restore" : "Archive"}
                                    >
                                        <Archive size={16} />
                                    </button>
                                    <button
                                        onClick={() => {
                                            if (location === 'list-view' && task.listId) {
                                                handleDeleteFromList(task.id, task.listId);
                                            } else {
                                                deleteTask(task.id);
                                            }
                                        }}
                                        className="p-1 hover:bg-red-100 rounded text-red-600"
                                        title="Delete"
                                    >
                                        <Trash2 size={16} />
                                    </button>
                                </div>
                            </div>

                            {/* Edit form */}
                            {isEditing && (
                                <div className="mt-3 p-3 bg-white rounded border space-y-2">
                                    <div>
                                        <label className="text-xs font-semibold">Task Text</label>
                                        <input
                                            type="text"
                                            value={localText}
                                            onChange={(e) => setLocalText(e.target.value)}
                                            onBlur={(e) => handleTaskUpdate({ text: e.target.value })}
                                            className="w-full px-2 py-1 border rounded text-sm"
                                        />
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="text-xs font-semibold">Priority</label>
                                            <select
                                                value={task.priority}
                                                onChange={(e) => {
                                                    const newPriority = e.target.value;
                                                    // V2.7.0: Auto-update rating when priority changes
                                                    const ratingMap = {
                                                        'non-priority': 0,
                                                        'low': 2,
                                                        'medium': 5,
                                                        'high': 8,  // FIXED: Changed from 7 to 8
                                                        'urgent': 10
                                                    };
                                                    handleTaskUpdate({ 
                                                        priority: newPriority,
                                                        priority_rating: ratingMap[newPriority] !== undefined ? ratingMap[newPriority] : 5
                                                    });
                                                }}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            >
                                                <option value="non-priority">Non-priority</option>
                                                <option value="low">Low</option>
                                                <option value="medium">Medium</option>
                                                <option value="high">High</option>
                                                <option value="urgent">Urgent</option>
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="text-xs font-semibold">Rating (0-10)</label>
                                            <select
                                                value={task.priority_rating !== undefined ? task.priority_rating : 5}
                                                onChange={(e) => {
                                                    const rating = parseInt(e.target.value);
                                                    // V2.7.0: Auto-update category when rating changes
                                                    let newPriority = 'medium';
                                                    if (rating === 0) newPriority = 'non-priority';
                                                    else if (rating <= 2) newPriority = 'low';
                                                    else if (rating <= 5) newPriority = 'medium';
                                                    else if (rating <= 8) newPriority = 'high';
                                                    else newPriority = 'urgent';
                                                    
                                                    handleTaskUpdate({ 
                                                        priority_rating: rating,
                                                        priority: newPriority
                                                    });
                                                }}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            >
                                                <option value="0">0 - Non-priority</option>
                                                <option value="1">1 - Low</option>
                                                <option value="2">2 - Low</option>
                                                <option value="3">3 - Medium</option>
                                                <option value="4">4 - Medium</option>
                                                <option value="5">5 - Medium</option>
                                                <option value="6">6 - High</option>
                                                <option value="7">7 - High</option>
                                                <option value="8">8 - High</option>
                                                <option value="9">9 - Urgent</option>
                                                <option value="10">10 - Urgent</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="text-xs font-semibold">Type</label>
                                            <select
                                                value={task.taskType}
                                                onChange={(e) => handleTaskUpdate({ taskType: e.target.value })}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            >
                                                <option value="growth">Growth (5pts)</option>
                                                <option value="consistency">Consistency (3pts)</option>
                                                <option value="maintenance">Maintenance (2pts)</option>
                                            </select>
                                        </div>
                                    </div>

                                    {/* V2.6.3-QUICKEDIT: Status dropdown */}
                                    <div>
                                        <label className="text-xs font-semibold">Status</label>
                                        <select
                                            value={task.status}
                                            onChange={(e) => handleTaskUpdate({ status: e.target.value })}
                                            className="w-full px-2 py-1 border rounded text-xs"
                                        >
                                            {(() => {
                                                // Get statuses for current project
                                                const currentProject = task.project 
                                                    ? projects.find(p => p.name === task.project)
                                                    : projects.find(p => p.isNoProject);
                                                const availableStatuses = currentProject?.statuses || ['not-started', 'in-progress', 'completed'];
                                                
                                                // V2.6.3-FIX: Inline status label formatter
                                                const formatStatus = (status) => {
                                                    const labels = {
                                                        'not-started': 'Not Started',
                                                        'in-progress': 'In Progress',
                                                        'completed': 'Completed',
                                                        'to-do': 'To Do',
                                                        'awaiting-discussion': 'Awaiting Discussion / Inputs',
                                                        'delayed-parked': 'Delayed or Parked',
                                                        'done': 'Done'
                                                    };
                                                    return labels[status] || status.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                                                };
                                                
                                                return availableStatuses.map(status => (
                                                    <option key={status} value={status}>
                                                        {formatStatus(status)}
                                                    </option>
                                                ));
                                            })()}
                                        </select>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="text-xs font-semibold">Persona</label>
                                            <select
                                                value={task.persona}
                                                onChange={(e) => handleTaskUpdate({ persona: e.target.value })}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            >
                                                {personas.map(p => (
                                                    <option key={p} value={p}>{p}</option>
                                                ))}
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="text-xs font-semibold">Project</label>
                                            <select
                                                value={task.project || ''}
                                                onChange={(e) => {
                                                    const newProject = e.target.value || null;
                                                    
                                                    // V2.6.3-FIX: Get new project's statuses
                                                    const projectStatuses = newProject 
                                                        ? (projects.find(p => p.name === newProject)?.statuses || ['not-started', 'in-progress', 'completed'])
                                                        : (projects.find(p => p.isNoProject)?.statuses || ['not-started', 'in-progress', 'completed']);
                                                    
                                                    // V2.6.3-FIX: If current status not valid for new project, reset to first status
                                                    const newStatus = projectStatuses.includes(task.status) 
                                                        ? task.status 
                                                        : projectStatuses[0];
                                                    
                                                    // Update both project and status (if needed)
                                                    handleTaskUpdate({ 
                                                        project: newProject,
                                                        status: newStatus
                                                    });
                                                }}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            >
                                                <option value="">No Project</option>
                                                {projects.filter(p => !p.isNoProject).map(p => (
                                                    <option key={p.id} value={p.name}>{p.name}</option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="text-xs font-semibold">Scheduled Date</label>
                                            <input
                                                type="date"
                                                value={task.scheduledDate || ''}
                                                onChange={(e) => handleTaskUpdate({ scheduledDate: e.target.value })}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="text-xs font-semibold">Due Date</label>
                                            <input
                                                type="date"
                                                value={task.dueDate || ''}
                                                onChange={(e) => handleTaskUpdate({ dueDate: e.target.value, dueLabel: null })}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            />
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="text-xs font-semibold">Time Slot</label>
                                            <input
                                                type="time"
                                                value={localTimeSlot}
                                                onChange={(e) => setLocalTimeSlot(e.target.value)}
                                                onBlur={(e) => handleTaskUpdate({ timeSlot: e.target.value || null })}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="text-xs font-semibold">Duration (min)</label>
                                            <input
                                                type="number"
                                                value={localDuration}
                                                onChange={(e) => setLocalDuration(e.target.value)}
                                                onBlur={(e) => handleTaskUpdate({ estimatedDuration: parseInt(e.target.value) || null })}
                                                className="w-full px-2 py-1 border rounded text-xs"
                                            />
                                        </div>
                                    </div>

                                    <div>
                                        <label className="text-xs font-semibold">Recurring Pattern</label>
                                        <select
                                            value={task.recurringPattern || ''}
                                            onChange={(e) => handleTaskUpdate({ recurringPattern: e.target.value || null })}
                                            className="w-full px-2 py-1 border rounded text-xs"
                                        >
                                            <option value="">None</option>
                                            <option value="daily">Daily</option>
                                            <option value="weekly">Weekly</option>
                                            <option value="monthly">Monthly</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="text-xs font-semibold">Tags (comma-separated)</label>
                                        <input
                                            type="text"
                                            value={localTags}
                                            onChange={(e) => setLocalTags(e.target.value)}
                                            onBlur={(e) => handleTaskUpdate({ 
                                                tags: e.target.value.split(',').map(t => t.trim()).filter(Boolean) 
                                            })}
                                            className="w-full px-2 py-1 border rounded text-xs"
                                            placeholder="work, important, urgent"
                                        />
                                    </div>

                                    <div>
                                        <label className="text-xs font-semibold">Notes</label>
                                        <textarea
                                            value={localNotes}
                                            onChange={(e) => setLocalNotes(e.target.value)}
                                            onBlur={(e) => handleTaskUpdate({ notes: e.target.value })}
                                            className="w-full px-2 py-1 border rounded text-xs"
                                            rows="2"
                                            placeholder="Additional notes..."
                                        />
                                    </div>

                                    <label className="flex items-center gap-2 text-xs">
                                        <input
                                            type="checkbox"
                                            checked={task.isOldTask || false}
                                            onChange={(e) => handleTaskUpdate({ isOldTask: e.target.checked })}
                                        />
                                        Old Task (2pts clearance bonus)
                                    </label>

                                    <button
                                        onClick={() => setEditingTask(null)}
                                        className="w-full px-3 py-2 bg-indigo-600 text-white rounded font-semibold hover:bg-indigo-700"
                                    >
                                        Done Editing
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* Subtasks section */}
                        {isExpanded && (
                            <div className="px-3 pb-3 bg-gray-50">
                                {/* Full notes if present */}
                                {task.notes && (
                                    <div className="mb-3 p-2 bg-white rounded border">
                                        <p className="text-xs font-semibold mb-1">Notes:</p>
                                        <p className="text-xs text-gray-700 whitespace-pre-wrap">{task.notes}</p>
                                    </div>
                                )}

                                <div className="ml-7 space-y-2">
                                    {(task.subtasks || []).map(subtask => {
                                        const stPoints = calculateTaskScore(subtask);
                                        const isEditingSt = editingSubtask === subtask.id;
                                        
                                        return (
                                            <div
                                                key={subtask.id}
                                                className={`p-2 rounded border ${getColor(subtask.status)}`}
                                                draggable={!isEditingSt}
                                                onDragStart={(e) => handleDragStart(e, subtask, 'subtask')}
                                                onDragEnd={handleDragEnd}
                                            >
                                                <div className="flex items-start gap-2">
                                                    <div
                                                        onClick={() => toggleSubtaskStatus(task.id, subtask.id)}
                                                        className="cursor-pointer"
                                                    >
                                                        {getIcon(subtask.status)}
                                                    </div>
                                                    <div className="flex-1">
                                                        <p className="text-xs">{subtask.text}</p>
                                                        <div className="flex flex-wrap gap-1 mt-1 text-xs">
                                                            <span className={`px-1 py-0.5 rounded ${
                                                                subtask.taskType === 'growth' ? 'bg-green-100 text-green-700' :
                                                                subtask.taskType === 'consistency' ? 'bg-blue-100 text-blue-700' :
                                                                'bg-yellow-100 text-yellow-700'
                                                            }`}>
                                                                {stPoints}pts
                                                            </span>
                                                            {subtask.dueLabel && (
                                                                <span className="bg-orange-100 text-orange-700 px-1 py-0.5 rounded">
                                                                    {subtask.dueLabel}
                                                                </span>
                                                            )}
                                                            {subtask.isOldTask && (
                                                                <span className="bg-gray-200 px-1 py-0.5 rounded">Old</span>
                                                            )}
                                                        </div>

                                                        {/* Subtask edit form with local state (Option C) */}
                                                        {isEditingSt && (() => {
                                                            // Local state hook - prevents React rerender bug
                                                            const [localText, setLocalText] = React.useState(subtask.text);
                                                            const [localNotes, setLocalNotes] = React.useState(subtask.notes || '');
                                                            
                                                            // Save function
                                                            const saveChanges = () => {
                                                                updateSubtask(task.id, subtask.id, { 
                                                                    text: localText,
                                                                    notes: localNotes 
                                                                });
                                                            };
                                                            
                                                            return (
                                                                <div className="mt-2 p-3 bg-white rounded border space-y-2">
                                                                    <div>
                                                                        <label className="text-xs font-semibold block mb-1">Text</label>
                                                                        <input
                                                                            type="text"
                                                                            value={localText}
                                                                            onChange={(e) => setLocalText(e.target.value)}
                                                                            onBlur={saveChanges}
                                                                            className="w-full px-2 py-1 border rounded text-xs"
                                                                        />
                                                                    </div>
                                                                    
                                                                    <div className="grid grid-cols-2 gap-2">
                                                                        <div>
                                                                            <label className="text-xs font-semibold block mb-1">Priority</label>
                                                                            <select
                                                                                value={subtask.priority || task.priority}
                                                                                onChange={(e) => {
                                                                                    const newPriority = e.target.value;
                                                                                    // V2.7.0: Auto-update rating when priority changes
                                                                                    const ratingMap = {
                                                                                        'non-priority': 0,
                                                                                        'low': 2,
                                                                                        'medium': 5,
                                                                                        'high': 8,
                                                                                        'urgent': 10
                                                                                    };
                                                                                    updateSubtask(task.id, subtask.id, { 
                                                                                        priority: newPriority,
                                                                                        priority_rating: ratingMap[newPriority] !== undefined ? ratingMap[newPriority] : 5
                                                                                    });
                                                                                }}
                                                                                className="w-full px-2 py-1 border rounded text-xs"
                                                                            >
                                                                                <option value="non-priority">Non-priority</option>
                                                                                <option value="low">Low</option>
                                                                                <option value="medium">Medium</option>
                                                                                <option value="high">High</option>
                                                                                <option value="urgent">Urgent</option>
                                                                            </select>
                                                                        </div>
                                                                        
                                                                        <div>
                                                                            <label className="text-xs font-semibold block mb-1">Rating (0-10)</label>
                                                                            <select
                                                                                value={subtask.priority_rating !== undefined ? subtask.priority_rating : (task.priority_rating || 5)}
                                                                                onChange={(e) => {
                                                                                    const rating = parseInt(e.target.value);
                                                                                    // V2.7.0: Auto-update category when rating changes
                                                                                    let newPriority = 'medium';
                                                                                    if (rating === 0) newPriority = 'non-priority';
                                                                                    else if (rating <= 2) newPriority = 'low';
                                                                                    else if (rating <= 5) newPriority = 'medium';
                                                                                    else if (rating <= 8) newPriority = 'high';
                                                                                    else newPriority = 'urgent';
                                                                                    
                                                                                    updateSubtask(task.id, subtask.id, { 
                                                                                        priority_rating: rating,
                                                                                        priority: newPriority
                                                                                    });
                                                                                }}
                                                                                className="w-full px-2 py-1 border rounded text-xs"
                                                                            >
                                                                                <option value="0">0 - Non-priority</option>
                                                                                <option value="1">1 - Low</option>
                                                                                <option value="2">2 - Low</option>
                                                                                <option value="3">3 - Medium</option>
                                                                                <option value="4">4 - Medium</option>
                                                                                <option value="5">5 - Medium</option>
                                                                                <option value="6">6 - High</option>
                                                                                <option value="7">7 - High</option>
                                                                                <option value="8">8 - High</option>
                                                                                <option value="9">9 - Urgent</option>
                                                                                <option value="10">10 - Urgent</option>
                                                                            </select>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div className="grid grid-cols-2 gap-2">
                                                                        <div>
                                                                            <label className="text-xs font-semibold block mb-1">Type</label>
                                                                            <select
                                                                                value={subtask.taskType}
                                                                                onChange={(e) => updateSubtask(task.id, subtask.id, { taskType: e.target.value })}
                                                                                className="w-full px-2 py-1 border rounded text-xs"
                                                                            >
                                                                                <option value="growth">Growth</option>
                                                                                <option value="consistency">Consistency</option>
                                                                                <option value="maintenance">Maintenance</option>
                                                                            </select>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div>
                                                                        <label className="text-xs font-semibold block mb-1">Persona</label>
                                                                        <select
                                                                            value={subtask.persona || task.persona}
                                                                            onChange={(e) => updateSubtask(task.id, subtask.id, { persona: e.target.value })}
                                                                            className="w-full px-2 py-1 border rounded text-xs"
                                                                        >
                                                                            {personas.map(p => <option key={p} value={p}>{p}</option>)}
                                                                        </select>
                                                                    </div>
                                                                    
                                                                    <div className="grid grid-cols-3 gap-2">
                                                                        <div>
                                                                            <label className="text-xs font-semibold block mb-1">Duration (min)</label>
                                                                            <input
                                                                                type="number"
                                                                                value={subtask.estimatedDuration || 30}
                                                                                onChange={(e) => updateSubtask(task.id, subtask.id, { estimatedDuration: parseInt(e.target.value) || 30 })}
                                                                                className="w-full px-2 py-1 border rounded text-xs"
                                                                                min="5"
                                                                                step="5"
                                                                            />
                                                                        </div>
                                                                        
                                                                        <div>
                                                                            <label className="text-xs font-semibold block mb-1">Scheduled</label>
                                                                            <input
                                                                                type="date"
                                                                                value={subtask.scheduledDate || ''}
                                                                                onChange={(e) => updateSubtask(task.id, subtask.id, { scheduledDate: e.target.value })}
                                                                                className="w-full px-2 py-1 border rounded text-xs"
                                                                            />
                                                                        </div>
                                                                        
                                                                        <div>
                                                                            <label className="text-xs font-semibold block mb-1">Due Date</label>
                                                                            <input
                                                                                type="date"
                                                                                value={subtask.dueDate || ''}
                                                                                onChange={(e) => updateSubtask(task.id, subtask.id, { dueDate: e.target.value })}
                                                                                className="w-full px-2 py-1 border rounded text-xs"
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div>
                                                                        <label className="text-xs font-semibold block mb-1">Time Slot</label>
                                                                        <select
                                                                            value={subtask.timeSlot || ''}
                                                                            onChange={(e) => updateSubtask(task.id, subtask.id, { timeSlot: e.target.value })}
                                                                            className="w-full px-2 py-1 border rounded text-xs"
                                                                        >
                                                                            <option value="">No time</option>
                                                                            {timeSlotsDisplay.map(slot => (
                                                                                <option key={slot.value} value={slot.value}>{slot.label}</option>
                                                                            ))}
                                                                        </select>
                                                                    </div>
                                                                    
                                                                    <div>
                                                                        <label className="text-xs font-semibold block mb-1">Notes</label>
                                                                        <textarea
                                                                            value={localNotes}
                                                                            onChange={(e) => setLocalNotes(e.target.value)}
                                                                            onBlur={saveChanges}
                                                                            className="w-full px-2 py-1 border rounded text-xs"
                                                                            rows="2"
                                                                            placeholder="Add notes..."
                                                                        />
                                                                    </div>
                                                                    
                                                                    <label className="flex items-center gap-1 text-xs">
                                                                    <input
                                                                        type="checkbox"
                                                                        checked={subtask.isOldTask || false}
                                                                        onChange={(e) => updateSubtask(task.id, subtask.id, { isOldTask: e.target.checked })}
                                                                    />
                                                                    Old Task (2pts)
                                                                </label>
                                                                
                                                                <div className="flex gap-2">
                                                                    <button
                                                                        onClick={() => setEditingSubtask(null)}
                                                                        className="flex-1 px-2 py-1 bg-indigo-600 text-white rounded text-xs hover:bg-indigo-700"
                                                                    >
                                                                        Done
                                                                    </button>
                                                                    <button
                                                                        onClick={() => {
                                                                            updateSubtask(task.id, subtask.id, {
                                                                                priority: task.priority,
                                                                                taskType: task.taskType,
                                                                                persona: task.persona,
                                                                                timeSlot: null,
                                                                                notes: ''
                                                                            });
                                                                        }}
                                                                        className="px-2 py-1 bg-gray-200 text-gray-700 rounded text-xs hover:bg-gray-300"
                                                                        title="Reset to parent values"
                                                                    >
                                                                        Reset
                                                                    </button>
                                                                </div>
                                                            </div>
                                                            );
                                                        })()}
                                                    </div>
                                                    <div className="flex gap-1">
                                                        <button
                                                            onClick={() => setEditingSubtask(isEditingSt ? null : subtask.id)}
                                                            className="p-1 hover:bg-blue-100 rounded text-blue-600"
                                                        >
                                                            <Edit2 size={12} />
                                                        </button>
                                                        <button
                                                            onClick={() => deleteSubtask(task.id, subtask.id)}
                                                            className="p-1 hover:bg-red-100 rounded text-red-600"
                                                        >
                                                            <X size={12} />
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}

                                    {/* Add subtask input */}
                                    <div className="flex gap-2 mt-2">
                                        <input
                                            type="text"
                                            placeholder="Add subtask..."
                                            value={newSubtaskText}
                                            onChange={(e) => setNewSubtaskText(e.target.value)}
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter' && newSubtaskText.trim()) {
                                                    addSubtask(task.id, newSubtaskText);
                                                    setNewSubtaskText('');
                                                }
                                            }}
                                            className="flex-1 px-2 py-1 border rounded text-xs"
                                        />
                                        <button
                                            onClick={() => {
                                                if (newSubtaskText.trim()) {
                                                    addSubtask(task.id, newSubtaskText);
                                                    setNewSubtaskText('');
                                                }
                                            }}
                                            className="px-2 py-1 bg-indigo-600 text-white rounded text-xs"
                                        >
                                            <Plus size={14} />
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }, (prevProps, nextProps) => {
                // V2.6.0-OPTIMIZE: Only re-render if task data actually changed
                // This prevents "screen shaking" from rapid real-time updates
                const prev = prevProps.task;
                const next = nextProps.task;
                
                return (
                    prev.id === next.id &&
                    prev.text === next.text &&
                    prev.status === next.status &&
                    prev.dueDate === next.dueDate &&
                    prev.scheduledDate === next.scheduledDate &&
                    prev.timeSlot === next.timeSlot &&
                    prev.estimatedDuration === next.estimatedDuration &&
                    prev.priority === next.priority &&
                    prev.persona === next.persona &&
                    prev.project === next.project &&
                    prev.notes === next.notes &&
                    prev.archived === next.archived &&
                    prev.manualOrder === next.manualOrder &&
                    JSON.stringify(prev.tags) === JSON.stringify(next.tags) &&
                    JSON.stringify(prev.subtasks) === JSON.stringify(next.subtasks) &&
                    prevProps.location === nextProps.location &&
                    prevProps.showDate === nextProps.showDate
                );
            });

            // V1.3: EventCard component
            const EventCard = ({ event, location = 'list' }) => {
                const [expanded, setExpanded] = useState(false);
                
                return (
                    <div
                        className="event-card border-2 rounded-lg mb-2 p-3"
                        style={{
                            borderColor: event.color || '#10b981',
                            background: `linear-gradient(135deg, ${event.color || '#10b981'}15 0%, ${event.color || '#10b981'}05 100%)`
                        }}
                    >
                        <div className="flex items-start justify-between">
                            <div className="flex-1">
                                <div className="flex items-center gap-2 mb-1">
                                    <span className="text-xs font-semibold px-2 py-0.5 rounded" style={{ backgroundColor: `${event.color || '#10b981'}20`, color: event.color || '#10b981' }}>
                                        EVENT
                                    </span>
                                    <span className="font-semibold">{event.text}</span>
                                </div>
                                <div className="text-sm text-gray-600 space-y-0.5">
                                    <div>‚è∞ {event.startTime} - {event.endTime}</div>
                                    {event.persona && <div>üë§ {event.persona}</div>}
                                    {event.project && <div>üìÅ {event.project}</div>}
                                    {event.priority && (
                                        <div>
                                            üéØ Priority: <span className={`font-semibold ${
                                                event.priority === 'urgent' ? 'text-red-600' :
                                                event.priority === 'high' ? 'text-orange-600' :
                                                event.priority === 'low' ? 'text-green-600' :
                                                'text-blue-600'
                                            }`}>{event.priority}</span>
                                        </div>
                                    )}
                                    {event.tags && event.tags.length > 0 && (
                                        <div>üè∑Ô∏è {Array.isArray(event.tags) ? event.tags.join(', ') : event.tags}</div>
                                    )}
                                    {/* Notes always visible */}
                                    <div className="text-sm">
                                        üìù {event.notes || <span className="text-gray-400 italic">No notes</span>}
                                    </div>
                                    {event.tasks && event.tasks.length > 0 && (
                                        <div>üìã {event.tasks.length} task{event.tasks.length !== 1 ? 's' : ''}</div>
                                    )}
                                </div>
                            </div>
                            <div className="flex gap-1">
                                <button
                                    onClick={() => setExpanded(!expanded)}
                                    className="p-1 hover:bg-gray-100 rounded"
                                    title="Expand/Collapse"
                                >
                                    {expanded ? <ChevronUp size={16} /> : <ChevronDown size={16} />}
                                </button>
                                <button
                                    onClick={() => {
                                        setEditingEvent(event);
                                        setShowEventModal(true);
                                    }}
                                    className="p-1 hover:bg-gray-100 rounded"
                                    title="Edit"
                                >
                                    <Edit2 size={16} />
                                </button>
                                <button
                                    onClick={async () => {
                                        if (confirm('Delete this event?')) {
                                            const eventToDelete = events.find(e => e.id === event.id);
                                            setEvents(prev => prev.filter(e => e.id !== event.id));
                                            showToast('Event deleted');
                                            
                                            // V2.5.0-SYNC: Delete from Supabase
                                            if (eventToDelete && user && !isLoadingFromSupabase) {
                                                await deleteEventFromSupabase(eventToDelete);
                                            }
                                        }
                                    }}
                                    className="p-1 hover:bg-red-100 rounded text-red-600"
                                    title="Delete"
                                >
                                    <Trash2 size={16} />
                                </button>
                            </div>
                        </div>
                        
                        {expanded && (
                            <div className="mt-3 pt-3 border-t space-y-2">
                                {event.tasks && event.tasks.length > 0 && (
                                    <div>
                                        <strong className="text-sm">Tasks in this event:</strong>
                                        <div className="mt-2 space-y-1">
                                            {event.tasks.map(task => (
                                                <div key={task.id} className="text-sm p-2 bg-white rounded border">
                                                    {task.text}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                );
            };

            // ====== VIEW: INDIVIDUAL LIST VIEW ======
            
            // V2.7.1 HYBRID: Sleek list item with useful features maintained
            // V2.7.2 FEATURE: Enhanced list item with 3 states, notes, and colorful icons
            const ListItemCard = ({ item, listId }) => {
                const [isEditing, setIsEditing] = useState(false);
                const [editText, setEditText] = useState(item.text);
                const [showNotes, setShowNotes] = useState(false);
                const [isEditingNotes, setIsEditingNotes] = useState(false);
                const [editNotes, setEditNotes] = useState(item.notes || '');
                // V2.7.5 NEW: Move to dropdown
                const [showMoveDropdown, setShowMoveDropdown] = useState(false);
                
                const handleToggle = () => {
                    handleToggleListTaskStatus(item.id, listId);
                };
                
                const handleDelete = () => {
                    handleDeleteFromList(item.id, listId);
                };
                
                const handleSaveEdit = () => {
                    if (editText.trim()) {
                        handleUpdateListTaskText(item.id, listId, editText.trim());
                        setIsEditing(false);
                    }
                };
                
                const handleSaveNotes = () => {
                    handleUpdateListTaskNotes(item.id, listId, editNotes.trim());
                    setIsEditingNotes(false);
                };
                
                // V2.7.5 NEW: Handle move to another list
                const handleMoveTo = (targetListId) => {
                    handleMoveItemToList(item.id, listId, targetListId);
                    setShowMoveDropdown(false);
                };
                
                // V2.8.0 NEW: Handle archive/unarchive
                const handleArchive = () => {
                    handleArchiveListItem(item.id, listId);
                };
                
                // V2.7.5 NEW: Get other lists (excluding current)
                const otherLists = customLists.filter(l => l.id !== listId);
                
                // V2.8.0: Check if archived
                const isArchived = item.archived || false;
                
                // V2.7.2: Three states - not-started, in-progress, done
                const status = item.status || 'not-started';
                const isDone = status === 'done';
                const isInProgress = status === 'in-progress';
                const hasNotes = item.notes && item.notes.trim().length > 0;
                
                // V2.7.2: Status icon and colors
                const getStatusDisplay = () => {
                    if (isDone) {
                        return {
                            icon: <Check size={16} className="text-white" />,
                            bgColor: 'bg-green-500',
                            borderColor: 'border-green-500',
                            hoverColor: 'hover:bg-green-600',
                            label: 'Done - Click to mark as not started'
                        };
                    } else if (isInProgress) {
                        return {
                            icon: <Clock size={16} className="text-white" />,
                            bgColor: 'bg-amber-500',
                            borderColor: 'border-amber-500',
                            hoverColor: 'hover:bg-amber-600',
                            label: 'In Progress - Click to mark as done'
                        };
                    } else {
                        return {
                            icon: null,
                            bgColor: 'bg-white',
                            borderColor: 'border-gray-300',
                            hoverColor: 'hover:border-gray-400',
                            label: 'Not Started - Click to mark as in progress'
                        };
                    }
                };
                
                const statusDisplay = getStatusDisplay();
                
                return (
                    <div className={`group rounded-lg border transition-all ${
                        isArchived 
                            ? 'bg-gray-50 border-gray-300 opacity-60 hover:opacity-100' 
                            : 'bg-white hover:bg-gray-50 border-gray-200'
                    }`}>
                        {/* Main row */}
                        <div className="flex items-center gap-3 px-3 py-2.5">
                            {/* Status icon - cycles through 3 states */}
                            <button
                                onClick={handleToggle}
                                className={`flex-shrink-0 w-6 h-6 rounded-full border-2 flex items-center justify-center transition-all ${
                                    isArchived ? 'opacity-50' : ''
                                } ${statusDisplay.bgColor} ${statusDisplay.borderColor} ${statusDisplay.hoverColor}`}
                                title={statusDisplay.label}
                            >
                                {statusDisplay.icon}
                            </button>
                            
                            {/* Text */}
                            <div className="flex-1 min-w-0">
                                {isEditing ? (
                                    <input
                                        type="text"
                                        value={editText}
                                        onChange={(e) => setEditText(e.target.value)}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter') handleSaveEdit();
                                            if (e.key === 'Escape') setIsEditing(false);
                                        }}
                                        onBlur={handleSaveEdit}
                                        className="w-full px-2 py-1 text-sm border border-blue-300 rounded focus:outline-none focus:border-blue-500"
                                        autoFocus
                                    />
                                ) : (
                                    <div>
                                        <span
                                            onClick={() => setIsEditing(true)}
                                            className={`text-sm cursor-pointer transition-all ${
                                                isDone ? 'line-through text-gray-400' : 
                                                isInProgress ? 'text-amber-700 font-medium' : 
                                                'text-gray-700'
                                            }`}
                                            title="Click to edit"
                                        >
                                            {item.text}
                                        </span>
                                        {/* V2.7.4: Inline notes display */}
                                        {hasNotes && (
                                            <div 
                                                className="mt-0.5 text-[11px] italic text-gray-500 cursor-pointer hover:text-gray-700 transition-colors"
                                                onClick={() => setShowNotes(!showNotes)}
                                                title="Click to edit note"
                                            >
                                                üìù {item.notes}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            {/* Action icons */}
                            <div className="flex items-center gap-1 relative">
                                {/* Notes indicator/button */}
                                <button
                                    onClick={() => setShowNotes(!showNotes)}
                                    className={`flex-shrink-0 p-1.5 rounded transition-all ${
                                        hasNotes 
                                            ? 'bg-blue-100 text-blue-600 hover:bg-blue-200' 
                                            : 'opacity-0 group-hover:opacity-100 text-gray-400 hover:bg-gray-100 hover:text-gray-600'
                                    }`}
                                    title={hasNotes ? "View notes" : "Add notes"}
                                >
                                    <FileText size={15} />
                                </button>
                                
                                {/* V2.7.5 NEW: Move to button */}
                                {otherLists.length > 0 && (
                                    <div className="relative">
                                        <button
                                            onClick={() => setShowMoveDropdown(!showMoveDropdown)}
                                            className="flex-shrink-0 opacity-0 group-hover:opacity-100 p-1.5 hover:bg-purple-50 rounded transition-all"
                                            title="Move to another list"
                                        >
                                            <MoveHorizontal size={15} className="text-purple-500" />
                                        </button>
                                        
                                        {/* Move dropdown */}
                                        {showMoveDropdown && (
                                            <div className="absolute right-0 top-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg z-50 min-w-[200px]">
                                                <div className="py-1">
                                                    <div className="px-3 py-2 text-xs font-semibold text-gray-500 border-b">
                                                        Move to...
                                                    </div>
                                                    {otherLists.map(list => (
                                                        <button
                                                            key={list.id}
                                                            onClick={() => handleMoveTo(list.id)}
                                                            className="w-full text-left px-3 py-2 hover:bg-gray-100 transition-colors flex items-center gap-2"
                                                        >
                                                            <span>{list.icon}</span>
                                                            <span className="text-sm">{list.name}</span>
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                {/* V2.8.0 NEW: Archive button */}
                                <button
                                    onClick={handleArchive}
                                    className={`flex-shrink-0 opacity-0 group-hover:opacity-100 p-1.5 rounded transition-all ${
                                        isArchived 
                                            ? 'bg-gray-100 text-gray-700 hover:bg-gray-200' 
                                            : 'hover:bg-amber-50 text-amber-600'
                                    }`}
                                    title={isArchived ? "Unarchive item" : "Archive item"}
                                >
                                    <Archive size={15} />
                                </button>
                                
                                {/* Delete button */}
                                <button
                                    onClick={handleDelete}
                                    className="flex-shrink-0 opacity-0 group-hover:opacity-100 p-1.5 hover:bg-red-50 rounded transition-all"
                                    title="Delete item"
                                >
                                    <Trash2 size={15} className="text-red-500" />
                                </button>
                            </div>
                        </div>
                        
                        {/* Notes section (expandable) */}
                        {showNotes && (
                            <div className="px-3 pb-3 pt-1 border-t border-gray-100">
                                {isEditingNotes ? (
                                    <div className="space-y-2">
                                        <textarea
                                            value={editNotes}
                                            onChange={(e) => setEditNotes(e.target.value)}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Escape') {
                                                    setIsEditingNotes(false);
                                                    setEditNotes(item.notes || '');
                                                }
                                                // Ctrl/Cmd + Enter to save
                                                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                                                    handleSaveNotes();
                                                }
                                            }}
                                            placeholder="Add notes (place of purchase, remarks, etc.)..."
                                            className="w-full px-2 py-1.5 text-xs border border-blue-300 rounded focus:outline-none focus:border-blue-500 resize-none"
                                            rows="2"
                                            autoFocus
                                        />
                                        <div className="flex gap-2">
                                            <button
                                                onClick={handleSaveNotes}
                                                className="px-2 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                                            >
                                                Save
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setIsEditingNotes(false);
                                                    setEditNotes(item.notes || '');
                                                }}
                                                className="px-2 py-1 text-xs bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                ) : (
                                    <div 
                                        onClick={() => setIsEditingNotes(true)}
                                        className="cursor-pointer"
                                    >
                                        {hasNotes ? (
                                            <p className="text-xs text-gray-600 italic bg-blue-50 px-2 py-1.5 rounded hover:bg-blue-100 transition-colors">
                                                üìù {item.notes}
                                            </p>
                                        ) : (
                                            <p className="text-xs text-gray-400 italic hover:text-gray-600 transition-colors">
                                                Click to add notes...
                                            </p>
                                        )}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                );
            };
            
            const IndividualListView = ({ listId }) => {
                // V2.7.1 FIX: Use REF for rapid entry mode (like tasks)
                const newTaskInputRef = useRef(null);
                const isCreatingTasksRef = useRef(false);
                const lastTaskCreationTimeRef = useRef(0);
                
                // V2.8.0 NEW: Show archived toggle
                const [showArchived, setShowArchived] = useState(false);
                
                // V2.7.5 NEW: Draft saving - restore draft on mount
                const draftKey = `list-draft-${listId}`;
                const [newTaskText, setNewTaskText] = useState(() => {
                    const savedDraft = localStorage.getItem(draftKey);
                    return savedDraft || '';
                });
                
                // V2.7.5 NEW: Save draft to localStorage when text changes
                useEffect(() => {
                    if (newTaskText.trim()) {
                        localStorage.setItem(draftKey, newTaskText);
                    } else {
                        localStorage.removeItem(draftKey);
                    }
                }, [newTaskText, draftKey]);
                
                const list = customLists.find(l => l.id === listId);
                
                if (!list) {
                    return (
                        <div className="bg-white rounded-lg shadow p-6">
                            <div className="text-center py-12">
                                <p className="text-gray-500 text-lg">List not found</p>
                                <button 
                                    onClick={() => setCurrentView('list')} 
                                    className="mt-4 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
                                >
                                    Back to Tasks
                                </button>
                            </div>
                        </div>
                    );
                }
                
                const totalPoints = list.tasks.reduce((sum, t) => sum + calculateTaskScore(t), 0);
                
                return (
                    <div className="bg-white rounded-lg shadow p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-3xl font-bold flex items-center gap-2">
                                <Tag className="text-amber-600" />
                                {list.name}
                            </h1>
                            <div className="flex items-center gap-2">
                                {/* V2.8.0 NEW: Show Archived toggle */}
                                <button
                                    onClick={() => setShowArchived(!showArchived)}
                                    className={`px-3 py-2 rounded-lg text-sm font-medium transition-all flex items-center gap-1 ${
                                        showArchived 
                                            ? 'bg-amber-100 text-amber-700 hover:bg-amber-200' 
                                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                    }`}
                                    title={showArchived ? "Hide archived items" : "Show archived items"}
                                >
                                    <Archive size={16} />
                                    {showArchived ? 'Hide Archived' : 'Show Archived'}
                                    {list.tasks.filter(t => t.archived).length > 0 && (
                                        <span className="ml-1 text-xs">
                                            ({list.tasks.filter(t => t.archived).length})
                                        </span>
                                    )}
                                </button>
                                <button 
                                    onClick={() => setCurrentView('list')} 
                                    className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                                >
                                    <ChevronLeft size={18} />
                                    Back
                                </button>
                            </div>
                        </div>
                        
                        <div className="flex gap-4 mb-6">
                            <div className="bg-blue-50 px-4 py-2 rounded-lg">
                                <span className="font-semibold text-blue-700">{list.tasks.length}</span>
                                <span className="text-blue-600 ml-1">items</span>
                            </div>
                            <div className="bg-green-50 px-4 py-2 rounded-lg">
                                <span className="font-semibold text-green-700">{totalPoints}</span>
                                <span className="text-green-600 ml-1">points</span>
                            </div>
                        </div>
                        
                        {/* V2.7.1 UX FIX: Input at TOP so new items don't push it down */}
                        <div className="bg-gradient-to-r from-amber-50 to-orange-50 p-4 rounded-lg border-2 border-amber-200 shadow-sm mb-6">
                            <div className="flex gap-2">
                                <input 
                                    ref={newTaskInputRef}
                                    type="text"
                                    placeholder="Add item to this list..."
                                    value={newTaskText}
                                    onChange={(e) => {
                                        setNewTaskText(e.target.value);
                                        // Extend rapid entry window while typing
                                        if (isCreatingTasksRef.current && e.target.value.trim().length > 0) {
                                            lastTaskCreationTimeRef.current = Date.now();
                                        }
                                    }}
                                    onKeyDown={(e) => {
                                    if (e.key === 'Enter' && newTaskText.trim()) {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        console.log('üöÄ Adding item to list:', newTaskText);
                                        
                                        const text = newTaskText.trim();
                                        const inputElement = newTaskInputRef.current;
                                        
                                        // Set rapid entry mode (REF not state!)
                                        isCreatingTasksRef.current = true;
                                        lastTaskCreationTimeRef.current = Date.now();
                                        console.log('üèÉ Rapid mode: true');
                                        
                                        // Clear SYNCHRONOUSLY with flushSync
                                        flushSync(() => {
                                            setNewTaskText('');
                                        });
                                        console.log('üßπ Input cleared');
                                        
                                        // V2.7.5 NEW: Clear draft from localStorage
                                        localStorage.removeItem(draftKey);
                                        console.log('üíæ Draft cleared from storage');
                                        
                                        // Keep focus with aggressive attempts
                                        // V2.11.1: CONDITIONAL - only focus if still in rapid entry mode
                                        if (inputElement) {
                                            // Helper: Check if should still focus
                                            const shouldFocus = () => {
                                                const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                                return isCreatingTasksRef.current && timeSince < 2000;
                                            };
                                            
                                            console.log('üéØ Starting focus retention');
                                            // Immediate attempts
                                            if (shouldFocus()) inputElement.focus();
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 0);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 10);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 20);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 50);
                                            
                                            // CRITICAL: Continue trying for 500ms (Supabase updates take 200-500ms)
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 100);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 150);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 200);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 250);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 300);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 350);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 400);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 500);
                                            
                                            // Frame-based (syncs with rendering)
                                            requestAnimationFrame(() => {
                                                if (shouldFocus()) inputElement.focus();
                                                requestAnimationFrame(() => { if (shouldFocus()) inputElement.focus(); });
                                            });
                                        }
                                        
                                        // Add the task (pass rapid mode flag to suppress toast)
                                        handleAddToList(listId, text, true);  // true = isRapidEntry
                                        
                                        // Exit rapid mode after delay
                                        setTimeout(() => {
                                            const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                            if (timeSince >= 4000) {
                                                console.log('üèÅ Exiting rapid mode');
                                                isCreatingTasksRef.current = false;
                                            }
                                        }, 4000);
                                    }
                                }}
                                className="flex-1 px-4 py-2 border-2 rounded-lg focus:border-amber-500 focus:outline-none"
                                autoFocus
                            />
                            <button 
                                onClick={() => {
                                    if (newTaskText.trim()) {
                                        const text = newTaskText.trim();
                                        const inputElement = newTaskInputRef.current;
                                        
                                        // Set rapid entry mode
                                        isCreatingTasksRef.current = true;
                                        lastTaskCreationTimeRef.current = Date.now();
                                        
                                        // Clear SYNCHRONOUSLY with flushSync
                                        flushSync(() => {
                                            setNewTaskText('');
                                        });
                                        
                                        // Clear draft from localStorage
                                        localStorage.removeItem(draftKey);
                                        
                                        // Keep focus with aggressive attempts
                                        // V2.11.1: CONDITIONAL - only focus if still in rapid entry mode
                                        if (inputElement) {
                                            // Helper: Check if should still focus
                                            const shouldFocus = () => {
                                                const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                                return isCreatingTasksRef.current && timeSince < 2000;
                                            };
                                            
                                            if (shouldFocus()) inputElement.focus();
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 0);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 10);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 20);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 50);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 100);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 150);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 200);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 250);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 300);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 350);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 400);
                                            setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 500);
                                            
                                            requestAnimationFrame(() => {
                                                if (shouldFocus()) inputElement.focus();
                                                requestAnimationFrame(() => { if (shouldFocus()) inputElement.focus(); });
                                            });
                                        }
                                        
                                        // Add the task (pass rapid mode flag)
                                        handleAddToList(listId, text, true);
                                        
                                        // Exit rapid mode after delay
                                        setTimeout(() => {
                                            const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                            if (timeSince >= 4000) {
                                                isCreatingTasksRef.current = false;
                                            }
                                        }, 4000);
                                    }
                                }}
                                className="px-6 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 flex items-center gap-2"
                            >
                                <Plus size={20} />
                                Add
                            </button>
                            </div>
                        </div>
                        
                        <div 
                            className="space-y-2 min-h-[200px] p-4 border-2 border-dashed border-gray-300 rounded-lg"
                            onDragOver={(e) => handleDragOver(e, 'custom-list', { listId })}
                            onDragLeave={handleDragLeave}
                            onDrop={(e) => handleDrop(e, 'custom-list', { listId })}
                        >
                            {list.tasks.length === 0 && (
                                <p className="text-gray-400 text-center py-8">No items in this list yet. Add items above!</p>
                            )}
                            {/* V2.8.0: Filter archived items based on toggle */}
                            {list.tasks
                                .filter(task => showArchived || !task.archived)
                                .map(task => (
                                    <ListItemCard 
                                        key={task.id}
                                        item={task}
                                        listId={listId}
                                    />
                                ))}
                        </div>
                    </div>
                );
            };

            // ====== LISTS MANAGEMENT MODAL (V2.7.1) ======
            const ListsManagementModal = () => {
                console.log('üé≠ ListsManagementModal rendered');
                // V2.7.1: Use local state for typing (prevents parent re-renders), persist in ref
                const [newListText, setNewListText] = useState(() => newListTextRef.current || '');
                const newListInputRef = useRef(null);
                
                // V2.7.1: Aggressive refocus when lists change during rapid entry
                useEffect(() => {
                    console.log('üîÑ useEffect triggered - lists.length:', customLists.length, 'rapid mode:', isCreatingListsRef.current);
                    if (isCreatingListsRef.current && newListInputRef.current) {
                        console.log('üéØ Refocusing due to lists change');
                        // Lists changed, we're in rapid entry mode, refocus NOW
                        newListInputRef.current.focus();
                        
                        // Multiple attempts to fight focus stealing
                        setTimeout(() => newListInputRef.current?.focus(), 0);
                        setTimeout(() => newListInputRef.current?.focus(), 10);
                        setTimeout(() => newListInputRef.current?.focus(), 50);
                        setTimeout(() => newListInputRef.current?.focus(), 100);
                    }
                }, [customLists.length]); // Re-run when lists array length changes
                
                // Save to ref before unmount
                useEffect(() => {
                    return () => {
                        newListTextRef.current = newListText;
                    };
                }, [newListText]);
                
                const handleAddList = () => {
                    console.log('üöÄ ListsManagementModal: handleAddList called');
                    const text = newListText.trim();
                    if (!text) return;
                    
                    console.log('‚úçÔ∏è Creating list:', text);
                    
                    // V2.7.1: Check if already in rapid mode
                    const wasInRapidMode = isCreatingListsRef.current;
                    console.log('üèÉ Rapid mode before:', wasInRapidMode);
                    
                    // Set rapid entry flags
                    isCreatingListsRef.current = true;
                    lastListCreationTimeRef.current = Date.now();
                    console.log('üèÉ Rapid mode set to: true');
                    
                    // Clear state SYNCHRONOUSLY using flushSync
                    console.log('üßπ Clearing input with flushSync');
                    flushSync(() => {
                        setNewListText('');
                    });
                    newListTextRef.current = '';
                    console.log('‚úÖ Input cleared');
                    
                    // Keep focus with multiple aggressive attempts
                    const inputElement = newListInputRef.current;
                    if (inputElement) {
                        console.log('üéØ Starting focus retention attempts');
                        // Immediate focus
                        inputElement.focus();
                        
                        // Multiple timed attempts
                        setTimeout(() => inputElement.focus(), 0);
                        setTimeout(() => inputElement.focus(), 10);
                        setTimeout(() => inputElement.focus(), 20);
                        setTimeout(() => inputElement.focus(), 50);
                        setTimeout(() => inputElement.focus(), 100);
                        
                        // Frame-based (syncs with rendering)
                        requestAnimationFrame(() => {
                            inputElement.focus();
                            requestAnimationFrame(() => inputElement.focus());
                        });
                    }
                    
                    // Create the list
                    const newList = {
                        id: Date.now(),
                        name: text,
                        tasks: []
                    };
                    
                    console.log('üíæ Adding list to state:', newList.name);
                    setCustomLists(prev => [...prev, newList]);
                    
                    // Save to Supabase (async, won't block)
                    if (user && !isLoadingFromSupabase) {
                        console.log('‚òÅÔ∏è Saving to Supabase');
                        saveListToSupabase(newList);
                    }
                    
                    // Exit rapid mode after delay
                    setTimeout(() => {
                        const timeSinceLastCreation = Date.now() - lastListCreationTimeRef.current;
                        if (timeSinceLastCreation >= 4000) {
                            console.log('üèÅ Exiting rapid mode');
                            isCreatingListsRef.current = false;
                        }
                    }, 4000);
                };
                
                return (
                    <div className="modal-backdrop flex items-center justify-center" onClick={() => setShowListsModal(false)}>
                        <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md m-4" onClick={(e) => e.stopPropagation()}>
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-2xl font-bold">Manage Lists</h2>
                                <button 
                                    onClick={() => setShowListsModal(false)}
                                    className="p-1 hover:bg-gray-100 rounded"
                                >
                                    <X size={24} />
                                </button>
                            </div>
                            
                            {/* V2.7.1: Ultra-compact sleek list items */}
                            <div className="space-y-1 mb-6 max-h-96 overflow-y-auto">
                                {customLists.map(list => (
                                    <div 
                                        key={list.id} 
                                        className="flex justify-between items-center px-2 py-1.5 bg-gradient-to-r from-amber-50 to-orange-50 border border-amber-100 hover:from-amber-100 hover:to-orange-100 transition-all duration-150"
                                        style={{borderRadius: '6px'}}
                                    >
                                        <div className="flex-1 min-w-0">
                                            <div className="text-xs font-medium text-gray-700 truncate">{list.name}</div>
                                            <div className="text-[10px] text-gray-500">
                                                {list.tasks.length} {list.tasks.length === 1 ? 'item' : 'items'}
                                            </div>
                                        </div>
                                        <div className="flex gap-0.5 ml-2">
                                            <button 
                                                onClick={() => handleRenameList(list.id)}
                                                className="p-1 text-blue-600 hover:bg-blue-100 rounded transition-colors"
                                                title="Rename list"
                                            >
                                                <Edit2 size={13} />
                                            </button>
                                            <button 
                                                onClick={() => handleDeleteList(list.id)}
                                                className="p-1 text-red-600 hover:bg-red-100 rounded transition-colors"
                                                title="Delete list"
                                            >
                                                <Trash2 size={13} />
                                            </button>
                                        </div>
                                    </div>
                                ))}
                                {customLists.length === 0 && (
                                    <p className="text-gray-400 text-center py-4 text-sm">No lists yet. Create one below!</p>
                                )}
                            </div>
                            
                            {/* V2.7.1: Input with rapid entry support */}
                            <div className="flex gap-2">
                                <input 
                                    ref={newListInputRef}
                                    type="text"
                                    placeholder="New list name..."
                                    value={newListText}
                                    onChange={(e) => {
                                        setNewListText(e.target.value);
                                        // Extend rapid entry window while typing
                                        if (isCreatingListsRef.current && e.target.value.trim().length > 0) {
                                            lastListCreationTimeRef.current = Date.now();
                                        }
                                    }}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter' && newListText.trim()) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            handleAddList();
                                        }
                                    }}
                                    className="flex-1 px-4 py-2 border-2 rounded-lg focus:border-amber-500 focus:outline-none"
                                    autoFocus
                                />
                                <button 
                                    onClick={handleAddList}
                                    className="px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 flex items-center gap-2 transition-colors"
                                >
                                    <Plus size={20} />
                                    Add
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // ====== VIEW: LIST VIEW ======
            const ListView = ({ newTaskTextRef }) => {
                // V2.6.3-REF: Use local state for typing (no parent re-renders), persist in ref across unmounts
                const [newTaskText, setNewTaskText] = useState(() => newTaskTextRef.current || '');
                const [localSearch, setLocalSearch] = useState(searchQuery);
                const searchTimeoutRef = useRef(null);
                const newTaskInputRef = useRef(null);
                
                // V2.6.3-AGGRESSIVE: Refocus input whenever tasks change during rapid entry
                useEffect(() => {
                    if (isCreatingTasksRef.current && newTaskInputRef.current) {
                        // Tasks changed, we're in rapid entry mode, refocus NOW
                        newTaskInputRef.current.focus();
                        
                        // Multiple attempts to fight any focus stealing
                        setTimeout(() => newTaskInputRef.current?.focus(), 0);
                        setTimeout(() => newTaskInputRef.current?.focus(), 10);
                        setTimeout(() => newTaskInputRef.current?.focus(), 50);
                        setTimeout(() => newTaskInputRef.current?.focus(), 100);
                    }
                }, [tasks.length]); // Re-run when tasks array length changes
                
                // Save to ref before unmount
                useEffect(() => {
                    return () => {
                        newTaskTextRef.current = newTaskText;
                    };
                }, [newTaskText, newTaskTextRef]);

                return (
                    <div className="space-y-4">
                        {/* Search and filters */}
                        <div className="bg-white rounded-lg shadow p-4">
                            <div className="flex gap-2 mb-3">
                                <div className="flex-1 relative">
                                    <Search className="absolute left-3 top-2.5 text-gray-400" size={20} />
                                    <input
                                        type="text"
                                        placeholder="Search tasks..."
                                        value={localSearch}
                                        onChange={(e) => {
                                            setLocalSearch(e.target.value);
                                            // Debounce search for smooth UX
                                            if (searchTimeoutRef.current) {
                                                clearTimeout(searchTimeoutRef.current);
                                            }
                                            searchTimeoutRef.current = setTimeout(() => {
                                                setSearchQuery(e.target.value);
                                            }, 300);
                                        }}
                                        className="w-full pl-10 pr-4 py-2 border rounded-lg"
                                    />
                                </div>
                                <button
                                    onClick={() => setShowFilters(!showFilters)}
                                    className={`px-4 py-2 rounded-lg flex items-center gap-2 ${
                                        showFilters ? 'bg-indigo-600 text-white' : 'bg-gray-200'
                                    }`}
                                >
                                    <Filter size={20} />
                                    Filters
                                </button>
                            </div>

                            {showFilters && (
                                <div className="grid md:grid-cols-4 gap-3 pt-3 border-t">
                                    <div>
                                        <label className="text-xs font-semibold mb-1 block">Status</label>
                                        <select
                                            value={filterStatus}
                                            onChange={(e) => setFilterStatus(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            <option value="all">All</option>
                                            {/* Dynamic statuses from all projects */}
                                            {(() => {
                                                const allStatuses = new Set();
                                                projects.forEach(p => {
                                                    (p.statuses || ['not-started', 'in-progress', 'completed']).forEach(s => allStatuses.add(s));
                                                });
                                                // Also add default statuses
                                                ['not-started', 'in-progress', 'completed'].forEach(s => allStatuses.add(s));
                                                return Array.from(allStatuses).sort().map(status => {
                                                    const label = status.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                                                    return <option key={status} value={status}>{label}</option>;
                                                });
                                            })()}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-xs font-semibold mb-1 block">Persona</label>
                                        <select
                                            value={filterPersona}
                                            onChange={(e) => setFilterPersona(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            <option value="all">All</option>
                                            {personas.map(p => (
                                                <option key={p} value={p}>{p}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-xs font-semibold mb-1 block">Project</label>
                                        <select
                                            value={filterProject}
                                            onChange={(e) => setFilterProject(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            <option value="all">All</option>
                                            {projects.filter(p => !p.isNoProject).map(p => (
                                                <option key={p.id} value={p.name}>{p.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-xs font-semibold mb-1 block">Sort By</label>
                                        <select
                                            value={sortBy}
                                            onChange={(e) => setSortBy(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            <option value="createdAt">Created Date</option>
                                            <option value="dueDate">Due Date</option>
                                            <option value="priority">Priority</option>
                                            <option value="points">Points</option>
                                        </select>
                                    </div>
                                </div>
                            )}

                            <div className="flex items-center gap-2 mt-3">
                                <button
                                    onClick={() => setShowArchived(!showArchived)}
                                    className={`px-3 py-1 rounded text-sm ${
                                        showArchived ? 'bg-yellow-100 text-yellow-700' : 'bg-gray-100'
                                    }`}
                                >
                                    <Archive size={14} className="inline mr-1" />
                                    {showArchived ? 'Viewing Archived' : 'View Archived'}
                                </button>
                                {/* V2.5.13-STABLE: Push/Pull order buttons - always visible */}
                                <div className="flex items-center gap-2">
                                    <button
                                        onClick={pushOrderToCloud}
                                        disabled={isLoadingFromSupabase || !tasks.some(t => t.manualOrder !== null)}
                                        className="px-3 py-1 rounded text-sm bg-green-500 text-white hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed flex items-center gap-1.5 transition-colors"
                                        title="Push your current order to cloud"
                                    >
                                        <svg 
                                            className="w-3.5 h-3.5" 
                                            fill="none" 
                                            stroke="currentColor" 
                                            viewBox="0 0 24 24"
                                        >
                                            <path 
                                                strokeLinecap="round" 
                                                strokeLinejoin="round" 
                                                strokeWidth={2} 
                                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" 
                                            />
                                        </svg>
                                        <span className="text-xs font-medium">Push</span>
                                    </button>
                                    
                                    {/* V2.6.2-POLISH: Sync button for manual refresh */}
                                    <button
                                        onClick={async () => {
                                            console.log('üîÑ Manual sync triggered');
                                            showToast('Syncing...', false);
                                            
                                            // Force reload from Supabase
                                            try {
                                                // Reload tasks
                                                const { data: tasksData, error: tasksError } = await supabase
                                                    .from('tasks')
                                                    .select('*')
                                                    .eq('user_id', user.id)
                                                    .order('created_at', { ascending: false });
                                                
                                                if (tasksError) throw tasksError;
                                                
                                                // Convert to local format
                                                const loadedTasks = tasksData.map(t => ({
                                                    id: t.id,
                                                    supabaseId: t.id,
                                                    text: t.text,
                                                    scheduledDate: t.scheduled_date,
                                                    dueDate: t.due_date,
                                                    timeSlot: t.time_slot,
                                                    estimatedDuration: t.estimated_duration || 30,
                                                    status: t.status,
                                                    priority: t.priority || 'medium',
                                                    taskType: t.task_type,
                                                    persona: t.persona,
                                                    project: t.project,
                                                    tags: t.tags || [],
                                                    notes: t.notes,
                                                    archived: t.archived || false,
                                                    isOldTask: t.is_old_task || false,
                                                    subtasks: t.subtasks || [],
                                                    manualOrder: t.manual_order,
                                                    createdAt: t.created_at,
                                                }));
                                                
                                                setTasks(loadedTasks);
                                                
                                                // Reload events
                                                const { data: eventsData, error: eventsError } = await supabase
                                                    .from('events')
                                                    .select('*')
                                                    .eq('user_id', user.id)
                                                    .order('created_at', { ascending: false });
                                                
                                                if (eventsError) throw eventsError;
                                                
                                                const loadedEvents = eventsData.map(e => ({
                                                    id: e.id,
                                                    supabaseId: e.id,
                                                    text: e.text,
                                                    date: e.event_date,
                                                    time: e.event_time,
                                                    duration: e.duration || 60,
                                                    color: e.color || '#10b981',
                                                    persona: e.persona,
                                                    project: e.project,
                                                    tags: e.tags || [],
                                                    notes: e.notes,
                                                    archived: e.archived || false,
                                                    createdAt: e.created_at,
                                                }));
                                                
                                                setEvents(loadedEvents);
                                                
                                                showToast('‚úÖ Synced successfully!', false);
                                                console.log('‚úÖ Manual sync complete:', loadedTasks.length, 'tasks,', loadedEvents.length, 'events');
                                            } catch (error) {
                                                console.error('‚ùå Sync error:', error);
                                                showToast('‚ùå Sync failed', true);
                                            }
                                        }}
                                        disabled={isLoadingFromSupabase}
                                        className="px-3 py-1 rounded text-sm bg-purple-500 text-white hover:bg-purple-600 disabled:bg-gray-300 disabled:cursor-not-allowed flex items-center gap-1.5 transition-colors"
                                        title="Sync with cloud (refresh data)"
                                    >
                                        <svg 
                                            className="w-3.5 h-3.5" 
                                            fill="none" 
                                            stroke="currentColor" 
                                            viewBox="0 0 24 24"
                                        >
                                            <path 
                                                strokeLinecap="round" 
                                                strokeLinejoin="round" 
                                                strokeWidth={2} 
                                                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" 
                                            />
                                        </svg>
                                        <span className="text-xs font-medium">Sync</span>
                                    </button>
                                    
                                    <button
                                        onClick={pullOrderFromCloud}
                                        disabled={isLoadingFromSupabase}
                                        className="px-3 py-1 rounded text-sm bg-blue-500 text-white hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed flex items-center gap-1.5 transition-colors"
                                        title="Pull order from cloud"
                                    >
                                        <svg 
                                            className="w-3.5 h-3.5" 
                                            fill="none" 
                                            stroke="currentColor" 
                                            viewBox="0 0 24 24"
                                        >
                                            <path 
                                                strokeLinecap="round" 
                                                strokeLinejoin="round" 
                                                strokeWidth={2} 
                                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" 
                                            />
                                        </svg>
                                        <span className="text-xs font-medium">Pull</span>
                                    </button>
                                </div>
                                <span className="text-sm text-gray-600">
                                    {filteredTasks.length} task{filteredTasks.length !== 1 ? 's' : ''}
                                </span>
                            </div>
                        </div>

                        {/* Quick add task */}
                        <div className="bg-white rounded-lg shadow p-4">
                            <div className="flex gap-2">
                                <input
                                    ref={newTaskInputRef}
                                    type="text"
                                    placeholder="Add a new task..."
                                    value={newTaskText}
                                    onChange={(e) => {
                                        setNewTaskText(e.target.value);
                                        // Extend rapid entry window while typing
                                        if (isCreatingTasksRef.current && e.target.value.trim().length > 0) {
                                            lastTaskCreationTimeRef.current = Date.now();
                                        }
                                    }}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter' && newTaskText.trim()) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            const taskText = newTaskText.trim();
                                            const inputElement = newTaskInputRef.current;
                                            
                                            // Set rapid entry flags
                                            isCreatingTasksRef.current = true;
                                            lastTaskCreationTimeRef.current = Date.now();
                                            
                                            // Clear state SYNCHRONOUSLY using flushSync
                                            flushSync(() => {
                                                setNewTaskText('');
                                            });
                                            newTaskTextRef.current = '';
                                            
                                            // MATCH LISTS: Aggressive focus retention (14 attempts over 500ms)
                                            // V2.11.1: CONDITIONAL - only focus if still in rapid entry mode
                                            if (inputElement) {
                                                // Helper: Check if should still focus
                                                const shouldFocus = () => {
                                                    const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                                    return isCreatingTasksRef.current && timeSince < 2000;
                                                };
                                                
                                                // Immediate attempts
                                                if (shouldFocus()) inputElement.focus();
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 0);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 10);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 20);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 50);
                                                
                                                // CRITICAL: Continue trying for 500ms (Supabase updates take 200-500ms)
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 100);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 150);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 200);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 250);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 300);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 350);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 400);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 500);
                                                
                                                // Frame-based (syncs with rendering)
                                                requestAnimationFrame(() => {
                                                    if (shouldFocus()) inputElement.focus();
                                                    requestAnimationFrame(() => { if (shouldFocus()) inputElement.focus(); });
                                                });
                                            }
                                            
                                            // Create task - pass rapid mode status
                                            createTask({ text: taskText, _wasInRapidMode: true });
                                            
                                            // Auto-clear flag after 4 seconds of no activity
                                            setTimeout(() => {
                                                if (Date.now() - lastTaskCreationTimeRef.current >= 4000) {
                                                    isCreatingTasksRef.current = false;
                                                }
                                            }, 4000);
                                        }
                                    }}
                                    className="flex-1 px-4 py-2 border rounded-lg"
                                    autoFocus
                                />
                                <button
                                    onClick={() => {
                                        if (newTaskText.trim()) {
                                            const taskText = newTaskText.trim();
                                            const inputElement = newTaskInputRef.current;
                                            
                                            // Set rapid entry flags
                                            isCreatingTasksRef.current = true;
                                            lastTaskCreationTimeRef.current = Date.now();
                                            
                                            // Clear state SYNCHRONOUSLY using flushSync
                                            flushSync(() => {
                                                setNewTaskText('');
                                            });
                                            newTaskTextRef.current = '';
                                            
                                            // MATCH LISTS: Aggressive focus retention
                                            // V2.11.1: CONDITIONAL - only focus if still in rapid entry mode
                                            if (inputElement) {
                                                // Helper: Check if should still focus
                                                const shouldFocus = () => {
                                                    const timeSince = Date.now() - lastTaskCreationTimeRef.current;
                                                    return isCreatingTasksRef.current && timeSince < 2000;
                                                };
                                                
                                                // Immediate attempts
                                                if (shouldFocus()) inputElement.focus();
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 0);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 10);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 20);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 50);
                                                
                                                // Continue for 500ms
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 100);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 150);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 200);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 250);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 300);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 350);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 400);
                                                setTimeout(() => { if (shouldFocus()) inputElement.focus(); }, 500);
                                                
                                                // Frame-based
                                                requestAnimationFrame(() => {
                                                    if (shouldFocus()) inputElement.focus();
                                                    requestAnimationFrame(() => { if (shouldFocus()) inputElement.focus(); });
                                                });
                                            }
                                            
                                            // Create task
                                            createTask({ text: taskText, _wasInRapidMode: true });
                                            
                                            // Auto-clear flag after 4 seconds
                                            setTimeout(() => {
                                                if (Date.now() - lastTaskCreationTimeRef.current >= 4000) {
                                                    isCreatingTasksRef.current = false;
                                                }
                                            }, 4000);
                                        }
                                    }}
                                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700"
                                >
                                    <Plus size={20} />
                                </button>
                            </div>
                        </div>

                        {/* Task list */}
                        <div className="bg-white rounded-lg shadow p-4">
                            {filteredTasks.length === 0 ? (
                                <div className="text-center py-12">
                                    <Target className="mx-auto text-gray-300 mb-4" size={48} />
                                    <p className="text-gray-500 text-lg">
                                        {showArchived ? 'No archived tasks' : 'No tasks found'}
                                    </p>
                                    <p className="text-gray-400 text-sm mt-2">
                                        {showArchived ? 'Archive completed tasks to see them here' : 'Create a new task to get started'}
                                    </p>
                                </div>
                            ) : (
                                <div>
                                    {/* V1.3: Events section */}
                                    {events.filter(e => !showArchived).length > 0 && (
                                        <div className="mb-6">
                                            <h3 className="font-semibold text-lg mb-3 flex items-center gap-2">
                                                <Calendar size={20} className="text-green-600" />
                                                Upcoming Events
                                            </h3>
                                            <div className="space-y-2">
                                                {events
                                                    .filter(e => !showArchived)
                                                    .sort((a, b) => new Date(a.scheduledDate + ' ' + a.startTime) - new Date(b.scheduledDate + ' ' + b.startTime))
                                                    .map(event => (
                                                        <EventCard key={event.id} event={event} location="list" />
                                                    ))}
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* V1.3: Reset Order button */}
                                    {isManualOrder && (
                                        <div className="mb-3 flex justify-end">
                                            <button
                                                onClick={() => {
                                                    // FIX Issue 3: Clear manualOrder properly
                                                    setTasks(prev => prev.map(t => ({ ...t, manualOrder: null })));
                                                    setIsManualOrder(false);
                                                    showToast('Order reset to default');
                                                }}
                                                className="px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 text-sm"
                                            >
                                                Reset Order
                                            </button>
                                        </div>
                                    )}
                                    
                                    <div className="space-y-1">
                                        {filteredTasks.map((task, index) => (
                                            <div key={task.id}>
                                                {/* Drop zone before task */}
                                                <div
                                                    className="h-2 transition-all"
                                                    data-drop-zone="reorder"
                                                    data-drop-data={JSON.stringify({ targetTaskId: task.id, position: 'before' })}
                                                    style={{ 
                                                        backgroundColor: (dragOverZone?.zone === 'reorder' && dragOverZone?.data?.targetTaskId === task.id && dragOverZone?.data?.position === 'before') || 
                                                                        (currentDropZone?.type === 'reorder' && JSON.parse(currentDropZone?.data || '{}').targetTaskId === task.id && JSON.parse(currentDropZone?.data || '{}').position === 'before') 
                                                                        ? '#6366f1' : 'transparent' 
                                                    }}
                                                    onDragOver={(e) => handleDragOver(e, 'reorder', { targetTaskId: task.id, position: 'before' })}
                                                    onDrop={(e) => handleDrop(e, 'reorder', { targetTaskId: task.id, position: 'before' })}
                                                />
                                                
                                                <TaskCard task={task} location="list" showDate={true} />
                                                
                                                {/* Drop zone after last task */}
                                                {index === filteredTasks.length - 1 && (
                                                    <div
                                                        className="h-2 transition-all"
                                                        data-drop-zone="reorder"
                                                        data-drop-data={JSON.stringify({ targetTaskId: task.id, position: 'after' })}
                                                        style={{ 
                                                            backgroundColor: (dragOverZone?.zone === 'reorder' && dragOverZone?.data?.targetTaskId === task.id && dragOverZone?.data?.position === 'after') ||
                                                                            (currentDropZone?.type === 'reorder' && JSON.parse(currentDropZone?.data || '{}').targetTaskId === task.id && JSON.parse(currentDropZone?.data || '{}').position === 'after')
                                                                            ? '#6366f1' : 'transparent' 
                                                        }}
                                                        onDragOver={(e) => handleDragOver(e, 'reorder', { targetTaskId: task.id, position: 'after' })}
                                                        onDrop={(e) => handleDrop(e, 'reorder', { targetTaskId: task.id, position: 'after' })}
                                                    />
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            };
            
            // V2.6.3-MEMO: Wrap with React.memo to prevent remounting when parent tasks change
            const MemoizedListView = React.memo(ListView);

            // Continue in next part...
            
            // ====== VIEW: CALENDAR VIEW ======
            const CalendarView = () => {
                const daysInMonth = getDaysInMonth(currentYear, currentMonth);
                const firstDay = getFirstDayOfMonth(currentYear, currentMonth);
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];

                const prevMonth = () => {
                    if (currentMonth === 0) {
                        setCurrentMonth(11);
                        setCurrentYear(currentYear - 1);
                    } else {
                        setCurrentMonth(currentMonth - 1);
                    }
                };

                const nextMonth = () => {
                    if (currentMonth === 11) {
                        setCurrentMonth(0);
                        setCurrentYear(currentYear + 1);
                    } else {
                        setCurrentMonth(currentMonth + 1);
                    }
                };

                const getTasksForDate = (dateStr) => {
                    // Include events
                    const eventsForDate = events.filter(event => {
                        return !event.archived && event.scheduledDate === dateStr;
                    }).map(e => ({ ...e, _itemType: 'event' }));
                    
                    // ‚úÖ REFACTORED: Use utility function instead of inline logic
                    const tasksForDate = tasks.filter(task => {
                        if (task.archived) return false;
                        
                        // Use centralized date utility (includes special case for scheduled date)
                        return getTaskIsScheduledForDate(task, dateStr);
                    }).map(task => {
                        // Mark invalid tasks (scheduled > due)
                        const isInvalid = task.scheduledDate && task.dueDate && 
                                         new Date(task.scheduledDate) > new Date(task.dueDate);
                        return { ...task, _isInvalid: isInvalid, _itemType: 'task' };
                    });
                    
                    // Return events first, then tasks
                    return [...eventsForDate, ...tasksForDate];
                };
                
                // Helper: Check if task is due on this date (for red highlighting)
                const isTaskDueDate = (task, dateStr) => {
                    return task.dueDate === dateStr;
                };

                const renderCalendarCells = () => {
                    const cells = [];
                    const blanks = [];
                    
                    // Empty cells before first day
                    for (let i = 0; i < firstDay; i++) {
                        blanks.push(
                            <div key={`blank-${i}`} className="calendar-cell border p-2 bg-gray-50"></div>
                        );
                    }

                    // Days of month
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        const tasksOnDate = getTasksForDate(dateStr);
                        const eventsOnDate = (events || []).filter(e => e.scheduledDate === dateStr);
                        const isToday = isSameDay(dateStr, formatDate(new Date()));
                        const isSelected = dateStr === selectedDate;

                        cells.push(
                            <div
                                key={day}
                                className={`calendar-cell border p-2 cursor-pointer transition-colors ${
                                    tasksOnDate.length > 0 ? 'has-tasks' : ''
                                } ${isToday ? 'bg-blue-50 border-blue-300' : 'bg-white'} ${
                                    isSelected ? 'ring-2 ring-indigo-500' : ''
                                } hover:bg-indigo-50`}
                                data-drop-zone="calendar-date"
                                data-drop-data={JSON.stringify({ date: dateStr })}
                                onClick={() => setSelectedDate(dateStr)}
                                onDragOver={(e) => handleDragOver(e, 'calendar-date', { date: dateStr })}
                                onDragLeave={handleDragLeave}
                                onDrop={(e) => handleDrop(e, 'calendar-date', { date: dateStr })}
                                style={{
                                    backgroundColor: (dragOverZone?.zone === 'calendar-date' && dragOverZone?.data?.date === dateStr) ||
                                                   (currentDropZone?.type === 'calendar-date' && JSON.parse(currentDropZone?.data || '{}').date === dateStr) ? 
                                                   'rgba(99, 102, 241, 0.1)' : undefined
                                }}
                            >
                                <div className="flex justify-between items-start mb-2">
                                    <span className={`text-sm font-semibold ${isToday ? 'text-blue-600' : ''}`}>
                                        {day}
                                    </span>
                                    {tasksOnDate.length > 0 && (
                                        <span className="text-xs px-2 py-0.5 bg-indigo-600 text-white rounded-full">
                                            {tasksOnDate.length}
                                        </span>
                                    )}
                                </div>
                                
                                {/* Show all items (events + tasks) */}
                                <div className="space-y-1">
                                    {tasksOnDate.slice(0, 3).map(item => {
                                        // Check if it's an event or task
                                        if (item._itemType === 'event') {
                                            return (
                                                <div
                                                    key={item.id}
                                                    className="text-xs p-1 rounded truncate font-semibold"
                                                    style={{ 
                                                        backgroundColor: `${item.color}20`,
                                                        color: item.color
                                                    }}
                                                    title={`${item.text} (${item.startTime}-${item.endTime})`}
                                                >
                                                    üìÖ {item.text}
                                                </div>
                                            );
                                        }
                                        
                                        // It's a task
                                        const isDue = isTaskDueDate(item, dateStr);
                                        const isInvalid = item._isInvalid;
                                        
                                        return (
                                            <div
                                                key={item.id}
                                                className={`text-xs p-1 rounded truncate ${
                                                    isInvalid ? 'bg-gray-300 text-gray-600 opacity-70' :
                                                    isDue ? 'bg-red-100 text-red-700 border border-red-300' :
                                                    item.status === 'completed' ? 'bg-green-100 text-green-700' :
                                                    item.status === 'in-progress' ? 'bg-blue-100 text-blue-700' :
                                                    'bg-gray-100 text-gray-700'
                                                }`}
                                                title={`${item.text}${isInvalid ? ' (‚ö†Ô∏è INVALID DATES)' : isDue ? ' (DUE TODAY üìç)' : ''}`}
                                            >
                                                {isInvalid && '‚ö†Ô∏è '}
                                                {isDue && !isInvalid && 'üìç '}
                                                {item.text}
                                            </div>
                                        );
                                    })}
                                    {tasksOnDate.length > 3 && (
                                        <div className="text-xs text-gray-500 text-center">
                                            +{tasksOnDate.length - 3} more
                                        </div>
                                    )}
                                </div>
                            </div>
                        );
                    }

                    return [...blanks, ...cells];
                };

                const tasksOnSelectedDate = getTasksForDate(selectedDate);

                return (
                    <div className="space-y-4">
                        {/* Calendar header */}
                        <div className="bg-white rounded-lg shadow p-4">
                            <div className="flex items-center justify-between mb-4">
                                <button
                                    onClick={prevMonth}
                                    className="p-2 hover:bg-gray-100 rounded"
                                >
                                    <ChevronLeft size={24} />
                                </button>
                                <h2 className="text-2xl font-bold">
                                    {monthNames[currentMonth]} {currentYear}
                                </h2>
                                <button
                                    onClick={nextMonth}
                                    className="p-2 hover:bg-gray-100 rounded"
                                >
                                    <ChevronRight size={24} />
                                </button>
                            </div>

                            {/* Day labels */}
                            <div className="grid grid-cols-7 gap-2 mb-2">
                                {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                                    <div key={day} className="text-center font-semibold text-sm text-gray-600">
                                        {day}
                                    </div>
                                ))}
                            </div>

                            {/* Calendar grid */}
                            <div className="grid grid-cols-7 gap-2">
                                {renderCalendarCells()}
                            </div>
                        </div>

                        {/* Tasks for selected date */}
                        <div className="bg-white rounded-lg shadow p-4">
                            <h3 className="text-lg font-bold mb-3">
                                Tasks for {formatDateDisplay(selectedDate)}
                            </h3>
                            {tasksOnSelectedDate.length === 0 ? (
                                <div className="text-center py-8">
                                    <Calendar className="mx-auto text-gray-300 mb-2" size={40} />
                                    <p className="text-gray-500">No tasks scheduled for this date</p>
                                    <button
                                        onClick={() => {
                                            createTask({ scheduledDate: selectedDate });
                                        }}
                                        className="mt-3 px-4 py-2 bg-indigo-600 text-white rounded-lg"
                                    >
                                        Add Task
                                    </button>
                                </div>
                            ) : (
                                <div className="space-y-2">
                                    {tasksOnSelectedDate.map(task => (
                                        <TaskCard key={task.id} task={task} location="calendar" />
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                );
            };

            // Continuing implementation...
            // Due to character limits, I'll create the remaining views in a concise way
            
            // Simple Timeline View
            const TimelineView = () => {
                const [newTimelineTask, setNewTimelineTask] = useState('');

                // FIX: Show ALL tasks for the date (like Calendar), not just those with time slots
                // ‚úÖ REFACTORED: Use utility function
                const tasksForDate = tasks.filter(t => {
                    if (t.archived) return false;
                    return getTaskIsScheduledForDate(t, selectedDate);
                });
                
                const handleQuickAddTask = () => {
                    if (!newTimelineTask.trim()) return;
                    
                    const newTask = {
                        id: Date.now(),
                        text: newTimelineTask.trim(),
                        status: 'not-started',
                        priority: 'medium',
                        taskType: 'consistency',
                        persona: personas[0],
                        project: null,
                        scheduledDate: selectedDate,
                        dueDate: null,
                        timeSlot: null,
                        estimatedDuration: null,
                        tags: [],
                        notes: '',
                        subtasks: [],
                        isOldTask: false,
                        archived: false,
                        createdAt: new Date().toISOString(),
                    };
                    
                    setTasks(prev => [...prev, newTask]);
                    setNewTimelineTask('');
                    setQuickEditTask(newTask);
                    setShowQuickEdit(true);
                };

                return (
                    <div className="bg-white rounded-lg shadow p-4">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">Timeline for {formatDateDisplay(selectedDate)}</h2>
                            <input
                                type="date"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="px-3 py-2 border rounded"
                            />
                        </div>
                        
                        <div className="mb-4 flex gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                            <input
                                type="text"
                                placeholder="Quick add task for this date..."
                                value={newTimelineTask}
                                onChange={(e) => setNewTimelineTask(e.target.value)}
                                onKeyPress={(e) => e.key === 'Enter' && handleQuickAddTask()}
                                className="flex-1 px-3 py-2 border rounded-lg"
                            />
                            <button
                                onClick={handleQuickAddTask}
                                disabled={!newTimelineTask.trim()}
                                className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 disabled:bg-gray-300 flex items-center gap-2"
                            >
                                <Plus size={18} />
                                Add
                            </button>
                        </div>
                        
                        {/* Fix #2: Unscheduled Tasks Section */}
                        {(() => {
                            const unscheduledTasks = tasks.filter(t => 
                                !t.archived && t.scheduledDate === selectedDate && !t.timeSlot
                            );
                            
                            if (unscheduledTasks.length === 0) return null;
                            
                            return (
                                <div className="mb-4 p-4 bg-yellow-50 rounded-lg border-2 border-yellow-300">
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        üìã Unscheduled Tasks ({unscheduledTasks.length})
                                        <span className="text-xs text-blue-600 font-semibold">
                                            ‚¨áÔ∏è Drag tasks below to time slots to schedule them
                                        </span>
                                    </h3>
                                    <div className="space-y-2">
                                        {unscheduledTasks.map(task => (
                                            <div key={task.id} className="relative">
                                                <TaskCard task={task} location="timeline" />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            );
                        })()}
                        
                        <div className="space-y-1">
                            {timeSlots.map(slot => {
                                const tasksAtSlot = tasksForDate.filter(t => t.timeSlot === slot);
                                const eventsAtSlot = events.filter(e => 
                                    e.scheduledDate === selectedDate && 
                                    e.startTime <= slot && 
                                    e.endTime > slot
                                );
                                const isDropTarget = dragOverZone?.zone === 'timeline-slot' && dragOverZone?.data?.slot === slot;
                                const isMouseDropTarget = currentDropZone?.type === 'timeline-slot' && JSON.parse(currentDropZone?.data || '{}').slot === slot;
                                
                                return (
                                    <div
                                        key={slot}
                                        className={`flex gap-3 min-h-[60px] border-b transition-colors ${
                                            (isDropTarget || isMouseDropTarget) ? 'bg-blue-100 border-blue-400' : 'hover:bg-gray-50'
                                        }`}
                                        data-drop-zone="timeline-slot"
                                        data-drop-data={JSON.stringify({ slot, date: selectedDate })}
                                        onDragOver={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            e.dataTransfer.dropEffect = 'move';
                                            handleDragOver(e, 'timeline-slot', { slot });
                                        }}
                                        onDragLeave={(e) => {
                                            e.preventDefault();
                                            handleDragLeave(e);
                                        }}
                                        onDrop={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            handleDrop(e, 'timeline-slot', { slot });
                                        }}
                                        style={{
                                            cursor: (draggedItem || isDragging) ? 'copy' : 'default',
                                            minHeight: '60px',
                                            padding: '8px'
                                        }}
                                    >
                                        <div className="w-20 text-sm font-semibold text-gray-600 pt-2">
                                            {formatTimeAMPM(slot)}
                                        </div>
                                        <div className="flex-1 pl-3 border-l-2">
                                            {eventsAtSlot.map(event => (
                                                <EventCard key={event.id} event={event} location="timeline" />
                                            ))}
                                            {tasksAtSlot.map(task => (
                                                <TaskCard key={task.id} task={task} location="timeline" />
                                            ))}
                                            {isDropTarget && (
                                                <div className="text-sm text-blue-600 font-semibold py-2">
                                                    Drop here to schedule at {slot}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            // Simple Gantt View
            const GanttView = () => {
                const [ganttGroupBy, setGanttGroupBy] = useStickyState('project', 'ln_ganttGroupBy'); // 'project' or 'persona' - persist!
                const today = formatDate(new Date());
                
                // Get all tasks (not just those with dates)
                const allTasks = tasks.filter(t => !t.archived);
                
                // Today's tasks with subtasks - use same logic as Calendar
                // ‚úÖ REFACTORED: Use utility function
                const todayTasks = allTasks.filter(task => {
                    return getTaskIsScheduledForDate(task, today);
                });
                
                const todayWithSubtasks = [];
                todayTasks.forEach(task => {
                    todayWithSubtasks.push({...task, isSubtask: false});
                    if (task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach(st => {
                            todayWithSubtasks.push({
                                ...st,
                                id: `${task.id}-${st.id}`, // Composite ID for React key
                                originalSubtaskId: st.id,   // Original ID for lookup
                                parentId: task.id,
                                isSubtask: true,
                                parentText: task.text,
                                persona: task.persona,
                                project: task.project,
                                priority: st.priority || task.priority,
                                scheduledDate: task.scheduledDate,
                                dueDate: task.dueDate,
                                estimatedDuration: st.estimatedDuration || 30
                            });
                        });
                    }
                });
                
                // Group all tasks by project or persona
                const tasksGrouped = {};
                allTasks.forEach(task => {
                    const groupKey = ganttGroupBy === 'project' 
                        ? (task.project || 'No Project')
                        : task.persona;
                    if (!tasksGrouped[groupKey]) tasksGrouped[groupKey] = [];
                    tasksGrouped[groupKey].push(task);
                });
                
                // Calculate date range for timeline
                const getDates = () => {
                    const dates = [];
                    const tasksWithDates = allTasks.filter(t => t.scheduledDate);
                    if (tasksWithDates.length === 0) return [today];
                    
                    const allDates = tasksWithDates.map(t => new Date(t.scheduledDate));
                    const minDate = new Date(Math.min(...allDates));
                    const maxDate = new Date(Math.max(...allDates));
                    maxDate.setDate(maxDate.getDate() + 7); // Add week buffer
                    
                    const current = new Date(minDate);
                    while (current <= maxDate) {
                        dates.push(formatDate(current));
                        current.setDate(current.getDate() + 1);
                    }
                    return dates;
                };
                const dateRange = getDates();
                
                // Get priority color
                const getPriorityColor = (priority) => {
                    switch(priority) {
                        case 'urgent': return 'bg-red-500';
                        case 'high': return 'bg-orange-500';
                        case 'medium': return 'bg-yellow-500';
                        case 'low': return 'bg-green-500';
                        default: return 'bg-gray-500';
                    }
                };
                
                // State for drag with useRef for immediate updates
                const [isDragging, setIsDragging] = useState(false); // Simple boolean for visual feedback
                const [visualDragOffset, setVisualDragOffset] = useState(0); // Days offset for visual feedback
                const [visualDragMode, setVisualDragMode] = useState(null); // Track resize mode for visual feedback
                const draggingGanttTaskRef = React.useRef(null);
                const dragModeRef = React.useRef(null);
                const dragStartXRef = React.useRef(0);
                const dragStartDateRef = React.useRef(null);
                const dragStartDaysRef = React.useRef(0);
                const lastDaysDeltaRef = React.useRef(0);  // FIX Issue 4: Track in ref not variable
                const dragStartYRef = React.useRef(0);  // Track Y position for movement detection
                const wasDraggingTaskIdRef = React.useRef(null);  // Track WHICH task was just dragged
                const timelineContainerRef = React.useRef(null);
                
                // Timeline drag refs (for Today's Tasks timeline bars)
                const [timelineGhostBar, setTimelineGhostBar] = useState(null); // {taskId, leftPercent, widthPercent}
                const timelineDragTaskRef = React.useRef(null);
                const timelineDragModeRef = React.useRef(null); // 'move', 'resize-start', 'resize-end'
                const timelineDragStartXRef = React.useRef(0);
                const timelineDragStartTimeRef = React.useRef(null); // Original timeSlot
                const timelineDragStartDurationRef = React.useRef(0); // Original estimatedDuration
                const timelineIsDraggingRef = React.useRef(false);
                
                // Render task bar with drag
                const TaskBar = ({ task, dateRange }) => {
                    if (!task.scheduledDate) return null;
                    
                    const startIndex = dateRange.indexOf(task.scheduledDate);
                    if (startIndex === -1) return null;
                    
                    // ‚úÖ REFACTORED: Use utility function
                    const daysSpan = getTaskDaysSpan(task);
                    
                    const leftPercent = (startIndex / dateRange.length) * 100;
                    const widthPercent = (daysSpan / dateRange.length) * 100;
                    
                    const handleBarMouseDown = (e, mode) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // CRITICAL FIX: Only start drag if NOT already dragging!
                        // This prevents re-renders from resetting the start date
                        if (draggingGanttTaskRef.current) {
                            console.log('‚ö†Ô∏è Already dragging, ignoring mousedown');
                            return;
                        }
                        
                        // Store ORIGINAL dates - LOCKED at start, never changes during drag!
                        // DON'T set isDragging yet - wait for actual movement
                        draggingGanttTaskRef.current = task;
                        dragModeRef.current = mode;
                        setVisualDragMode(mode); // Store mode for visual feedback
                        dragStartXRef.current = e.clientX;
                        dragStartYRef.current = e.clientY; // Store Y for movement detection
                        dragStartDateRef.current = task.scheduledDate; // LOCKED!
                        dragStartDaysRef.current = daysSpan; // LOCKED!
                        
                        console.log('üéØ Gantt drag start:', mode, task.text, 'from date:', task.scheduledDate, '(LOCKED)');
                        
                        // Define handlers as functions that can be removed later
                        const handleMouseMove = (e) => {
                            if (!draggingGanttTaskRef.current) return;
                            
                            e.preventDefault();
                            
                            const container = timelineContainerRef.current;
                            if (!container) return;
                            
                            const containerWidth = container.offsetWidth;
                            const deltaX = e.clientX - dragStartXRef.current;
                            const pixelsPerDay = containerWidth / dateRange.length;
                            
                            // Calculate days delta
                            const daysDelta = deltaX > 0 
                                ? Math.floor(deltaX / pixelsPerDay + 0.4)
                                : Math.ceil(deltaX / pixelsPerDay - 0.4);
                            
                            // Throttle: Only update if delta changed
                            if (daysDelta === lastDaysDeltaRef.current) return;
                            
                            // Now we know user is actually dragging
                            if (!isDragging) {
                                setIsDragging(true);
                                console.log('üöÄ Drag movement detected, isDragging = true');
                            }
                            
                            console.log('üìç Drag move:', daysDelta, 'days (deltaX:', Math.round(deltaX), 'px)');
                            
                            // ‚úÖ FIX Screen Jumps: Only update visual state when day count changes
                            // This reduces re-renders from ~20 per drag to ~5 per drag
                            if (daysDelta !== lastDaysDeltaRef.current) {
                                lastDaysDeltaRef.current = daysDelta;
                                setVisualDragOffset(daysDelta); // Update visual feedback only on day change
                            }
                            
                            const mode = dragModeRef.current;
                            const task = draggingGanttTaskRef.current;
                            
                            // ‚úÖ FIX: DON'T call setTasks() during drag!
                            // Store nothing - task will update ONCE on mouseup
                            // This prevents re-renders that destroy event handlers
                        };
                        
                        const handleMouseUp = () => {
                            // Remove listeners first
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                            
                            if (draggingGanttTaskRef.current) {
                                const mode = dragModeRef.current;
                                
                                // Check if there was actual movement (drag vs click)
                                const actuallyDragged = lastDaysDeltaRef.current !== 0;
                                
                                if (actuallyDragged) {
                                    console.log('üèÅ Gantt drag end:', mode);
                                    
                                    // LOCK scroll position during state update  
                                    // Method: Add padding to compensate for scrollbar width, then hide overflow
                                    const scrollX = window.scrollX;
                                    const scrollY = window.scrollY;
                                    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
                                    
                                    // Prevent layout shift by compensating for scrollbar
                                    const originalOverflow = document.body.style.overflow;
                                    const originalPaddingRight = document.body.style.paddingRight;
                                    document.body.style.paddingRight = `${scrollbarWidth}px`;
                                    document.body.style.overflow = 'hidden';
                                    
                                    // ‚úÖ NOW apply the changes - ONCE at the end!
                                    const task = draggingGanttTaskRef.current;
                                    const daysDelta = lastDaysDeltaRef.current;
                                    
                                    if (mode === 'move') {
                                        const startDate = new Date(dragStartDateRef.current);
                                        startDate.setDate(startDate.getDate() + daysDelta);
                                        const newStartDate = formatDate(startDate);
                                        
                                        if (dateRange.includes(newStartDate)) {
                                            const endDate = new Date(startDate);
                                            // FIX: Subtract 1 because getTaskDaysSpan counts inclusive days
                                            // e.g., 3 days = Dec 19, 20, 21 = scheduledDate + 2 days to get dueDate
                                            endDate.setDate(endDate.getDate() + dragStartDaysRef.current - 1);
                                            
                                            if (task.isSubtask && task.parentId) {
                                                setTasks(prev => prev.map(t => {
                                                    if (t.id === task.parentId) {
                                                        return {
                                                            ...t,
                                                            subtasks: (t.subtasks || []).map(st => 
                                                                st.id === task.id ? {
                                                                    ...st,
                                                                    scheduledDate: newStartDate,
                                                                    dueDate: formatDate(endDate)
                                                                } : st
                                                            )
                                                        };
                                                    }
                                                    return t;
                                                }));
                                            } else {
                                                setTasks(prev => prev.map(t => 
                                                    t.id === task.id ? {
                                                        ...t,
                                                        scheduledDate: newStartDate,
                                                        dueDate: formatDate(endDate)
                                                    } : t
                                                ));
                                            }
                                        }
                                    } else if (mode === 'resize-end') {
                                        const newDaysSpan = Math.max(1, dragStartDaysRef.current + daysDelta);
                                        const startDate = new Date(dragStartDateRef.current);
                                        const endDate = new Date(startDate);
                                        // FIX: Subtract 1 because getTaskDaysSpan counts inclusive days
                                        // e.g., 3 days = Dec 19, 20, 21 = scheduledDate + 2 days to get dueDate
                                        endDate.setDate(endDate.getDate() + newDaysSpan - 1);
                                        
                                        if (task.isSubtask && task.parentId) {
                                            setTasks(prev => prev.map(t => {
                                                if (t.id === task.parentId) {
                                                    return {
                                                        ...t,
                                                        subtasks: (t.subtasks || []).map(st => 
                                                            st.id === task.id ? {
                                                                ...st,
                                                                dueDate: formatDate(endDate)
                                                            } : st
                                                        )
                                                    };
                                                }
                                                return t;
                                            }));
                                        } else {
                                            setTasks(prev => prev.map(t => 
                                                t.id === task.id ? {
                                                    ...t,
                                                    dueDate: formatDate(endDate)
                                                } : t
                                            ));
                                        }
                                    } else if (mode === 'resize-start') {
                                        const startDate = new Date(dragStartDateRef.current);
                                        startDate.setDate(startDate.getDate() + daysDelta);
                                        const newStartDate = formatDate(startDate);
                                        
                                        if (dateRange.includes(newStartDate)) {
                                            if (task.isSubtask && task.parentId) {
                                                setTasks(prev => prev.map(t => {
                                                    if (t.id === task.parentId) {
                                                        return {
                                                            ...t,
                                                            subtasks: (t.subtasks || []).map(st => 
                                                                st.id === task.id ? {
                                                                    ...st,
                                                                    scheduledDate: newStartDate
                                                                } : st
                                                            )
                                                        };
                                                    }
                                                    return t;
                                                }));
                                            } else {
                                                setTasks(prev => prev.map(t => 
                                                    t.id === task.id ? {
                                                        ...t,
                                                        scheduledDate: newStartDate
                                                    } : t
                                                ));
                                            }
                                        }
                                    }
                                    
                                    // ‚úÖ AGGRESSIVE SCROLL RESTORE: Try multiple times to fight browser scroll changes
                                    // Restore immediately
                                    window.scrollTo(scrollX, scrollY);
                                    
                                    // Restore in next frame
                                    requestAnimationFrame(() => {
                                        window.scrollTo(scrollX, scrollY);
                                        document.body.style.overflow = originalOverflow;
                                        document.body.style.paddingRight = originalPaddingRight;
                                        console.log('üìç Scroll restored (frame 1) to', scrollX, scrollY);
                                        
                                        // Restore in frame after that
                                        requestAnimationFrame(() => {
                                            window.scrollTo(scrollX, scrollY);
                                            console.log('üìç Scroll restored (frame 2) to', scrollX, scrollY);
                                            
                                            // One more time for good measure
                                            setTimeout(() => {
                                                window.scrollTo(scrollX, scrollY);
                                                console.log('üìç Scroll restored (final) to', scrollX, scrollY);
                                            }, 10);
                                        });
                                    });
                                    
                                    const toastMsg = mode === 'move' ? 'Task moved' : 'Task resized';
                                    showToast(toastMsg, true);
                                    wasDraggingTaskIdRef.current = task.id; // Mark THIS task as dragged
                                } else {
                                    console.log('üëÜ Click detected (no movement)');
                                    wasDraggingTaskIdRef.current = null; // No drag, allow clicks
                                    
                                    // Manually trigger onClick since preventDefault() blocks native click
                                    // Use setTimeout to ensure it happens after mouseup completes
                                    const clickTask = draggingGanttTaskRef.current;
                                    setTimeout(() => {
                                        console.log('üîç Manual onClick for task:', clickTask.id);
                                        
                                        // Open QuickEdit for this task
                                        if (clickTask.isSubtask && clickTask.parentId) {
                                            // Find and edit subtask
                                            setTasks(currentTasks => {
                                                const parentTask = currentTasks.find(t => t.id === clickTask.parentId);
                                                if (parentTask) {
                                                    const subtaskData = parentTask.subtasks?.find(st => st.id === clickTask.id);
                                                    if (subtaskData) {
                                                        const subtaskForEdit = {
                                                            ...subtaskData,
                                                            parentId: parentTask.id,
                                                            isSubtask: true,
                                                            persona: subtaskData.persona || parentTask.persona,
                                                            priority: subtaskData.priority || parentTask.priority,
                                                            taskType: subtaskData.taskType || parentTask.taskType,
                                                            project: parentTask.project
                                                        };
                                                        console.log('‚úÖ Opening QuickEdit for subtask:', subtaskForEdit.text);
                                                        setQuickEditTask(subtaskForEdit);
                                                        setShowQuickEdit(true);
                                                    }
                                                }
                                                return currentTasks;
                                            });
                                        } else {
                                            // Regular task
                                            const originalTask = tasks.find(t => t.id === clickTask.id);
                                            if (originalTask) {
                                                console.log('‚úÖ Opening QuickEdit for task:', originalTask.text);
                                                setQuickEditTask({...originalTask});
                                                setShowQuickEdit(true);
                                            }
                                        }
                                    }, 10);
                                }
                            }
                            
                            // Clear drag state
                            setIsDragging(false);
                            setVisualDragOffset(0); // Clear visual offset
                            setVisualDragMode(null); // Clear drag mode
                            draggingGanttTaskRef.current = null;
                            dragModeRef.current = null;
                            lastDaysDeltaRef.current = 0;
                            
                            // Clear the wasDragging flag after a brief delay to let onClick fire
                            setTimeout(() => {
                                wasDraggingTaskIdRef.current = null;
                            }, 50); // Increased to 50ms for better click detection
                        };
                        
                        // Add listeners for this drag session
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    };
                    
                    const isDraggingThis = isDragging && draggingGanttTaskRef.current?.id === task.id;
                    
                    // Calculate visual offset and width changes during drag
                    let visualTransform = 'none';
                    let visualWidth = `${Math.max(widthPercent, 5)}%`;
                    let visualLeft = `${leftPercent}%`;
                    
                    if (isDraggingThis && visualDragOffset !== 0) {
                        const offsetPercent = (visualDragOffset / dateRange.length) * 100;
                        
                        if (visualDragMode === 'move') {
                            // Move: just translate
                            visualTransform = `translateX(${offsetPercent}%)`;
                        } else if (visualDragMode === 'resize-end') {
                            // Resize end: change width (right edge moves, left fixed)
                            const newDaysSpan = Math.max(1, dragStartDaysRef.current + visualDragOffset);
                            const newWidthPercent = (newDaysSpan / dateRange.length) * 100;
                            visualWidth = `${Math.max(newWidthPercent, 5)}%`;
                        } else if (visualDragMode === 'resize-start') {
                            // Resize start: change left AND width (left edge moves, right fixed)
                            // Calculate new left position
                            const newLeftPercent = leftPercent + offsetPercent;
                            visualLeft = `${newLeftPercent}%`;
                            
                            // Calculate new width (grows when dragging left, shrinks when dragging right)
                            const newDaysSpan = Math.max(1, dragStartDaysRef.current - visualDragOffset);
                            const newWidthPercent = (newDaysSpan / dateRange.length) * 100;
                            visualWidth = `${Math.max(newWidthPercent, 5)}%`;
                            
                            // NO transform - we're changing left directly
                        }
                    }
                    
                    return (
                        <div
                            className={`absolute h-6 rounded ${getPriorityColor(task.priority)} ${isDraggingThis ? 'opacity-60' : 'hover:opacity-80'}`}
                            style={{
                                left: visualLeft,
                                width: visualWidth,
                                top: '4px',
                                cursor: 'move',
                                userSelect: 'none',
                                transform: visualTransform,
                                transition: isDraggingThis ? 'none' : 'transform 0.2s ease',
                                pointerEvents: isDraggingThis ? 'none' : 'auto' // Only disable THIS bar
                            }}
                            onMouseDown={(e) => handleBarMouseDown(e, 'move')}
                            onClick={(e) => {
                                console.log('üîç onClick fired for task:', task.id, 'wasDraggingTaskIdRef:', wasDraggingTaskIdRef.current);
                                
                                // Only block if THIS specific task was just dragged
                                if (wasDraggingTaskIdRef.current === task.id) {
                                    console.log('üö´ Click blocked - THIS task was just dragged');
                                    return;
                                }
                                
                                try {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    
                                    console.log('üéØ TaskBar clicked:', {
                                        id: task.id,
                                        text: task.text,
                                        isSubtask: task.isSubtask,
                                        parentId: task.parentId
                                    });
                                    
                                    // FIX Issue 11: Edit subtask directly if it's a subtask
                                    if (task.isSubtask && task.parentId) {
                                        // Use setTasks to get latest state
                                        setTasks(currentTasks => {
                                            const parentTask = currentTasks.find(t => t.id === task.parentId);
                                            if (parentTask) {
                                                const subtaskData = parentTask.subtasks?.find(st => st.id === task.id);
                                                if (subtaskData) {
                                                    const subtaskForEdit = {
                                                        ...subtaskData,
                                                        parentId: parentTask.id,
                                                        isSubtask: true,
                                                        persona: subtaskData.persona || parentTask.persona,
                                                        priority: subtaskData.priority || parentTask.priority,
                                                        taskType: subtaskData.taskType || parentTask.taskType,
                                                        project: parentTask.project
                                                    };
                                                    console.log('‚úÖ Opening QuickEdit for subtask:', subtaskForEdit.text);
                                                    setQuickEditTask(subtaskForEdit);
                                                    setShowQuickEdit(true);
                                                }
                                            }
                                            return currentTasks; // No change to tasks
                                        });
                                    } else {
                                        // Regular task
                                        setTasks(currentTasks => {
                                            const originalTask = currentTasks.find(t => t.id === task.id);
                                            if (originalTask) {
                                                console.log('‚úÖ Opening QuickEdit for task:', originalTask.text);
                                                setQuickEditTask({...originalTask});
                                                setShowQuickEdit(true);
                                            }
                                            return currentTasks; // No change
                                        });
                                    }
                                } catch (err) {
                                    console.error('‚ùå Error in TaskBar click:', err);
                                }
                            }}
                            title={`${task.text} - ${daysSpan} day${daysSpan > 1 ? 's' : ''} - ${task.priority}`}
                        >
                            {/* Left resize handle */}
                            <div 
                                className="absolute left-0 top-0 bottom-0 w-2 cursor-ew-resize hover:bg-white hover:bg-opacity-30"
                                style={{ 
                                    userSelect: 'none',
                                    pointerEvents: isDraggingThis ? 'none' : 'auto'
                                }}
                                onMouseDown={(e) => handleBarMouseDown(e, 'resize-start')}
                                onClick={(e) => e.stopPropagation()}
                            />
                            
                            {/* Bar content - show days and status indicator */}
                            <div className="flex items-center justify-between text-white text-xs px-2 leading-6 pointer-events-none">
                                <span>{daysSpan}d</span>
                                {/* Dynamic status indicator (read-only, toggle is next to task name) */}
                                <span className="ml-1" title={getStatusIcon(task.status).label}>
                                    {getStatusIcon(task.status).icon}
                                </span>
                            </div>
                            
                            {/* Right resize handle */}
                            <div 
                                className="absolute right-0 top-0 bottom-0 w-2 cursor-ew-resize hover:bg-white hover:bg-opacity-30"
                                style={{ 
                                    userSelect: 'none',
                                    pointerEvents: isDraggingThis ? 'none' : 'auto'
                                }}
                                onMouseDown={(e) => handleBarMouseDown(e, 'resize-end')}
                                onClick={(e) => e.stopPropagation()}
                            />
                        </div>
                    );
                };
                
                // FIX Issue 6: Lock scroll during drag to prevent screen jumping
                // Note: Scroll lock removed - it caused screen jumps
                // Users can scroll during drag, but drag still works
                
                // ========== TIMELINE DRAG HANDLERS (for Today's Tasks) ==========
                const handleTimelineBarMouseDown = (e, task, mode) => {
                    e.stopPropagation();
                    e.preventDefault();
                    
                    timelineDragTaskRef.current = task;
                    timelineDragModeRef.current = mode;
                    timelineDragStartXRef.current = e.clientX;
                    timelineDragStartTimeRef.current = task.timeSlot;
                    timelineDragStartDurationRef.current = task.estimatedDuration || 30;
                    timelineIsDraggingRef.current = false; // Will be set to true on first movement
                    
                    console.log('üéØ Timeline drag start:', mode, task.text, 'from time:', task.timeSlot);
                    
                    document.addEventListener('mousemove', handleTimelineBarMouseMove);
                    document.addEventListener('mouseup', handleTimelineBarMouseUp);
                };
                
                const handleTimelineBarMouseMove = (e) => {
                    if (!timelineDragTaskRef.current) return;
                    
                    const deltaX = e.clientX - timelineDragStartXRef.current;
                    
                    // Detect movement threshold
                    if (!timelineIsDraggingRef.current && Math.abs(deltaX) > 3) {
                        timelineIsDraggingRef.current = true;
                        console.log('üöÄ Timeline drag movement detected');
                    }
                    
                    if (!timelineIsDraggingRef.current) return;
                    
                    const task = timelineDragTaskRef.current;
                    const mode = timelineDragModeRef.current;
                    
                    // Don't show ghost bar for unscheduled tasks
                    if (!task.timeSlot) {
                        setTimelineGhostBar(null);
                        return;
                    }
                    
                    // Calculate time change (15-minute snapping)
                    // Timeline width represents 6AM-9PM (15 hours = 900 minutes)
                    const timelineWidth = 800; // Approximate pixel width of timeline area
                    const totalMinutes = 15 * 60; // 15 hours
                    const pixelsPerMinute = timelineWidth / totalMinutes;
                    const minutesDelta = Math.round(deltaX / pixelsPerMinute / 15) * 15; // Snap to 15min
                    
                    // Calculate ghost bar position for visual feedback
                    const timeToMinutes = (timeStr) => {
                        if (!timeStr) return null;
                        const [hours, minutes] = timeStr.split(':').map(Number);
                        return hours * 60 + minutes;
                    };
                    
                    const MIN_TIME_MINUTES = 6 * 60;
                    const MAX_TIME_MINUTES = 21 * 60;
                    const RANGE_MINUTES = MAX_TIME_MINUTES - MIN_TIME_MINUTES;
                    
                    let ghostLeft, ghostWidth;
                    
                    if (mode === 'move') {
                        const oldMinutes = timeToMinutes(timelineDragStartTimeRef.current);
                        const newMinutes = Math.max(MIN_TIME_MINUTES, Math.min(MAX_TIME_MINUTES, oldMinutes + minutesDelta));
                        ghostLeft = ((newMinutes - MIN_TIME_MINUTES) / RANGE_MINUTES) * 100;
                        ghostWidth = (timelineDragStartDurationRef.current / 900) * 100;
                    } else if (mode === 'resize-start') {
                        const oldStartMinutes = timeToMinutes(timelineDragStartTimeRef.current);
                        const oldDuration = timelineDragStartDurationRef.current;
                        const oldEndMinutes = oldStartMinutes + oldDuration;
                        let newStartMinutes = oldStartMinutes + minutesDelta;
                        newStartMinutes = Math.max(MIN_TIME_MINUTES, Math.min(MAX_TIME_MINUTES, newStartMinutes));
                        const newDuration = Math.max(15, Math.min(180, oldEndMinutes - newStartMinutes));
                        ghostLeft = ((newStartMinutes - MIN_TIME_MINUTES) / RANGE_MINUTES) * 100;
                        ghostWidth = (newDuration / 900) * 100;
                    } else if (mode === 'resize-end') {
                        const startMinutes = timeToMinutes(timelineDragStartTimeRef.current);
                        const oldDuration = timelineDragStartDurationRef.current;
                        let newDuration = oldDuration + minutesDelta;
                        newDuration = Math.max(15, Math.min(180, newDuration));
                        newDuration = Math.min(newDuration, MAX_TIME_MINUTES - startMinutes);
                        ghostLeft = ((startMinutes - MIN_TIME_MINUTES) / RANGE_MINUTES) * 100;
                        ghostWidth = (newDuration / 900) * 100;
                    }
                    
                    setTimelineGhostBar({
                        taskId: task.id,
                        leftPercent: ghostLeft,
                        widthPercent: Math.min(ghostWidth, 90 - ghostLeft) // Buffer zone
                    });
                    
                    console.log('üìç Timeline drag move: deltaX:', deltaX, 'minutes delta:', minutesDelta, 'ghost:', ghostLeft + '%');
                };
                
                const handleTimelineBarMouseUp = (e) => {
                    if (!timelineDragTaskRef.current) return;
                    
                    const task = timelineDragTaskRef.current;
                    const mode = timelineDragModeRef.current;
                    
                    document.removeEventListener('mousemove', handleTimelineBarMouseMove);
                    document.removeEventListener('mouseup', handleTimelineBarMouseUp);
                    
                    if (!timelineIsDraggingRef.current) {
                        // Click, not drag
                        console.log('üëÜ Timeline click detected (no movement)');
                        timelineDragTaskRef.current = null;
                        return;
                    }
                    
                    console.log('üèÅ Timeline drag end:', mode);
                    
                    const deltaX = e.clientX - timelineDragStartXRef.current;
                    const timelineWidth = 800;
                    const totalMinutes = 15 * 60;
                    const pixelsPerMinute = timelineWidth / totalMinutes;
                    const minutesDelta = Math.round(deltaX / pixelsPerMinute / 15) * 15;
                    
                    // Convert timeSlot to minutes
                    const timeToMinutes = (timeStr) => {
                        if (!timeStr) return null;
                        const [hours, minutes] = timeStr.split(':').map(Number);
                        return hours * 60 + minutes;
                    };
                    
                    const minutesToTime = (mins) => {
                        const hours = Math.floor(mins / 60);
                        const minutes = mins % 60;
                        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    };
                    
                    // Constants
                    const MIN_TIME_MINUTES = 6 * 60; // 6:00 AM
                    const MAX_TIME_MINUTES = 21 * 60; // 9:00 PM
                    const MIN_DURATION = 15;
                    const MAX_DURATION = 180;
                    
                    if (mode === 'move') {
                        // Move: change timeSlot, keep duration
                        let oldMinutes = timeToMinutes(timelineDragStartTimeRef.current);
                        
                        // SPECIAL CASE: Unscheduled tasks get assigned a default start time
                        if (oldMinutes === null) {
                            oldMinutes = 9 * 60; // Default to 9:00 AM
                            console.log('‚ö†Ô∏è Unscheduled task - assigning default time 9:00 AM');
                        }
                        
                        // Apply drag delta with NO upper limit (work as long as you want!)
                        // Only enforce 6AM minimum start time
                        const newMinutes = Math.max(MIN_TIME_MINUTES, oldMinutes + minutesDelta);
                        const newTimeSlot = minutesToTime(newMinutes);
                        const taskDuration = task.estimatedDuration || 30;
                        
                        console.log('üîß Move:', {
                            oldTime: timelineDragStartTimeRef.current,
                            duration: taskDuration,
                            newTime: newTimeSlot,
                            endTime: minutesToTime(newMinutes + taskDuration)
                        });
                        
                        if (task.isSubtask && task.parentId) {
                            setTasks(prev => prev.map(t => {
                                if (t.id === task.parentId) {
                                    return {
                                        ...t,
                                        subtasks: (t.subtasks || []).map(st =>
                                            st.id === task.originalSubtaskId || st.id === task.id
                                                ? { ...st, timeSlot: newTimeSlot }
                                                : st
                                        )
                                    };
                                }
                                return t;
                            }));
                        } else {
                            setTasks(prev => prev.map(t =>
                                t.id === task.id ? { ...t, timeSlot: newTimeSlot } : t
                            ));
                        }
                        
                        showToast(`Moved to ${newTimeSlot}`, true);
                        
                    } else if (mode === 'resize-start') {
                        // Resize-start: change start time, keep END time fixed
                        let oldStartMinutes = timeToMinutes(timelineDragStartTimeRef.current);
                        
                        // SPECIAL CASE: Unscheduled tasks get assigned a default start time
                        if (oldStartMinutes === null) {
                            oldStartMinutes = 9 * 60; // Default to 9:00 AM
                            console.log('‚ö†Ô∏è Unscheduled task - assigning default time 9:00 AM');
                        }
                        
                        const oldDuration = timelineDragStartDurationRef.current;
                        const oldEndMinutes = oldStartMinutes + oldDuration;
                        
                        // New start = old start + delta (only enforce 6AM minimum)
                        let newStartMinutes = Math.max(MIN_TIME_MINUTES, oldStartMinutes + minutesDelta);
                        
                        // Keep end time fixed, calculate new duration
                        let newDuration = oldEndMinutes - newStartMinutes;
                        newDuration = Math.max(MIN_DURATION, Math.min(MAX_DURATION, newDuration));
                        
                        // If duration hit limit, adjust start time to maintain it
                        if (newDuration === MIN_DURATION) {
                            newStartMinutes = oldEndMinutes - MIN_DURATION;
                        } else if (newDuration === MAX_DURATION) {
                            newStartMinutes = oldEndMinutes - MAX_DURATION;
                        }
                        
                        const newTimeSlot = minutesToTime(newStartMinutes);
                        
                        console.log('üîß Resize-start:', {
                            oldStart: timelineDragStartTimeRef.current,
                            oldDuration,
                            oldEnd: minutesToTime(oldEndMinutes),
                            newStart: newTimeSlot,
                            newDuration,
                            newEnd: minutesToTime(oldEndMinutes)
                        });
                        
                        if (task.isSubtask && task.parentId) {
                            setTasks(prev => prev.map(t => {
                                if (t.id === task.parentId) {
                                    return {
                                        ...t,
                                        subtasks: (t.subtasks || []).map(st =>
                                            st.id === task.originalSubtaskId || st.id === task.id
                                                ? { ...st, timeSlot: newTimeSlot, estimatedDuration: newDuration }
                                                : st
                                        )
                                    };
                                }
                                return t;
                            }));
                        } else {
                            setTasks(prev => prev.map(t =>
                                t.id === task.id ? { ...t, timeSlot: newTimeSlot, estimatedDuration: newDuration } : t
                            ));
                        }
                        
                        showToast(`Resized: ${newTimeSlot} (${newDuration}min)`, true);
                        
                    } else if (mode === 'resize-end') {
                        // Resize-end: change duration only, but clamp to not exceed 9PM
                        let startMinutes = timeToMinutes(timelineDragStartTimeRef.current);
                        
                        // SPECIAL CASE: Unscheduled tasks get assigned a default start time
                        if (startMinutes === null) {
                            startMinutes = 9 * 60; // Default to 9:00 AM
                            console.log('‚ö†Ô∏è Unscheduled task - assigning default time 9:00 AM');
                        }
                        
                        const oldDuration = timelineDragStartDurationRef.current;
                        let newDuration = oldDuration + minutesDelta;
                        
                        // Only clamp to min/max duration (no time-of-day constraint)
                        newDuration = Math.max(MIN_DURATION, Math.min(MAX_DURATION, newDuration));
                        
                        console.log('üîß Resize-end:', {
                            startTime: timelineDragStartTimeRef.current,
                            oldDuration,
                            newDuration,
                            endTime: minutesToTime(startMinutes + newDuration),
                            wasUnscheduled: timelineDragStartTimeRef.current === null
                        });
                        
                        // Calculate new timeSlot (especially for unscheduled tasks)
                        const newTimeSlot = minutesToTime(startMinutes);
                        
                        if (task.isSubtask && task.parentId) {
                            setTasks(prev => prev.map(t => {
                                if (t.id === task.parentId) {
                                    return {
                                        ...t,
                                        subtasks: (t.subtasks || []).map(st =>
                                            st.id === task.originalSubtaskId || st.id === task.id
                                                ? { 
                                                    ...st, 
                                                    timeSlot: newTimeSlot, 
                                                    estimatedDuration: newDuration 
                                                }
                                                : st
                                        )
                                    };
                                }
                                return t;
                            }));
                        } else {
                            setTasks(prev => prev.map(t =>
                                t.id === task.id ? { 
                                    ...t, 
                                    timeSlot: newTimeSlot, 
                                    estimatedDuration: newDuration 
                                } : t
                            ));
                        }
                        
                        showToast(`Scheduled: ${newTimeSlot} (${newDuration}min)`, true);
                    }
                    
                    timelineDragTaskRef.current = null;
                    timelineIsDraggingRef.current = false;
                    setTimelineGhostBar(null); // Clear ghost bar
                };
                // ========== END TIMELINE DRAG HANDLERS ==========
                
                
                return (
                    <div className="bg-white rounded-lg shadow p-4">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-bold">Gantt Chart</h2>
                            <button
                                onClick={() => {
                                    const newTask = {
                                        id: Date.now(),
                                        text: 'New task',
                                        status: 'not-started',
                                        priority: 'medium',
                                        taskType: 'consistency',
                                        persona: personas[0],
                                        project: projects[0]?.name || null,
                                        scheduledDate: today,
                                        dueDate: null,
                                        timeSlot: null,
                                        estimatedDuration: 60,
                                        tags: [],
                                        notes: '',
                                        subtasks: [],
                                        isOldTask: false,
                                        archived: false,
                                        createdAt: new Date().toISOString(),
                                    };
                                    setTasks(prev => [...prev, newTask]);
                                    setQuickEditTask(newTask);
                                    setShowQuickEdit(true);
                                }}
                                className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                            >
                                <Plus size={18} />
                                Add Task
                            </button>
                        </div>
                        
                        {/* Section 1: Today's Tasks with Subtasks */}
                        <div className="mb-8">
                            <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                                <span>üìÖ Today's Tasks & Subtasks</span>
                                <span className="text-sm text-gray-600">({todayWithSubtasks.length})</span>
                            </h3>
                            
                            {todayWithSubtasks.length === 0 ? (
                                <div className="text-center py-8 text-gray-400">
                                    No tasks scheduled for today
                                </div>
                            ) : (
                                <div>
                                    {/* Time axis */}
                                    <div className="flex items-center gap-2 mb-2">
                                        <div className="w-48 text-xs font-semibold">Task</div>
                                        <div className="flex-1 flex justify-between text-xs text-gray-600 px-2">
                                            {['6AM', '9AM', '12PM', '3PM', '6PM', '9PM'].map(time => (
                                                <span key={time}>{time}</span>
                                            ))}
                                        </div>
                                        <div className="w-24 text-xs text-center font-semibold">Project</div>
                                        <div className="w-24 text-xs text-center font-semibold">Persona</div>
                                    </div>
                                    
                                    {/* Tasks on timeline */}
                                    <div className="space-y-1">
                                        {todayWithSubtasks.map(task => {
                                            // Calculate position based on time slot (6AM-9PM range)
                                            // ‚úÖ REFACTORED: Use utility function
                                            const getTimePosition = (timeSlot) => {
                                                if (!timeSlot) return 0;
                                                
                                                const taskMinutes = getTaskStartMinutes({ timeSlot });
                                                if (taskMinutes === null) return 0;
                                                
                                                // Define working hours range: 6AM (360 min) to 9PM (1260 min)
                                                const startMinutes = 6 * 60;
                                                const endMinutes = 21 * 60;
                                                const rangeMinutes = endMinutes - startMinutes;
                                                
                                                // Clamp to range
                                                const clampedMinutes = Math.max(startMinutes, Math.min(endMinutes, taskMinutes));
                                                
                                                // Map to 0-100% position
                                                return ((clampedMinutes - startMinutes) / rangeMinutes) * 100;
                                            };
                                            
                                            const leftPercent = getTimePosition(task.timeSlot);
                                            // Calculate width based on duration (no artificial clamping)
                                            // 900min = 15 hours (6AM-9PM range for DISPLAY, but tasks can extend beyond)
                                            let widthPercent = (task.estimatedDuration || 30) / 9; // 900min / 100 = 9
                                            
                                            // Note: Bars may overlap Project/Persona columns if tasks extend past 9PM
                                            // This is intentional to support unrestricted work hours
                                            
                                            return (
                                                <div key={task.id} className="flex items-center gap-2">
                                                    <div className={`flex-shrink-0 w-48 text-sm truncate ${task.isSubtask ? 'pl-6 text-gray-600' : 'font-medium'}`} title={task.text}>
                                                        {task.isSubtask && '‚îî '}
                                                        {task.text}
                                                    </div>
                                                    <div className="flex-1 relative bg-gray-50 rounded" style={{minHeight: '32px'}}>
                                                        {/* Timeline bar */}
                                                        <div
                                                            className={`absolute h-6 rounded hover:opacity-80 ${getPriorityColor(task.priority)}`}
                                                            style={{
                                                                left: task.timeSlot ? `${leftPercent}%` : '2%',
                                                                width: task.timeSlot ? `${widthPercent}%` : `${Math.min((task.estimatedDuration || 30) / 5, 20)}%`,
                                                                top: '4px',
                                                                userSelect: 'none'
                                                            }}
                                                            onMouseMove={(e) => {
                                                                // Dynamic cursor based on hover position
                                                                if (timelineIsDraggingRef.current) return;
                                                                const rect = e.currentTarget.getBoundingClientRect();
                                                                const hoverX = e.clientX - rect.left;
                                                                const barWidth = rect.width;
                                                                const leftZone = barWidth * 0.2;
                                                                const rightZone = barWidth * 0.8;
                                                                
                                                                if (hoverX < leftZone || hoverX > rightZone) {
                                                                    e.currentTarget.style.cursor = 'ew-resize';
                                                                } else {
                                                                    e.currentTarget.style.cursor = 'grab';
                                                                }
                                                            }}
                                                            onMouseLeave={(e) => {
                                                                e.currentTarget.style.cursor = 'grab';
                                                            }}
                                                            onMouseDown={(e) => {
                                                                e.currentTarget.style.cursor = 'grabbing';
                                                                // Detect which part of bar was clicked for edge detection
                                                                const rect = e.currentTarget.getBoundingClientRect();
                                                                const clickX = e.clientX - rect.left;
                                                                const barWidth = rect.width;
                                                                const leftZone = barWidth * 0.2; // Left 20%
                                                                const rightZone = barWidth * 0.8; // Right 20% starts here
                                                                
                                                                let mode;
                                                                if (clickX < leftZone) {
                                                                    mode = 'resize-start';
                                                                } else if (clickX > rightZone) {
                                                                    mode = 'resize-end';
                                                                } else {
                                                                    mode = 'move';
                                                                }
                                                                
                                                                handleTimelineBarMouseDown(e, task, mode);
                                                            }}
                                                            onClick={(e) => {
                                                                if (timelineIsDraggingRef.current) {
                                                                    // Was dragging, don't open edit
                                                                    return;
                                                                }
                                                                console.log('üîç Today bar clicked:', {
                                                                    id: task.id,
                                                                    text: task.text,
                                                                    isSubtask: task.isSubtask,
                                                                    parentId: task.parentId
                                                                });
                                                                
                                                                try {
                                                                    e.stopPropagation();
                                                                    
                                                                    // FIX Issue 8: Edit subtask directly if it's a subtask
                                                                    if (task.isSubtask && task.parentId) {
                                                                        console.log('  ‚Üí Attempting subtask edit');
                                                                        // Find parent task
                                                                        const parentTask = tasks.find(t => t.id === task.parentId);
                                                                        console.log('  ‚Üí Parent task found:', !!parentTask);
                                                                        if (parentTask) {
                                                                            // Find this specific subtask using original ID
                                                                            const lookupId = task.originalSubtaskId || task.id;
                                                                            console.log('  ‚Üí Looking for subtask ID:', lookupId);
                                                                            const subtaskData = parentTask.subtasks?.find(st => st.id === lookupId);
                                                                            console.log('  ‚Üí Subtask data found:', !!subtaskData);
                                                                            if (subtaskData) {
                                                                                // Create a temporary task object for QuickEdit
                                                                                const subtaskForEdit = {
                                                                                    ...subtaskData,
                                                                                    parentId: parentTask.id,
                                                                                    isSubtask: true,
                                                                                    persona: subtaskData.persona || parentTask.persona,
                                                                                    priority: subtaskData.priority || parentTask.priority,
                                                                                    taskType: subtaskData.taskType || parentTask.taskType,
                                                                                    project: parentTask.project
                                                                                };
                                                                                console.log('üéØ Today: Editing subtask', subtaskForEdit.id, subtaskForEdit.text);
                                                                                setQuickEditTask(subtaskForEdit);
                                                                                setShowQuickEdit(true);
                                                                                console.log('  ‚Üí Modal state set to true');
                                                                            } else {
                                                                                console.log('  ‚ùå Subtask not found in parent.subtasks');
                                                                                console.log('  ‚Üí Parent subtasks:', parentTask.subtasks?.map(st => st.id));
                                                                            }
                                                                        } else {
                                                                            console.log('  ‚ùå Parent task not found');
                                                                        }
                                                                    } else {
                                                                        // Regular task
                                                                        console.log('üéØ Today: Editing task', task.id, task.text);
                                                                        const originalTask = tasks.find(t => t.id === task.id);
                                                                        if (originalTask) {
                                                                            setQuickEditTask({...originalTask});
                                                                            setShowQuickEdit(true);
                                                                        }
                                                                    }
                                                                } catch (err) {
                                                                    console.error('Error in Today click:', err);
                                                                }
                                                            }}
                                                            title={`${task.timeSlot || 'No time'} - ${task.estimatedDuration || 30}min - ${task.priority}`}
                                                        >
                                                            <div className="text-white text-xs px-2 truncate leading-6">
                                                                {task.estimatedDuration || 30}min
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Ghost bar for drag preview */}
                                                        {timelineGhostBar && timelineGhostBar.taskId === task.id && (
                                                            <div
                                                                className={`absolute h-6 rounded ${getPriorityColor(task.priority)}`}
                                                                style={{
                                                                    left: `${timelineGhostBar.leftPercent}%`,
                                                                    width: `${timelineGhostBar.widthPercent}%`,
                                                                    top: '4px',
                                                                    opacity: 0.4,
                                                                    pointerEvents: 'none',
                                                                    border: '2px dashed white'
                                                                }}
                                                            />
                                                        )}
                                                    </div>
                                                    <div className="flex-shrink-0 w-24 text-xs text-gray-600 text-center truncate" title={task.project}>
                                                        {task.project || '-'}
                                                    </div>
                                                    <div className="flex-shrink-0 w-24 text-xs text-gray-600 text-center truncate" title={task.persona}>
                                                        {task.persona}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* Section 2: Tasks by Project/Persona with Full Timeline */}
                        <div>
                            <div className="flex items-center justify-between mb-3">
                                <h3 className="text-lg font-semibold">
                                    üìä All Tasks Planning Area
                                </h3>
                                <div className="flex items-center gap-2 text-sm">
                                    <span className="text-gray-600">Group by:</span>
                                    <button
                                        onClick={() => setGanttGroupBy('project')}
                                        className={`px-3 py-1 rounded ${ganttGroupBy === 'project' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        Project
                                    </button>
                                    <button
                                        onClick={() => setGanttGroupBy('persona')}
                                        className={`px-3 py-1 rounded ${ganttGroupBy === 'persona' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        Persona
                                    </button>
                                </div>
                            </div>
                            
                            {/* Timeline header with dates */}
                            <div className="mb-2 flex items-center gap-2" ref={timelineContainerRef}>
                                <div className="w-56 flex-shrink-0 text-sm font-semibold">Task</div>
                                <div className="flex-1 relative" style={{minHeight: '30px'}}>
                                    <div className="flex justify-between text-xs text-gray-600">
                                        {dateRange.map((date, idx) => {
                                            if (idx % Math.ceil(dateRange.length / 10) === 0 || date === today) {
                                                return (
                                                    <div key={date} className={`${date === today ? 'font-bold text-blue-600' : ''}`}>
                                                        {date === today ? 'üìç TODAY' : (() => {
                                                            const d = new Date(date);
                                                            const day = d.getDate();
                                                            const month = d.toLocaleDateString('en-US', {month: 'short'});
                                                            return `${day} ${month}`;
                                                        })()}
                                                    </div>
                                                );
                                            }
                                            return null;
                                        })}
                                    </div>
                                    {/* Today marker line */}
                                    {dateRange.includes(today) && (
                                        <div 
                                            className="absolute top-0 bottom-0 w-0.5 bg-blue-500 z-10"
                                            style={{
                                                left: `${(dateRange.indexOf(today) / dateRange.length) * 100}%`
                                            }}
                                        />
                                    )}
                                </div>
                                <div className="w-20 flex-shrink-0"></div>
                            </div>
                            
                            {/* Tasks grouped dynamically */}
                            {Object.entries(tasksGrouped).map(([groupName, groupTasks]) => (
                                <div key={groupName} className="mb-6">
                                    <div className="font-semibold text-sm mb-2 text-indigo-700 flex items-center gap-2">
                                        <span>{groupName}</span>
                                        <span className="text-gray-500">({groupTasks.length})</span>
                                    </div>
                                    <div className="space-y-1">
                                        {groupTasks.map(task => (
                                            <div key={task.id}>
                                                {/* Main task row */}
                                                <div className="flex items-center gap-2">
                                                    <div className="w-56 flex-shrink-0 text-sm flex items-center gap-2">
                                                        {/* Status toggle button */}
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                // Use project-specific status cycle
                                                                const newStatus = getNextStatus(task);
                                                                updateTask(task.id, { status: newStatus });
                                                            }}
                                                            className="flex-shrink-0 w-5 h-5 rounded border flex items-center justify-center hover:bg-gray-100 transition-colors"
                                                            title={`Status: ${getStatusIcon(task.status).label} (click to cycle)`}
                                                        >
                                                            {/* Dynamic status icon */}
                                                            <span className={`text-xs ${getStatusIcon(task.status).color}`}>
                                                                {getStatusIcon(task.status).icon}
                                                            </span>
                                                        </button>
                                                        
                                                        {/* Task name */}
                                                        <span className="truncate" title={task.text}>
                                                            {task.text}
                                                        </span>
                                                    </div>
                                                    <div className="flex-1 relative bg-gray-50 rounded" style={{minHeight: '32px'}}>
                                                        <TaskBar task={task} dateRange={dateRange} />
                                                        {/* Today marker line */}
                                                        {dateRange.includes(today) && (
                                                            <div 
                                                                className="absolute top-0 bottom-0 w-0.5 bg-blue-400 opacity-30"
                                                                style={{
                                                                    left: `${(dateRange.indexOf(today) / dateRange.length) * 100}%`
                                                                }}
                                                            />
                                                        )}
                                                    </div>
                                                    <div className="w-20 flex-shrink-0 text-xs text-gray-500">
                                                        {task.scheduledDate || 'Not scheduled'}
                                                    </div>
                                                </div>
                                                
                                                {/* FIX Issues 12-13: Show subtasks inline below */}
                                                {task.subtasks && task.subtasks.length > 0 && (
                                                    <div className="space-y-1 mt-1">
                                                        {task.subtasks.map(subtask => (
                                                            <div key={subtask.id} className="flex items-center gap-2">
                                                                <div className="w-56 flex-shrink-0 text-xs flex items-center gap-2 pl-8">
                                                                    {/* Status toggle for subtask */}
                                                                    <button
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            // Use project-specific status cycle (subtask inherits parent's project)
                                                                            const subtaskWithProject = { ...subtask, project: task.project };
                                                                            const newStatus = getNextStatus(subtaskWithProject);
                                                                            
                                                                            // Update subtask status
                                                                            setTasks(prev => prev.map(t => {
                                                                                if (t.id === task.id) {
                                                                                    return {
                                                                                        ...t,
                                                                                        subtasks: (t.subtasks || []).map(st =>
                                                                                            st.id === subtask.id ? { ...st, status: newStatus } : st
                                                                                        )
                                                                                    };
                                                                                }
                                                                                return t;
                                                                            }));
                                                                        }}
                                                                        className="flex-shrink-0 w-4 h-4 rounded border flex items-center justify-center hover:bg-gray-100 transition-colors"
                                                                        title={`Status: ${getStatusIcon(subtask.status).label} (click to cycle)`}
                                                                    >
                                                                        {/* Dynamic subtask status icon */}
                                                                        <span className={`${getStatusIcon(subtask.status).color}`} style={{fontSize: '10px'}}>
                                                                            {getStatusIcon(subtask.status).icon}
                                                                        </span>
                                                                    </button>
                                                                    
                                                                    <span className="text-gray-600 truncate" title={subtask.text}>
                                                                        ‚îî {subtask.text}
                                                                    </span>
                                                                </div>
                                                                <div className="flex-1 relative bg-gray-100 rounded" style={{minHeight: '24px'}}>
                                                                    <TaskBar task={{...subtask, isSubtask: true, parentId: task.id}} dateRange={dateRange} />
                                                                </div>
                                                                <div className="w-20 flex-shrink-0 text-xs text-gray-400">
                                                                    {subtask.scheduledDate || '-'}
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                
                                                {/* FIX Issues 12-13: Add Subtask button (always visible below task) */}
                                                {!task.isSubtask && (
                                                    <div className="pl-8 mt-1">
                                                        <button
                                                            onClick={() => {
                                                                const newSubtask = {
                                                                    id: Date.now(),
                                                                    text: 'New subtask',
                                                                    taskType: task.taskType,
                                                                    persona: task.persona,
                                                                    priority: task.priority,
                                                                    status: 'not-started',
                                                                    isOldTask: false,
                                                                    notes: '',
                                                                    timeSlot: null,
                                                                    estimatedDuration: 30,
                                                                    scheduledDate: task.scheduledDate,
                                                                    dueDate: null
                                                                };
                                                                
                                                                // Add subtask to parent
                                                                updateTask(task.id, {
                                                                    subtasks: [...(task.subtasks || []), newSubtask]
                                                                });
                                                                
                                                                // Open QuickEdit for immediate editing
                                                                const subtaskForEdit = {
                                                                    ...newSubtask,
                                                                    parentId: task.id,
                                                                    isSubtask: true,
                                                                    project: task.project
                                                                };
                                                                
                                                                console.log('‚úÖ Opening QuickEdit for new subtask');
                                                                setQuickEditTask(subtaskForEdit);
                                                                setShowQuickEdit(true);
                                                            }}
                                                            className="text-xs px-2 py-1 text-blue-600 hover:bg-blue-50 rounded flex items-center gap-1"
                                                            title="Add subtask to this task"
                                                        >
                                                            <Plus size={12} />
                                                            Add Subtask
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                        
                        {/* Legend */}
                        <div className="mt-6 pt-4 border-t flex items-center gap-4 text-xs">
                            <span className="font-semibold">Priority:</span>
                            <div className="flex items-center gap-1"><div className="w-4 h-4 bg-red-500 rounded"></div> Urgent</div>
                            <div className="flex items-center gap-1"><div className="w-4 h-4 bg-orange-500 rounded"></div> High</div>
                            <div className="flex items-center gap-1"><div className="w-4 h-4 bg-yellow-500 rounded"></div> Medium</div>
                            <div className="flex items-center gap-1"><div className="w-4 h-4 bg-green-500 rounded"></div> Low</div>
                        </div>
                    </div>
                );
            };

            // Persona View
            const PersonaView = () => {
                const [showAddPersona, setShowAddPersona] = useState(false);
                const [newPersonaName, setNewPersonaName] = useState('');
                
                const handleAddPersona = () => {
                    if (newPersonaName.trim() && !personas.includes(newPersonaName.trim())) {
                        setPersonas([...personas, newPersonaName.trim()]);
                        setNewPersonaName('');
                        setShowAddPersona(false);
                        showToast('Persona added', true);
                    }
                };
                
                return (
                    <div className="space-y-4">
                        {/* Add Persona Button */}
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">Personas</h2>
                            {!showAddPersona ? (
                                <button
                                    onClick={() => setShowAddPersona(true)}
                                    className="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 text-sm font-medium"
                                >
                                    + Add Persona
                                </button>
                            ) : (
                                <div className="flex gap-2">
                                    <input
                                        type="text"
                                        value={newPersonaName}
                                        onChange={(e) => setNewPersonaName(e.target.value)}
                                        onKeyPress={(e) => e.key === 'Enter' && handleAddPersona()}
                                        placeholder="Enter persona name"
                                        className="px-3 py-2 border rounded text-sm"
                                        autoFocus
                                    />
                                    <button
                                        onClick={handleAddPersona}
                                        className="px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm"
                                    >
                                        Save
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowAddPersona(false);
                                            setNewPersonaName('');
                                        }}
                                        className="px-3 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 text-sm"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            )}
                        </div>
                        
                        {personas.map(persona => {
                            const personaTasks = tasks.filter(t => t.persona === persona && !t.archived);
                            const completed = personaTasks.filter(t => t.status === 'completed').length;
                            const totalPoints = personaTasks.reduce((sum, t) => sum + calculateTaskScore(t), 0);
                            
                            return (
                                <div key={persona} className="bg-white rounded-lg shadow p-4">
                                    <div className="flex justify-between items-center mb-3">
                                        <h3 className="text-lg font-bold">{persona}</h3>
                                        <div className="text-sm text-gray-600">
                                            {completed}/{personaTasks.length} tasks ‚Ä¢ {totalPoints} points
                                        </div>
                                    </div>
                                    
                                    <div
                                        className="space-y-2"
                                        data-drop-zone="persona"
                                        data-drop-data={JSON.stringify({ persona })}
                                        onDragOver={(e) => handleDragOver(e, 'persona', { persona })}
                                        onDrop={(e) => handleDrop(e, 'persona', { persona })}
                                        style={{
                                            backgroundColor: (dragOverZone?.zone === 'persona' && dragOverZone?.data?.persona === persona) ||
                                                           (currentDropZone?.type === 'persona' && JSON.parse(currentDropZone?.data || '{}').persona === persona) ?
                                                           'rgba(99, 102, 241, 0.05)' : undefined,
                                            minHeight: '60px'
                                        }}
                                    >
                                        {personaTasks.length === 0 ? (
                                            <p className="text-gray-400 text-center py-4">No tasks</p>
                                        ) : (
                                            personaTasks.map(task => (
                                                <TaskCard key={task.id} task={task} location="persona" showDate={true} />
                                            ))
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                );
            };

            // Project Kanban View
            const ProjectView = () => {
                // Default status labels for all possible statuses
                const getStatusLabel = (status) => {
                    const labels = {
                        'not-started': 'Not Started',
                        'in-progress': 'In Progress',
                        'completed': 'Completed',
                        'to-do': 'To Do',
                        'awaiting-discussion': 'Awaiting Discussion / Inputs',
                        'delayed-parked': 'Delayed or Parked',
                        'done': 'Done'
                    };
                    return labels[status] || status.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                };
                
                const [editingProjectId, setEditingProjectId] = useState(null);
                const [newStatusName, setNewStatusName] = useState('');

                return (
                    <div className="space-y-4">
                        {/* Add Project Button */}
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">Projects</h2>
                            <button
                                onClick={() => {
                                    const projectName = prompt('Enter new project name:');
                                    if (projectName && projectName.trim()) {
                                        const newProject = {
                                            id: Date.now(),
                                            name: projectName.trim(),
                                            status: 0,
                                            color: '#6366f1',
                                            statuses: ['not-started', 'in-progress', 'completed']
                                        };
                                        setProjects(prev => [...prev, newProject]);
                                        showToast('Project created!', true);
                                    }
                                }}
                                className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                            >
                                <Plus size={18} />
                                Add Project
                            </button>
                        </div>
                        
                        {projects.filter(p => !p.isNoProject).map(project => {
                            const projectTasks = tasks.filter(t => t.project === project.name && !t.archived);
                            const projectStatuses = project.statuses || ['not-started', 'in-progress', 'completed'];
                            
                            return (
                                <div key={project.id} className="bg-white rounded-lg shadow p-4">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-bold">{project.name}</h3>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => setEditingProjectId(editingProjectId === project.id ? null : project.id)}
                                                className="text-xs px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded"
                                                title="Customize statuses"
                                            >
                                                ‚öôÔ∏è Statuses
                                            </button>
                                            <div className="text-sm text-gray-600">{project.status}%</div>
                                            <div className="w-32 h-2 bg-gray-200 rounded-full overflow-hidden">
                                                <div
                                                    className="h-full bg-indigo-600"
                                                    style={{ width: `${project.status}%` }}
                                                />
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {editingProjectId === project.id && (
                                        <div className="mb-4 p-3 bg-blue-50 rounded border border-blue-200">
                                            <h4 className="font-semibold text-sm mb-2">Custom Statuses (drag to reorder)</h4>
                                            <div className="flex flex-wrap gap-2 mb-2">
                                                {projectStatuses.map((status, idx) => (
                                                    <span 
                                                        key={idx} 
                                                        className="px-2 py-1 bg-white border rounded text-sm flex items-center gap-1 cursor-move hover:shadow"
                                                        draggable="true"
                                                        onDragStart={(e) => {
                                                            e.dataTransfer.effectAllowed = 'move';
                                                            e.dataTransfer.setData('text/plain', idx.toString());
                                                        }}
                                                        onDragOver={(e) => {
                                                            e.preventDefault();
                                                            e.currentTarget.style.borderColor = '#6366f1';
                                                        }}
                                                        onDragLeave={(e) => {
                                                            e.currentTarget.style.borderColor = '';
                                                        }}
                                                        onDrop={(e) => {
                                                            e.preventDefault();
                                                            e.currentTarget.style.borderColor = '';
                                                            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                            const toIdx = idx;
                                                            if (fromIdx !== toIdx) {
                                                                const newStatuses = [...projectStatuses];
                                                                const [moved] = newStatuses.splice(fromIdx, 1);
                                                                newStatuses.splice(toIdx, 0, moved);
                                                                setProjects(prev => prev.map(p => 
                                                                    p.id === project.id ? {...p, statuses: newStatuses} : p
                                                                ));
                                                            }
                                                        }}
                                                    >
                                                        ‚ãÆ‚ãÆ {getStatusLabel(status)}
                                                        {projectStatuses.length > 1 && (
                                                            <button
                                                                onClick={() => {
                                                                    const newStatuses = projectStatuses.filter((_, i) => i !== idx);
                                                                    setProjects(prev => prev.map(p => 
                                                                        p.id === project.id ? {...p, statuses: newStatuses} : p
                                                                    ));
                                                                }}
                                                                className="text-red-600 hover:text-red-800"
                                                            >
                                                                √ó
                                                            </button>
                                                        )}
                                                    </span>
                                                ))}
                                            </div>
                                            <div className="flex gap-2">
                                                <input
                                                    type="text"
                                                    placeholder="New status (e.g., review-needed)"
                                                    value={newStatusName}
                                                    onChange={(e) => setNewStatusName(e.target.value)}
                                                    className="flex-1 px-2 py-1 border rounded text-sm"
                                                    onKeyPress={(e) => {
                                                        if (e.key === 'Enter' && newStatusName.trim()) {
                                                            const statusId = newStatusName.toLowerCase().replace(/\s+/g, '-');
                                                            setProjects(prev => prev.map(p =>
                                                                p.id === project.id 
                                                                    ? {...p, statuses: [...projectStatuses, statusId]}
                                                                    : p
                                                            ));
                                                            setNewStatusName('');
                                                        }
                                                    }}
                                                />
                                                <button
                                                    onClick={() => {
                                                        if (newStatusName.trim()) {
                                                            const statusId = newStatusName.toLowerCase().replace(/\s+/g, '-');
                                                            setProjects(prev => prev.map(p =>
                                                                p.id === project.id 
                                                                    ? {...p, statuses: [...projectStatuses, statusId]}
                                                                    : p
                                                            ));
                                                            setNewStatusName('');
                                                        }
                                                    }}
                                                    className="px-3 py-1 bg-indigo-600 text-white rounded text-sm hover:bg-indigo-700"
                                                >
                                                    Add
                                                </button>
                                            </div>
                                            <p className="text-xs text-gray-600 mt-1">Use lowercase with hyphens (e.g., "review-needed")</p>
                                        </div>
                                    )}

                                    <div className={`grid gap-4`} style={{
                                        gridTemplateColumns: `repeat(${projectStatuses.length}, minmax(250px, 1fr))`,
                                        overflowX: 'auto'
                                    }}>
                                        {projectStatuses.map(status => {
                                            const statusTasks = projectTasks.filter(t => t.status === status);
                                            
                                            return (
                                                <div
                                                    key={status}
                                                    className="bg-gray-50 rounded-lg p-3"
                                                    data-drop-zone="kanban-column"
                                                    data-drop-data={JSON.stringify({ status, projectId: project.id, project: project.name })}
                                                    onDragOver={(e) => handleDragOver(e, 'kanban-column', { status })}
                                                    onDrop={(e) => handleDrop(e, 'kanban-column', { status })}
                                                    style={{
                                                        backgroundColor: (dragOverZone?.zone === 'kanban-column' && dragOverZone?.data?.status === status) ||
                                                                       (currentDropZone?.type === 'kanban-column' && JSON.parse(currentDropZone?.data || '{}').status === status) ?
                                                                       'rgba(99, 102, 241, 0.1)' : undefined,
                                                        minHeight: '100px',
                                                        minWidth: '250px',
                                                        wordWrap: 'break-word',
                                                        overflowWrap: 'break-word'
                                                    }}
                                                >
                                                    <div className="flex items-center justify-between mb-2">
                                                        <h4 className="font-semibold text-sm">
                                                            {getStatusLabel(status)} ({statusTasks.length})
                                                        </h4>
                                                        <button
                                                            onClick={async () => {
                                                                // V2.6.1-FIX: Use createTask() to properly save to Supabase
                                                                const newTask = await createTask({
                                                                    text: 'New task',
                                                                    status: status,
                                                                    priority: 'medium',
                                                                    taskType: 'consistency',
                                                                    persona: personas[0],
                                                                    project: project.name,
                                                                    scheduledDate: null,
                                                                    dueDate: null,
                                                                    timeSlot: null,
                                                                    estimatedDuration: null,
                                                                    tags: [],
                                                                    notes: '',
                                                                    subtasks: [],
                                                                });
                                                                // Edit the task immediately
                                                                setEditingTask(newTask.id);
                                                            }}
                                                            className="text-indigo-600 hover:text-indigo-800 hover:bg-indigo-50 rounded p-1"
                                                            title="Add task"
                                                        >
                                                            <Plus size={18} />
                                                        </button>
                                                    </div>
                                                    <div className="space-y-2">
                                                        {statusTasks.map(task => (
                                                            <TaskCard key={task.id} task={task} location="kanban" />
                                                        ))}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                        
                        {/* "No Project" Section - Shows unassigned tasks */}
                        {(() => {
                            const noProjectTasks = tasks.filter(t => t.project === null && !t.archived);
                            const noProjectPseudo = projects.find(p => p.isNoProject);
                            const noProjectStatuses = noProjectPseudo?.statuses || ['not-started', 'in-progress', 'completed'];
                            
                            console.log('üîç No Project Section Render:', {
                                noProjectPseudo,
                                noProjectStatuses,
                                editingProjectId,
                                tasksCount: noProjectTasks.length
                            });
                            
                            // Only show section if there are unassigned tasks
                            if (noProjectTasks.length === 0) return null;
                            
                            return (
                                <div className="bg-white rounded-lg shadow p-4 border-2 border-dashed border-gray-300">
                                    <div className="flex justify-between items-center mb-4">
                                        <div className="flex items-center gap-2">
                                            <h3 className="text-lg font-bold text-gray-600">üìã No Project</h3>
                                            <span className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">
                                                {noProjectTasks.length} unassigned {noProjectTasks.length === 1 ? 'task' : 'tasks'}
                                            </span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => {
                                                    console.log('‚öôÔ∏è Statuses button clicked, current editingProjectId:', editingProjectId);
                                                    setEditingProjectId(editingProjectId === 'no-project' ? null : 'no-project');
                                                }}
                                                className="text-xs px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded"
                                                title="Customize statuses"
                                            >
                                                ‚öôÔ∏è Statuses
                                            </button>
                                            <div className="text-xs text-gray-500 italic">
                                                Drag tasks here to remove project assignment
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {editingProjectId === 'no-project' && (
                                        <div className="mb-4 p-3 bg-blue-50 rounded border border-blue-200">
                                            <h4 className="font-semibold text-sm mb-2">Custom Statuses (drag to reorder)</h4>
                                            <div className="flex flex-wrap gap-2 mb-2">
                                                {noProjectStatuses.map((status, idx) => (
                                                    <span 
                                                        key={idx} 
                                                        className="px-2 py-1 bg-white border rounded text-sm flex items-center gap-1 cursor-move hover:shadow"
                                                        draggable="true"
                                                        onDragStart={(e) => {
                                                            e.dataTransfer.effectAllowed = 'move';
                                                            e.dataTransfer.setData('text/plain', idx.toString());
                                                        }}
                                                        onDragOver={(e) => {
                                                            e.preventDefault();
                                                            e.currentTarget.style.borderColor = '#6366f1';
                                                        }}
                                                        onDragLeave={(e) => {
                                                            e.currentTarget.style.borderColor = '';
                                                        }}
                                                        onDrop={(e) => {
                                                            e.preventDefault();
                                                            e.currentTarget.style.borderColor = '';
                                                            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                            const toIdx = idx;
                                                            if (fromIdx !== toIdx) {
                                                                setProjects(prev => prev.map(p => {
                                                                    if (p.isNoProject) {
                                                                        const currentStatuses = [...(p.statuses || ['not-started', 'in-progress', 'completed'])];
                                                                        const [moved] = currentStatuses.splice(fromIdx, 1);
                                                                        currentStatuses.splice(toIdx, 0, moved);
                                                                        console.log('üîÑ Reordering statuses:', currentStatuses);
                                                                        return {...p, statuses: currentStatuses};
                                                                    }
                                                                    return p;
                                                                }));
                                                            }
                                                        }}
                                                    >
                                                        ‚ãÆ‚ãÆ {getStatusLabel(status)}
                                                        {noProjectStatuses.length > 1 && (
                                                            <button
                                                                onClick={() => {
                                                                    setProjects(prev => prev.map(p => {
                                                                        if (p.isNoProject) {
                                                                            const currentStatuses = p.statuses || ['not-started', 'in-progress', 'completed'];
                                                                            const newStatuses = currentStatuses.filter((_, i) => i !== idx);
                                                                            console.log('‚ùå Removing status at index:', idx, 'new statuses:', newStatuses);
                                                                            return {...p, statuses: newStatuses};
                                                                        }
                                                                        return p;
                                                                    }));
                                                                }}
                                                                className="text-red-600 hover:text-red-800"
                                                            >
                                                                √ó
                                                            </button>
                                                        )}
                                                    </span>
                                                ))}
                                            </div>
                                            <div className="flex gap-2">
                                                <input
                                                    type="text"
                                                    placeholder="New status (e.g., review-needed)"
                                                    value={newStatusName}
                                                    onChange={(e) => setNewStatusName(e.target.value)}
                                                    className="flex-1 px-2 py-1 border rounded text-sm"
                                                    onKeyPress={(e) => {
                                                        if (e.key === 'Enter' && newStatusName.trim()) {
                                                            e.preventDefault();
                                                            const statusId = newStatusName.toLowerCase().replace(/\s+/g, '-');
                                                            setProjects(prev => prev.map(p => {
                                                                if (p.isNoProject) {
                                                                    const currentStatuses = p.statuses || ['not-started', 'in-progress', 'completed'];
                                                                    console.log('üéØ Adding status:', statusId, 'to current:', currentStatuses);
                                                                    return {...p, statuses: [...currentStatuses, statusId]};
                                                                }
                                                                return p;
                                                            }));
                                                            setNewStatusName('');
                                                        }
                                                    }}
                                                />
                                                <button
                                                    onClick={() => {
                                                        console.log('üñ±Ô∏è Add button clicked, newStatusName:', newStatusName);
                                                        if (newStatusName.trim()) {
                                                            const statusId = newStatusName.toLowerCase().replace(/\s+/g, '-');
                                                            console.log('üìù Processing add, statusId:', statusId);
                                                            setProjects(prev => {
                                                                console.log('üîÑ setProjects updater called, prev:', prev);
                                                                return prev.map(p => {
                                                                    if (p.isNoProject) {
                                                                        const currentStatuses = p.statuses || ['not-started', 'in-progress', 'completed'];
                                                                        console.log('üéØ Adding status:', statusId, 'to current:', currentStatuses);
                                                                        return {...p, statuses: [...currentStatuses, statusId]};
                                                                    }
                                                                    return p;
                                                                });
                                                            });
                                                            setNewStatusName('');
                                                        } else {
                                                            console.log('‚ö†Ô∏è Cannot add: newStatusName is empty or whitespace');
                                                        }
                                                    }}
                                                    className="px-3 py-1 bg-indigo-600 text-white rounded text-sm hover:bg-indigo-700"
                                                >
                                                    Add
                                                </button>
                                            </div>
                                            <p className="text-xs text-gray-600 mt-1">Use lowercase with hyphens (e.g., "review-needed")</p>
                                        </div>
                                    )}
                                    
                                    <div className={`grid gap-4`} style={{
                                        gridTemplateColumns: `repeat(${noProjectStatuses.length}, minmax(250px, 1fr))`,
                                        overflowX: 'auto'
                                    }}>
                                        {noProjectStatuses.map(status => {
                                            const statusTasks = noProjectTasks.filter(t => t.status === status);
                                            
                                            return (
                                                <div
                                                    key={status}
                                                    className="bg-gray-50 rounded-lg p-3 border border-gray-200"
                                                    data-drop-zone="kanban-column"
                                                    data-drop-data={JSON.stringify({ status, projectId: null, project: null })}
                                                    onDragOver={(e) => handleDragOver(e, 'kanban-column', { status })}
                                                    onDrop={(e) => handleDrop(e, 'kanban-column', { status })}
                                                    style={{
                                                        backgroundColor: (dragOverZone?.zone === 'kanban-column' && dragOverZone?.data?.status === status) ||
                                                                       (currentDropZone?.type === 'kanban-column' && JSON.parse(currentDropZone?.data || '{}').status === status) ?
                                                                       'rgba(99, 102, 241, 0.1)' : undefined,
                                                        minHeight: '100px',
                                                        minWidth: '250px',
                                                        wordWrap: 'break-word',
                                                        overflowWrap: 'break-word'
                                                    }}
                                                >
                                                    <div className="flex items-center justify-between mb-2">
                                                        <h4 className="font-semibold text-sm text-gray-600">
                                                            {getStatusLabel(status)} ({statusTasks.length})
                                                        </h4>
                                                        <button
                                                            onClick={async () => {
                                                                // V2.6.1-FIX: Use createTask() to properly save to Supabase
                                                                const newTask = await createTask({
                                                                    text: 'New task',
                                                                    status: status,
                                                                    priority: 'medium',
                                                                    taskType: 'consistency',
                                                                    persona: personas[0],
                                                                    project: null, // No project assigned
                                                                    scheduledDate: null,
                                                                    dueDate: null,
                                                                    timeSlot: null,
                                                                    estimatedDuration: null,
                                                                    tags: [],
                                                                    notes: '',
                                                                    subtasks: [],
                                                                });
                                                                // Edit the task immediately
                                                                setEditingTask(newTask.id);
                                                            }}
                                                            className="text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded p-1"
                                                            title="Add unassigned task"
                                                        >
                                                            <Plus size={18} />
                                                        </button>
                                                    </div>
                                                    <div className="space-y-2">
                                                        {statusTasks.map(task => (
                                                            <TaskCard key={task.id} task={task} location="kanban" />
                                                        ))}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })()}
                    </div>
                );
            };

            // ====== V2.11.6: COMPLETION ZONE VIEW ======
            const CompletionZoneView = () => {
                // Get tasks in completion zone (still count in scores but hidden from views)
                const completionZoneTasks = tasks.filter(t => t.inCompletionZone === true);
                const activeCompletedTasks = tasks.filter(t => t.status === 'completed' && !t.inCompletionZone && !t.archived);
                
                return (
                    <div className="space-y-6">
                        {/* Header */}
                        <div className="bg-gradient-to-r from-yellow-50 to-amber-50 rounded-lg p-6 border border-yellow-200">
                            <div className="flex items-center gap-3 mb-2">
                                <Trophy size={32} className="text-yellow-600" />
                                <h2 className="text-2xl font-bold text-gray-900">Completion Zone</h2>
                            </div>
                            <p className="text-gray-600 text-sm">
                                Completed tasks stored here still contribute to your points but stay out of your active views. 
                                Move tasks here to focus on what's next while preserving your achievements.
                            </p>
                        </div>
                        
                        {/* Stats */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div className="bg-yellow-50 rounded-lg p-4 border border-yellow-200">
                                <div className="text-sm text-gray-600 mb-1">In Completion Zone</div>
                                <div className="text-3xl font-bold text-yellow-900">{completionZoneTasks.length}</div>
                            </div>
                            <div className="bg-green-50 rounded-lg p-4 border border-green-200">
                                <div className="text-sm text-gray-600 mb-1">Active Completed</div>
                                <div className="text-3xl font-bold text-green-900">{activeCompletedTasks.length}</div>
                            </div>
                            <div className="bg-purple-50 rounded-lg p-4 border border-purple-200">
                                <div className="text-sm text-gray-600 mb-1">Total Points from Zone</div>
                                <div className="text-3xl font-bold text-purple-900">
                                    {completionZoneTasks.reduce((sum, t) => sum + calculateTaskScore(t), 0)}
                                </div>
                            </div>
                        </div>
                        
                        {/* Tasks in completion zone */}
                        {completionZoneTasks.length > 0 ? (
                            <div className="bg-white rounded-lg shadow overflow-hidden">
                                <div className="px-6 py-4 bg-gray-50 border-b border-gray-200">
                                    <h3 className="font-semibold text-gray-900">Tasks in Completion Zone</h3>
                                </div>
                                <div className="divide-y divide-gray-200">
                                    {completionZoneTasks.map(task => (
                                        <div key={task.id} className="p-4 hover:bg-gray-50">
                                            <div className="flex items-center justify-between">
                                                <div className="flex items-center gap-3 flex-1">
                                                    <CheckCircle size={20} className="text-green-600 flex-shrink-0" />
                                                    <div className="flex-1">
                                                        <div className="text-gray-900">{task.text}</div>
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            {task.taskType && <span className="mr-2">üìã {task.taskType}</span>}
                                                            {task.completedAt && <span>‚úÖ {new Date(task.completedAt).toLocaleDateString()}</span>}
                                                            <span className="ml-2 font-semibold text-purple-600">{calculateTaskScore(task)} pts</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <button
                                                    onClick={() => toggleCompletionZone(task.id)}
                                                    className="px-3 py-1 text-sm bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
                                                >
                                                    Restore
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ) : (
                            <div className="bg-gray-50 rounded-lg p-12 text-center">
                                <Trophy size={48} className="text-gray-400 mx-auto mb-3" />
                                <p className="text-gray-600">No tasks in completion zone yet.</p>
                                <p className="text-sm text-gray-500 mt-2">
                                    Complete tasks and click the trophy icon üèÜ to move them here.
                                </p>
                            </div>
                        )}
                        
                        {/* Active completed tasks (can be moved to zone) */}
                        {activeCompletedTasks.length > 0 && (
                            <div className="bg-white rounded-lg shadow overflow-hidden">
                                <div className="px-6 py-4 bg-green-50 border-b border-green-200">
                                    <h3 className="font-semibold text-gray-900">Recently Completed (Click üèÜ to move to zone)</h3>
                                </div>
                                <div className="divide-y divide-gray-200">
                                    {activeCompletedTasks.slice(0, 10).map(task => (
                                        <div key={task.id} className="p-4 hover:bg-gray-50">
                                            <div className="flex items-center justify-between">
                                                <div className="flex items-center gap-3 flex-1">
                                                    <CheckCircle size={20} className="text-green-600 flex-shrink-0" />
                                                    <div className="flex-1">
                                                        <div className="text-gray-900">{task.text}</div>
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            {task.completedAt && <span>‚úÖ {new Date(task.completedAt).toLocaleDateString()}</span>}
                                                            <span className="ml-2 font-semibold text-purple-600">{calculateTaskScore(task)} pts</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <button
                                                    onClick={() => toggleCompletionZone(task.id)}
                                                    className="p-2 hover:bg-yellow-100 rounded-lg transition-colors"
                                                    title="Move to Completion Zone"
                                                >
                                                    <Trophy size={20} className="text-yellow-600" />
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            // ====== V2.11.0: ANALYTICS VIEW ======
            const AnalyticsView = () => {
                const [timeRange, setTimeRange] = useState('month');
                const [expandedCard, setExpandedCard] = useState(null);  // V2.11.6: Track which card is expanded
                
                // Helper: Check if date is in selected range
                const isInRange = (date) => {
                    if (!date) return false;
                    const taskDate = new Date(date);
                    const now = new Date();
                    
                    switch (timeRange) {
                        case 'today':
                            return taskDate.toDateString() === now.toDateString();
                        case 'week':
                            const weekAgo = new Date(now);
                            weekAgo.setDate(now.getDate() - 7);
                            return taskDate >= weekAgo;
                        case 'month':
                            const monthAgo = new Date(now);
                            monthAgo.setMonth(now.getMonth() - 1);
                            return taskDate >= monthAgo;
                        case 'quarter':
                            const quarterAgo = new Date(now);
                            quarterAgo.setMonth(now.getMonth() - 3);
                            return taskDate >= quarterAgo;
                        case 'year':
                            const yearAgo = new Date(now);
                            yearAgo.setFullYear(now.getFullYear() - 1);
                            return taskDate >= yearAgo;
                        case 'all':
                            return true;
                        default:
                            return false;
                    }
                };
                
                // Calculate analytics
                const analytics = useMemo(() => {
                    // V2.11.4: Match homepage logic exactly
                    // Filter out archived tasks
                    const activeTasks = tasks.filter(t => !t.archived);
                    
                    // Total Tasks: ALL active (non-archived) tasks
                    const totalTasks = activeTasks.length;
                    
                    // Completed Tasks: ALL completed active tasks
                    const completedTasks = activeTasks.filter(t => t.status === 'completed').length;
                    
                    // Total Points: Use SAME logic as homepage (calculateTaskScore)
                    // This includes:
                    // - Base points (completed=2-5, in-progress=1, not-started=0)
                    // - Early completion bonuses (up to 2x multiplier)
                    // - Priority rating (0-10)
                    const totalPoints = activeTasks.reduce((sum, task) => {
                        let score = calculateTaskScore(task);
                        // Include subtasks
                        if (task.subtasks) {
                            task.subtasks.forEach(st => score += calculateTaskScore(st));
                        }
                        return sum + score;
                    }, 0);
                    
                    // Calculate streak (consecutive days with completed tasks)
                    const calculateStreak = () => {
                        const completedByDate = {};
                        tasks.filter(t => t.status === 'completed').forEach(task => {
                            const date = new Date(task.updated_at || task.created_at).toDateString();
                            completedByDate[date] = true;
                        });
                        
                        let streak = 0;
                        const today = new Date();
                        
                        for (let i = 0; i < 365; i++) {
                            const checkDate = new Date(today);
                            checkDate.setDate(today.getDate() - i);
                            const dateStr = checkDate.toDateString();
                            
                            if (completedByDate[dateStr]) {
                                streak++;
                            } else if (i > 0) {
                                // Stop if we hit a day with no completions (but allow today to be empty)
                                break;
                            }
                        }
                        
                        return streak;
                    };
                    
                    const streak = calculateStreak();
                    
                    return {
                        totalTasks,
                        completedTasks,
                        totalPoints,
                        streak
                    };
                }, [tasks]);  // V2.11.3: Removed timeRange dependency
                
                return (
                    <div className="bg-white rounded-lg shadow p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold text-gray-900">üìä Analytics Dashboard</h2>
                            
                            {/* Time Range Filter */}
                            <div className="flex flex-col items-end gap-1">
                                <select
                                    value={timeRange}
                                    onChange={(e) => setTimeRange(e.target.value)}
                                    className="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                >
                                    <option value="today">Today</option>
                                    <option value="week">This Week</option>
                                    <option value="month">This Month</option>
                                    <option value="quarter">This Quarter</option>
                                    <option value="year">This Year</option>
                                    <option value="all">All Time</option>
                                </select>
                                <div className="text-xs text-gray-500 italic">For charts in Phase 2</div>
                            </div>
                        </div>
                        
                        {/* Overview Cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            {/* Total Tasks Card */}
                            <div 
                                className="bg-gradient-to-br from-blue-50 to-blue-100 rounded-lg p-6 border border-blue-200 cursor-pointer hover:shadow-lg transition-shadow"
                                onClick={() => console.log('üìä Deep dive: Total Tasks - Coming in Phase 2!')}
                            >
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-semibold text-blue-700 uppercase">Total Tasks</h3>
                                    <List size={20} className="text-blue-600" />
                                </div>
                                <div className="text-3xl font-bold text-blue-900">{analytics.totalTasks}</div>
                                <div className="text-xs text-blue-600 mt-1">All time ‚Ä¢ Click for details</div>
                            </div>
                            
                            {/* Completed Tasks Card */}
                            <div 
                                className="bg-gradient-to-br from-green-50 to-green-100 rounded-lg p-6 border border-green-200 cursor-pointer hover:shadow-lg transition-shadow"
                                onClick={() => console.log('üìä Deep dive: Completed Tasks - Coming in Phase 2!')}
                            >
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-semibold text-green-700 uppercase">Completed</h3>
                                    <CheckCircle size={20} className="text-green-600" />
                                </div>
                                <div className="text-3xl font-bold text-green-900">{analytics.completedTasks}</div>
                                <div className="text-xs text-green-600 mt-1">
                                    {analytics.totalTasks > 0 
                                        ? `${Math.round((analytics.completedTasks / analytics.totalTasks) * 100)}% ‚Ä¢ Click for details`
                                        : 'No tasks yet'
                                    }
                                </div>
                            </div>
                            
                            {/* Total Points Card */}
                            <div 
                                className="bg-gradient-to-br from-purple-50 to-purple-100 rounded-lg p-6 border border-purple-200 cursor-pointer hover:shadow-lg transition-shadow"
                                onClick={() => console.log('üìä Deep dive: Points Breakdown - Coming in Phase 2!')}
                            >
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-semibold text-purple-700 uppercase">Total Points</h3>
                                    <Target size={20} className="text-purple-600" />
                                </div>
                                <div className="text-3xl font-bold text-purple-900">{analytics.totalPoints}</div>
                                <div className="text-xs text-purple-600 mt-1">
                                    Status + bonuses + priority ‚Ä¢ Click for details
                                </div>
                            </div>
                            
                            {/* Streak Card */}
                            <div 
                                className="bg-gradient-to-br from-orange-50 to-orange-100 rounded-lg p-6 border border-orange-200 cursor-pointer hover:shadow-lg transition-shadow"
                                onClick={() => console.log('üìä Deep dive: Streak History - Coming in Phase 2!')}
                            >
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-semibold text-orange-700 uppercase">Streak</h3>
                                    <TrendingUp size={20} className="text-orange-600" />
                                </div>
                                <div className="text-3xl font-bold text-orange-900">{analytics.streak}</div>
                                <div className="text-xs text-orange-600 mt-1">
                                    {analytics.streak === 1 ? 'day' : 'days'} consecutive ‚Ä¢ Click for details
                                </div>
                            </div>
                        </div>
                        
                        {/* Points Calculation Breakdown */}
                        <div className="bg-white rounded-lg shadow p-6 mb-8">
                            <h3 className="text-lg font-semibold text-gray-900 mb-4">üìä How Points Are Calculated</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                <div className="space-y-2">
                                    <div className="font-semibold text-gray-700">Base Points (by status & type):</div>
                                    <div className="pl-4 space-y-1 text-gray-600">
                                        <div>‚úÖ Completed (Growth): <span className="font-semibold">5 pts</span></div>
                                        <div>‚úÖ Completed (Consistency): <span className="font-semibold">3 pts</span></div>
                                        <div>‚úÖ Completed (Old/Other): <span className="font-semibold">2 pts</span></div>
                                        <div>üîÑ In Progress: <span className="font-semibold">1 pt</span></div>
                                        <div>‚≠ï Not Started: <span className="font-semibold">0 pts</span></div>
                                    </div>
                                </div>
                                <div className="space-y-2">
                                    <div className="font-semibold text-gray-700">Bonuses & Additions:</div>
                                    <div className="pl-4 space-y-1 text-gray-600">
                                        <div>üéØ Priority Rating: <span className="font-semibold">+0-10 pts</span></div>
                                        <div>‚è∞ On Time: <span className="font-semibold">√ó1.5 (50% bonus)</span></div>
                                        <div>üìÖ 1 Day Early: <span className="font-semibold">√ó1.75 (75% bonus)</span></div>
                                        <div>üöÄ 2+ Days Early: <span className="font-semibold">√ó2.0 (100% bonus)</span></div>
                                    </div>
                                </div>
                            </div>
                            <div className="mt-4 pt-4 border-t border-gray-200">
                                <div className="text-xs text-gray-500 italic">
                                    ‚ÑπÔ∏è Archived tasks are excluded ‚Ä¢ Subtasks contribute to total ‚Ä¢ Homepage shows Today/Week/Month scores
                                </div>
                            </div>
                        </div>
                        
                        {/* Coming Soon - Charts */}
                        <div className="bg-gray-50 rounded-lg p-8 text-center">
                            <BarChart2 size={48} className="text-gray-400 mx-auto mb-4" />
                            <h3 className="text-lg font-semibold text-gray-700 mb-2">More Analytics Coming Soon</h3>
                            <p className="text-gray-600 text-sm">
                                Phase 2: Completion trends, Priority distribution<br />
                                Phase 3: Persona balance, Project progress, Activity heatmap<br />
                                Phase 4: Device analytics with cross-device insights
                            </p>
                        </div>
                    </div>
                );
            };

            // ====== MAIN LAYOUT ======
            
            // Show loading spinner while checking auth
            if (authLoading) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-indigo-600 mx-auto mb-4"></div>
                            <p className="text-gray-600">Loading Life Ninja...</p>
                            <p className="text-gray-400 text-sm mt-2">V2.11.6</p>
                        </div>
                    </div>
                );
            }
            
            // Show login screen if not authenticated
            if (!user) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md">
                            <div className="text-center mb-8">
                                <Target className="text-indigo-600 mx-auto mb-4" size={48} />
                                <h1 className="text-3xl font-bold text-gray-900 mb-2">Life Ninja</h1>
                                <p className="text-gray-600">V2.11.6 ‚Ä¢ Scroll Fixed</p>
                            </div>
                            
                            <div className="mb-6">
                                <div className="flex gap-2 mb-4">
                                    <button
                                        onClick={() => {setAuthMode('login'); setAuthError('');}}
                                        className={`flex-1 py-2 px-4 rounded-lg font-semibold transition-colors ${
                                            authMode === 'login' 
                                                ? 'bg-indigo-600 text-white' 
                                                : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                        }`}
                                    >
                                        Login
                                    </button>
                                    <button
                                        onClick={() => {setAuthMode('signup'); setAuthError('');}}
                                        className={`flex-1 py-2 px-4 rounded-lg font-semibold transition-colors ${
                                            authMode === 'signup' 
                                                ? 'bg-indigo-600 text-white' 
                                                : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                        }`}
                                    >
                                        Sign Up
                                    </button>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Email</label>
                                        <input
                                            type="email"
                                            value={authEmail}
                                            onChange={(e) => setAuthEmail(e.target.value)}
                                            placeholder="your@email.com"
                                            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter') {
                                                    authMode === 'login' ? handleEmailLogin() : handleEmailSignup();
                                                }
                                            }}
                                        />
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Password</label>
                                        <input
                                            type="password"
                                            value={authPassword}
                                            onChange={(e) => setAuthPassword(e.target.value)}
                                            placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                                            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter') {
                                                    authMode === 'login' ? handleEmailLogin() : handleEmailSignup();
                                                }
                                            }}
                                        />
                                    </div>
                                    
                                    {authError && (
                                        <div className={`p-3 rounded-lg text-sm ${
                                            authError.startsWith('‚úÖ') 
                                                ? 'bg-green-50 text-green-700' 
                                                : 'bg-red-50 text-red-700'
                                        }`}>
                                            {authError}
                                        </div>
                                    )}
                                    
                                    <button
                                        onClick={authMode === 'login' ? handleEmailLogin : handleEmailSignup}
                                        disabled={!authEmail || !authPassword || authLoading}
                                        className="w-full py-3 px-4 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                    >
                                        {authMode === 'login' ? 'Login' : 'Create Account'}
                                    </button>
                                </div>
                            </div>
                            
                            <div className="text-center text-sm text-gray-600">
                                <p className="mb-2">üîí Secure ‚Ä¢ 100% Free ‚Ä¢ Feedback: vikaslk@hotmail.com</p>
                                {authMode === 'signup' && (
                                    <p className="text-xs text-gray-500">You'll receive a verification email after signup</p>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }
            
            // Main app (only shown when logged in)
            return (
                <div 
                    className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100"
                    onDragOver={(e) => {
                        e.preventDefault(); // CRITICAL: Allow drop anywhere
                        e.stopPropagation();
                    }}
                    onDrop={(e) => {
                        e.preventDefault(); // Prevent default file drop behavior
                        e.stopPropagation();
                    }}
                >
                    {/* Header */}
                    <header className="bg-white shadow-sm">
                        <div className="max-w-7xl mx-auto px-4 py-4">
                            <div className="flex justify-between items-center">
                                <div className="flex items-center gap-3">
                                    <Target className="text-indigo-600" size={32} />
                                    <h1 className="text-2xl font-bold text-gray-900">Life Ninja</h1>
                                    <span className="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-semibold">V2.7.1</span>
                                </div>

                                <div className="flex items-center gap-4">
                                    {/* V2.5.0-SYNC: User Profile & Logout */}
                                    {user && (
                                        <div className="flex items-center gap-2 px-3 py-2 bg-green-50 border border-green-200 rounded-lg">
                                            <div className="flex items-center gap-2">
                                                <div className="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold text-sm">
                                                    {user.email[0].toUpperCase()}
                                                </div>
                                                <div>
                                                    <div className="text-sm font-semibold text-gray-900">{user.email}</div>
                                                    <div className="text-xs text-green-600">‚úì Synced</div>
                                                </div>
                                            </div>
                                            <button
                                                onClick={handleLogout}
                                                onTouchEnd={(e) => {
                                                    e.preventDefault();
                                                    handleLogout();
                                                }}
                                                className="p-3 hover:bg-green-100 rounded transition-colors min-w-[44px] min-h-[44px] flex items-center justify-center"
                                                title="Log Out"
                                                aria-label="Log Out"
                                            >
                                                <LogOut size={20} className="text-gray-600" />
                                            </button>
                                        </div>
                                    )}
                                    
                                    {/* Score display */}
                                    <div className="flex gap-4 text-sm">
                                        <div className="text-center">
                                            <div className="font-bold text-indigo-600 text-lg">{dailyScore}</div>
                                            <div className="text-gray-600 text-xs">Today</div>
                                        </div>
                                        <div className="text-center">
                                            <div className="font-bold text-purple-600 text-lg">{weeklyScore}</div>
                                            <div className="text-gray-600 text-xs">Week</div>
                                        </div>
                                        <div className="text-center">
                                            <div className="font-bold text-pink-600 text-lg">{monthlyScore}</div>
                                            <div className="text-gray-600 text-xs">Month</div>
                                        </div>
                                    </div>

                                    {/* Action buttons */}
                                    <button
                                        onClick={() => setCurrentView('bulk-import')}
                                        className="p-2 hover:bg-gray-100 rounded"
                                        title="Bulk Import"
                                    >
                                        <Upload size={20} />
                                    </button>
                                    <button
                                        onClick={exportData}
                                        className="p-2 hover:bg-gray-100 rounded"
                                        title="Export Data"
                                    >
                                        <Download size={20} />
                                    </button>
                                    <label className="p-2 hover:bg-gray-100 rounded cursor-pointer" title="Import Data">
                                        <FileUp size={20} />
                                        <input
                                            type="file"
                                            accept=".json"
                                            onChange={(e) => e.target.files[0] && importData(e.target.files[0])}
                                            className="hidden"
                                        />
                                    </label>
                                    {/* V1.3: Create Event button */}
                                    <button
                                        onClick={() => {
                                            setEditingEvent(null);
                                            setShowEventModal(true);
                                        }}
                                        className="p-2 hover:bg-gray-100 rounded bg-green-50"
                                        title="Create Event"
                                    >
                                        <Calendar size={20} className="text-green-600" />
                                    </button>
                                    {/* HIDDEN - User Request: Migrate button removed
                                    <button
                                        onClick={migrateOldData}
                                        className="p-2 hover:bg-gray-100 rounded"
                                        title="Migrate Old Data"
                                    >
                                        <ArrowRight size={20} />
                                    </button>
                                    */}
                                </div>
                            </div>

                            {/* V2.5.0-SYNC: Migration Banner */}
                            {needsMigration && (
                                <div className="mt-4 p-4 bg-yellow-50 border-2 border-yellow-300 rounded-lg">
                                    <div className="flex items-start gap-3">
                                        <div className="flex-shrink-0">
                                            <Upload className="text-yellow-600" size={24} />
                                        </div>
                                        <div className="flex-1">
                                            <h3 className="font-bold text-yellow-900 mb-1">üì§ Sync Your Tasks to Cloud</h3>
                                            <p className="text-sm text-yellow-800 mb-3">
                                                You have tasks stored locally. Click below to sync them to the cloud so they're accessible from all your devices!
                                            </p>
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={migrateToSupabase}
                                                    disabled={syncStatus === 'syncing'}
                                                    className="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-lg font-semibold disabled:opacity-50 flex items-center gap-2"
                                                >
                                                    {syncStatus === 'syncing' ? (
                                                        <>
                                                            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                                                            Syncing...
                                                        </>
                                                    ) : (
                                                        <>
                                                            <Upload size={18} />
                                                            Sync to Cloud
                                                        </>
                                                    )}
                                                </button>
                                                <button
                                                    onClick={() => setNeedsMigration(false)}
                                                    className="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg font-semibold"
                                                >
                                                    Later
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            {/* Sync Status Indicator */}
                            {syncStatus === 'syncing' && (
                                <div className="mt-2 p-2 bg-blue-50 border border-blue-200 rounded-lg flex items-center gap-2">
                                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                                    <span className="text-sm text-blue-700">Syncing...</span>
                                </div>
                            )}
                            {syncStatus === 'synced' && lastSyncTime && (
                                <div className="mt-2 p-2 bg-green-50 border border-green-200 rounded-lg flex items-center gap-2">
                                    <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                                    <span className="text-xs text-green-700">
                                        Last synced: {new Date(lastSyncTime).toLocaleTimeString()}
                                    </span>
                                </div>
                            )}
                            {syncStatus === 'error' && (
                                <div className="mt-2 p-2 bg-red-50 border border-red-200 rounded-lg flex items-center gap-2">
                                    <span className="text-sm text-red-700">‚ö†Ô∏è Sync error - will retry automatically</span>
                                </div>
                            )}

                            {/* View switcher */}
                            <div className="flex gap-2 mt-4 overflow-x-auto">
                                {[
                                    { id: 'list', label: 'List', icon: List },
                                    { id: 'calendar', label: 'Calendar', icon: Calendar },
                                    { id: 'timeline', label: 'Timeline', icon: Clock },
                                    { id: 'gantt', label: 'Gantt', icon: BarChart3 },
                                    { id: 'persona', label: 'Personas', icon: User },
                                    { id: 'project', label: 'Projects', icon: Kanban },
                                    { id: 'analytics', label: 'Analytics', icon: BarChart2 },
                                    { id: 'completion-zone', label: 'Completed', icon: Trophy } // V2.11.6
                                ].map(({ id, label, icon: Icon }) => (
                                    <button
                                        key={id}
                                        onClick={() => setCurrentView(id)}
                                        className={`px-4 py-2 rounded-lg flex items-center gap-2 whitespace-nowrap ${
                                            currentView === id
                                                ? 'bg-indigo-600 text-white'
                                                : 'bg-gray-100 hover:bg-gray-200'
                                        }`}
                                    >
                                        <Icon size={18} />
                                        {label}
                                    </button>
                                ))}

                                
                                {/* Lists buttons */}
                                {customLists.map(list => (
                                    <button 
                                        key={list.id}
                                        onClick={() => setCurrentView(`list:${list.id}`)}
                                        className={`px-3 py-2 rounded-lg text-sm font-medium flex items-center gap-1 whitespace-nowrap ${
                                            currentView === `list:${list.id}`
                                                ? 'bg-amber-600 text-white'
                                                : 'bg-amber-100 text-amber-700 hover:bg-amber-200'
                                        }`}
                                    >
                                        <Tag size={16} />
                                        {list.name} ({list.tasks.length})
                                    </button>
                                ))}
                                
                                <button 
                                    onClick={() => setShowListsModal(true)}
                                    className="px-3 py-2 rounded-lg text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200 whitespace-nowrap"
                                >
                                    + Lists
                                </button>
                            </div>
                        </div>
                    </header>

                    {/* Main content */}
                    <main className="max-w-7xl mx-auto px-4 py-6">
                        {currentView.startsWith('list:') && (
                            <IndividualListView listId={parseInt(currentView.split(':')[1])} />
                        )}
                        
                        {currentView === 'list' && <MemoizedListView newTaskTextRef={newTaskTextRef} />}
                        {currentView === 'calendar' && <CalendarView />}
                        {currentView === 'timeline' && <TimelineView />}
                        {currentView === 'gantt' && <GanttView />}
                        {currentView === 'persona' && <PersonaView />}
                        {currentView === 'project' && <ProjectView />}
                        {currentView === 'analytics' && <AnalyticsView />}
                        {currentView === 'completion-zone' && <CompletionZoneView />}
                        
                        {currentView === 'bulk-import' && (
                            <div className="bg-white rounded-lg shadow p-6">
                                <h2 className="text-2xl font-bold mb-4">Bulk Import</h2>
                                <textarea
                                    value={bulkImportText}
                                    onChange={(e) => setBulkImportText(e.target.value)}
                                    placeholder="Paste tasks (one per line)..."
                                    className="w-full h-64 px-4 py-3 border rounded-lg font-mono text-sm"
                                />
                                <div className="flex gap-2 mt-4">
                                    <button
                                        onClick={parseBulkImport}
                                        disabled={!bulkImportText.trim()}
                                        className="px-6 py-3 bg-indigo-600 text-white rounded-lg font-semibold disabled:bg-gray-300"
                                    >
                                        Import {bulkImportText.split('\n').filter(l => l.trim()).length} Tasks
                                    </button>
                                    <button
                                        onClick={() => setCurrentView('list')}
                                        className="px-6 py-3 bg-gray-200 rounded-lg"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}

                        {currentView === 'classify' && importedItems.length > 0 && (
                            <div className="bg-white rounded-lg shadow p-6">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold">Classify Task</h2>
                                    <span className="text-sm text-gray-600">
                                        {currentClassifyIndex + 1} / {importedItems.length}
                                    </span>
                                </div>
                                
                                <div className="bg-indigo-50 p-4 rounded-lg mb-4">
                                    <p className="font-medium">{importedItems[currentClassifyIndex].text}</p>
                                </div>

                                <div className="space-y-3">
                                    <button
                                        onClick={() => saveClassifiedItem({ persona: personas[0] })}
                                        className="w-full px-4 py-3 bg-indigo-600 text-white rounded-lg font-semibold"
                                    >
                                        Save & Next
                                    </button>
                                    <button
                                        onClick={() => {
                                            if (currentClassifyIndex < importedItems.length - 1) {
                                                setCurrentClassifyIndex(prev => prev + 1);
                                            } else {
                                                setCurrentView('list');
                                            }
                                        }}
                                        className="w-full px-4 py-3 bg-gray-200 rounded-lg"
                                    >
                                        Skip
                                    </button>
                                </div>
                            </div>
                        )}
                    </main>

                    {/* V1.3: Event Modal */}
                    {showEventModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowEventModal(false)}>
                            <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold">{editingEvent ? 'Edit Event' : 'Create Event'}</h2>
                                    <button onClick={() => setShowEventModal(false)} className="p-1 hover:bg-gray-100 rounded">
                                        <X size={20} />
                                    </button>
                                </div>
                                
                                <form onSubmit={async (e) => {
                                    e.preventDefault();
                                    const formData = new FormData(e.target);
                                    
                                    // Create temp ID for new events
                                    const tempId = editingEvent?.id || ('temp_event_' + Date.now());
                                    
                                    const eventData = {
                                        id: tempId,
                                        supabaseId: editingEvent?.supabaseId || null,
                                        type: 'event',
                                        text: formData.get('text'),
                                        startTime: formData.get('startTime'),
                                        endTime: formData.get('endTime'),
                                        persona: formData.get('persona'),
                                        project: formData.get('project') || null,
                                        priority: formData.get('priority'),
                                        scheduledDate: formData.get('scheduledDate'),
                                        tags: formData.get('tags').split(',').map(t => t.trim()).filter(Boolean),
                                        notes: formData.get('notes'),
                                        color: formData.get('color') || '#10b981',
                                        tasks: editingEvent?.tasks || [],
                                        createdAt: editingEvent?.createdAt || new Date().toISOString(),
                                        status: editingEvent?.status || 'upcoming',
                                        allDay: formData.get('allDay') === 'on'
                                    };
                                    
                                    if (editingEvent) {
                                        // Update existing event
                                        setEvents(prev => prev.map(e => e.id === editingEvent.id ? eventData : e));
                                        showToast('Event updated');
                                        
                                        // V2.5.0-SYNC: Save to Supabase
                                        if (user && !isLoadingFromSupabase) {
                                            await saveEventToSupabase(eventData);
                                        }
                                    } else {
                                        // Create new event
                                        setEvents(prev => [...prev, eventData]);
                                        showToast('Event created');
                                        
                                        // V2.5.0-SYNC: Save to Supabase and get real ID
                                        if (user && !isLoadingFromSupabase) {
                                            try {
                                                const savedEvent = await saveEventToSupabase(eventData);
                                                if (savedEvent && savedEvent.id) {
                                                    // Replace temp event with event using Supabase ID
                                                    setEvents(prev => prev.map(e => 
                                                        e.id === tempId 
                                                            ? { ...e, id: savedEvent.id, supabaseId: savedEvent.id }
                                                            : e
                                                    ));
                                                }
                                            } catch (error) {
                                                console.error('‚ùå Error saving new event:', error);
                                            }
                                        }
                                    }
                                    setShowEventModal(false);
                                }}>
                                    <div className="space-y-3">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Event Name *</label>
                                            <input
                                                type="text"
                                                name="text"
                                                required
                                                defaultValue={editingEvent?.text || ''}
                                                placeholder="Team Meeting, Conference, etc."
                                                className="w-full px-3 py-2 border rounded-lg"
                                            />
                                        </div>
                                        
                                        <div className="grid grid-cols-2 gap-3">
                                            <div>
                                                <label className="block text-sm font-semibold mb-1">Start Time *</label>
                                                <input
                                                    type="time"
                                                    name="startTime"
                                                    required
                                                    defaultValue={editingEvent?.startTime || '09:00'}
                                                    className="w-full px-3 py-2 border rounded-lg"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm font-semibold mb-1">End Time *</label>
                                                <input
                                                    type="time"
                                                    name="endTime"
                                                    required
                                                    defaultValue={editingEvent?.endTime || '10:00'}
                                                    className="w-full px-3 py-2 border rounded-lg"
                                                />
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Date *</label>
                                            <input
                                                type="date"
                                                name="scheduledDate"
                                                required
                                                defaultValue={editingEvent?.scheduledDate || selectedDate}
                                                className="w-full px-3 py-2 border rounded-lg"
                                            />
                                        </div>
                                        
                                        <div className="grid grid-cols-2 gap-3">
                                            <div>
                                                <label className="block text-sm font-semibold mb-1">Priority</label>
                                                <select 
                                                    name="priority"
                                                    defaultValue={editingEvent?.priority || 'medium'}
                                                    className="w-full px-3 py-2 border rounded-lg"
                                                >
                                                    <option value="low">Low</option>
                                                    <option value="medium">Medium</option>
                                                    <option value="high">High</option>
                                                    <option value="urgent">Urgent</option>
                                                </select>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-semibold mb-1">Color</label>
                                                <input
                                                    type="color"
                                                    name="color"
                                                    defaultValue={editingEvent?.color || '#10b981'}
                                                    className="w-full h-10 px-1 py-1 border rounded-lg"
                                                />
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Persona</label>
                                            <select 
                                                name="persona"
                                                defaultValue={editingEvent?.persona || personas[0]}
                                                className="w-full px-3 py-2 border rounded-lg"
                                            >
                                                {personas.map(p => <option key={p} value={p}>{p}</option>)}
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Project</label>
                                            <select 
                                                name="project"
                                                defaultValue={editingEvent?.project || ''}
                                                className="w-full px-3 py-2 border rounded-lg"
                                            >
                                                <option value="">No project</option>
                                                {projects.filter(p => !p.isNoProject).map(p => <option key={p.id} value={p.name}>{p.name}</option>)}
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Tags (comma-separated)</label>
                                            <input
                                                type="text"
                                                name="tags"
                                                defaultValue={(editingEvent?.tags || []).join(', ')}
                                                placeholder="meeting, important"
                                                className="w-full px-3 py-2 border rounded-lg"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Notes</label>
                                            <textarea
                                                name="notes"
                                                defaultValue={editingEvent?.notes || ''}
                                                placeholder="Additional details..."
                                                rows="3"
                                                className="w-full px-3 py-2 border rounded-lg"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="flex gap-2 mt-6">
                                        <button
                                            type="submit"
                                            className="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                                        >
                                            {editingEvent ? 'Update Event' : 'Create Event'}
                                        </button>
                                        <button
                                            type="button"
                                            onClick={() => setShowEventModal(false)}
                                            className="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}

                    {/* Quick Edit Modal */}
                    {showQuickEdit && quickEditTask && (
                        <div 
                            className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" 
                            onMouseDown={(e) => {
                                // Only close on background click, not when dragging started inside modal
                                if (e.target === e.currentTarget) {
                                    // Show warning that changes will be lost
                                    if (window.confirm('Close without saving? Any unsaved changes will be lost.')) {
                                        setShowQuickEdit(false);
                                    }
                                }
                            }}
                        >
                            <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md" onClick={(e) => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold">Quick Edit Task</h2>
                                    <button onClick={() => setShowQuickEdit(false)} className="p-1 hover:bg-gray-100 rounded">
                                        <X size={20} />
                                    </button>
                                </div>
                                
                                <div className="space-y-3">
                                    <div>
                                        <label className="block text-sm font-semibold mb-1">Task</label>
                                        <input
                                            type="text"
                                            value={quickEditTask.text}
                                            onChange={(e) => setQuickEditTask({...quickEditTask, text: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg"
                                        />
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Priority</label>
                                            <select 
                                                value={quickEditTask.priority}
                                                onChange={(e) => {
                                                    const newPriority = e.target.value;
                                                    // V2.7.0: Auto-update rating when priority changes
                                                    const ratingMap = {
                                                        'non-priority': 0,
                                                        'low': 2,
                                                        'medium': 5,
                                                        'high': 8,  // FIXED: Changed from 7 to 8
                                                        'urgent': 10
                                                    };
                                                    setQuickEditTask({
                                                        ...quickEditTask, 
                                                        priority: newPriority,
                                                        priority_rating: ratingMap[newPriority] !== undefined ? ratingMap[newPriority] : 5
                                                    });
                                                }}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            >
                                                <option value="non-priority">Non-priority</option>
                                                <option value="low">Low</option>
                                                <option value="medium">Medium</option>
                                                <option value="high">High</option>
                                                <option value="urgent">Urgent</option>
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Rating (0-10)</label>
                                            <select 
                                                value={quickEditTask.priority_rating !== undefined ? quickEditTask.priority_rating : 5}
                                                onChange={(e) => {
                                                    const rating = parseInt(e.target.value);
                                                    // V2.7.0: Auto-update category when rating changes
                                                    let newPriority = 'medium';
                                                    if (rating === 0) newPriority = 'non-priority';
                                                    else if (rating <= 2) newPriority = 'low';
                                                    else if (rating <= 5) newPriority = 'medium';
                                                    else if (rating <= 8) newPriority = 'high';
                                                    else newPriority = 'urgent';
                                                    
                                                    setQuickEditTask({
                                                        ...quickEditTask, 
                                                        priority_rating: rating,
                                                        priority: newPriority
                                                    });
                                                }}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            >
                                                <option value="0">0 - Non-priority</option>
                                                <option value="1">1 - Low</option>
                                                <option value="2">2 - Low</option>
                                                <option value="3">3 - Medium</option>
                                                <option value="4">4 - Medium</option>
                                                <option value="5">5 - Medium</option>
                                                <option value="6">6 - High</option>
                                                <option value="7">7 - High</option>
                                                <option value="8">8 - High</option>
                                                <option value="9">9 - Urgent</option>
                                                <option value="10">10 - Urgent</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Status</label>
                                            <select 
                                                value={quickEditTask.status}
                                                onChange={(e) => setQuickEditTask({...quickEditTask, status: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            >
                                                {getTaskStatuses(quickEditTask).map(status => {
                                                    const statusInfo = getStatusIcon(status);
                                                    return (
                                                        <option key={status} value={status}>
                                                            {statusInfo.icon} {statusInfo.label}
                                                        </option>
                                                    );
                                                })}
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Type</label>
                                            <select 
                                                value={quickEditTask.taskType}
                                                onChange={(e) => setQuickEditTask({...quickEditTask, taskType: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            >
                                                <option value="growth">Growth</option>
                                                <option value="consistency">Consistency</option>
                                                <option value="maintenance">Maintenance</option>
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Persona</label>
                                            <select 
                                                value={quickEditTask.persona}
                                                onChange={(e) => setQuickEditTask({...quickEditTask, persona: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            >
                                                {personas.map(p => (
                                                    <option key={p} value={p}>{p}</option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Project</label>
                                            <select 
                                                value={quickEditTask.project || ''}
                                                onChange={(e) => {
                                                    const newProject = e.target.value;
                                                    const projectStatuses = newProject 
                                                        ? (projects.find(p => p.name === newProject)?.statuses || ['not-started', 'in-progress', 'completed'])
                                                        : ['not-started', 'in-progress', 'completed'];
                                                    
                                                    // If current status not in new project's statuses, reset to first status
                                                    const newStatus = projectStatuses.includes(quickEditTask.status) 
                                                        ? quickEditTask.status 
                                                        : projectStatuses[0];
                                                    
                                                    setQuickEditTask({
                                                        ...quickEditTask, 
                                                        project: newProject,
                                                        status: newStatus // Auto-adjust status to match project
                                                    });
                                                }}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            >
                                                <option value="">No Project</option>
                                                {projects.filter(p => !p.isNoProject).map(p => (
                                                    <option key={p.id} value={p.name}>{p.name}</option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-3 gap-3">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Duration (min)</label>
                                            <input
                                                type="number"
                                                value={quickEditTask.estimatedDuration || 30}
                                                onChange={(e) => setQuickEditTask({...quickEditTask, estimatedDuration: parseInt(e.target.value) || 30})}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                                min="5"
                                                step="5"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Scheduled</label>
                                            <input
                                                type="date"
                                                value={quickEditTask.scheduledDate || ''}
                                                onChange={(e) => setQuickEditTask({...quickEditTask, scheduledDate: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Due Date</label>
                                            <input
                                                type="date"
                                                value={quickEditTask.dueDate || ''}
                                                onChange={(e) => setQuickEditTask({...quickEditTask, dueDate: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-lg text-sm"
                                            />
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-semibold mb-1">Time Slot</label>
                                        <select 
                                            value={quickEditTask.timeSlot || ''}
                                            onChange={(e) => setQuickEditTask({...quickEditTask, timeSlot: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        >
                                            <option value="">Unscheduled</option>
                                            {timeSlotsDisplay.map(slot => (
                                                <option key={slot.value} value={slot.value}>{slot.label}</option>
                                            ))}
                                        </select>
                                    </div>
                                </div>
                                
                                <div className="flex gap-2 mt-6">
                                    <button
                                        onClick={() => {
                                            // Check if this is a subtask
                                            if (quickEditTask.isSubtask && quickEditTask.parentId) {
                                                // Save subtask back to parent
                                                updateSubtask(quickEditTask.parentId, quickEditTask.id, {
                                                    text: quickEditTask.text,
                                                    priority: quickEditTask.priority,
                                                    taskType: quickEditTask.taskType,
                                                    persona: quickEditTask.persona,
                                                    timeSlot: quickEditTask.timeSlot,
                                                    estimatedDuration: quickEditTask.estimatedDuration,
                                                    dueDate: quickEditTask.dueDate,
                                                    notes: quickEditTask.notes
                                                });
                                                showToast('Subtask updated!');
                                            } else {
                                                // Regular task - save normally
                                                setTasks(prev => prev.map(t => 
                                                    t.id === quickEditTask.id ? quickEditTask : t
                                                ));
                                                showToast('Task updated!');
                                            }
                                            setShowQuickEdit(false);
                                        }}
                                        className="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
                                    >
                                        Save
                                    </button>
                                    <button
                                        onClick={() => setShowQuickEdit(false)}
                                        className="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300"
                                    >
                                        Skip
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Lists Management Modal - V2.7.1 FIXED: Separate component for focus retention */}
                    {showListsModal && <ListsManagementModal />}
                    
                    {/* V1.3.1: Task Mover Modal (Drag-drop fallback) */}
                    {showTaskMover && taskToMove && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowTaskMover(false)}>
                            <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md" onClick={(e) => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold">Move Task</h2>
                                    <button onClick={() => setShowTaskMover(false)} className="p-1 hover:bg-gray-100 rounded">
                                        <X size={20} />
                                    </button>
                                </div>
                                
                                <div className="mb-4">
                                    <p className="text-sm text-gray-600 mb-2">
                                        <strong>Task:</strong> {taskToMove.text}
                                    </p>
                                </div>
                                
                                <form onSubmit={(e) => {
                                    e.preventDefault();
                                    const formData = new FormData(e.target);
                                    const newDate = formData.get('date');
                                    const newSlot = formData.get('timeSlot');
                                    
                                    if (newDate) {
                                        updateTask(taskToMove.id, { 
                                            scheduledDate: newDate,
                                            timeSlot: newSlot || taskToMove.timeSlot
                                        });
                                        showToast(`Task moved to ${newDate}${newSlot ? ' at ' + newSlot : ''}`, true);
                                        setShowTaskMover(false);
                                        setTaskToMove(null);
                                    }
                                }}>
                                    <div className="space-y-4">
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Move to Date</label>
                                            <input
                                                type="date"
                                                name="date"
                                                defaultValue={taskToMove.scheduledDate || formatDate(new Date())}
                                                className="w-full px-3 py-2 border rounded-lg"
                                                required
                                            />
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-semibold mb-1">Time Slot (Optional)</label>
                                            <select
                                                name="timeSlot"
                                                defaultValue={taskToMove.timeSlot || ''}
                                                className="w-full px-3 py-2 border rounded-lg"
                                            >
                                                <option value="">No specific time</option>
                                                {Array.from({length: 48}, (_, i) => {
                                                    const hour = Math.floor(i / 2);
                                                    const minute = (i % 2) * 30;
                                                    const time = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                                                    return <option key={time} value={time}>{time}</option>;
                                                })}
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="flex gap-2 mt-6">
                                        <button
                                            type="button"
                                            onClick={() => setShowTaskMover(false)}
                                            className="flex-1 px-4 py-2 border rounded-lg hover:bg-gray-50"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            type="submit"
                                            className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                        >
                                            Move Task
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}
                    
                    {/* Toast notification */}
                    {toast && (
                        <Toast
                            message={toast.message}
                            showUndo={toast.showUndo}
                            onClose={() => setToast(null)}
                            onUndo={handleUndo}
                        />
                    )}
                    
                    {/* V1.4.2: Drag Ghost Preview */}
                    {isDragging && draggedTask && dragStartPos && (
                        <div
                            style={{
                                position: 'fixed',
                                left: `${dragStartPos.x + 10}px`,
                                top: `${dragStartPos.y + 10}px`,
                                pointerEvents: 'none',
                                zIndex: 9999,
                                opacity: 0.8,
                                transform: 'rotate(-3deg)',
                                transition: 'none'
                            }}
                            className="bg-white border-2 border-blue-500 rounded-lg shadow-2xl p-3 max-w-xs"
                        >
                            <div className="flex items-center gap-2">
                                <GripVertical size={16} className="text-gray-400" />
                                <div className="flex-1 font-medium truncate">{draggedTask.text}</div>
                            </div>
                            <div className="text-xs text-gray-500 mt-1">
                                Drop on timeline slot
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the app
        const root = createRoot(document.getElementById('root'));
        root.render(<LifeNinjaApp />);
    </script>
</body>
</html>